【C primer Plus自学】

【第一章】初识

C语言历史和特性；
程序编写步骤；
编译器和链接器；
C标准；

1.4 	计算机能做什么
	计算机组成：
	①中央处理单元 CPU；
	②随机存储内存RAM；
	③永久内存存储 硬盘；
	④支持设备、外设等；

	CPU：	从内存获取并执行一条指令；然后再下一条；
		CPU有自己的小工作区；若干个寄存器；寄存器可存储一个数字；
		一个寄存器存储下一条指令的内存地址（寄存器a）；
		CPU用该地址来获取和更新下一条指令；
		CPU在获取指令后，在另一个寄存器（寄存器b）存储该指令；并更新寄存器a的下一个地址；
	CPU能理解的指令有限（指令集）多数用于将一个数从一个位置移动到另一个位置；
	存储在计算机内的所有内容都是数字；
	计算机程序最终都必须以数字指令码来表示；
	
	计算机工作原理：
	如果希望计算机做某些事：
	1.必须为其提供特殊的指令列表（程序）；确切的告诉它要做的事以及如何做；
	2.必须用计算机直接明白的语言（机器语言）创建程序；
	例如：两数相加；
		①从内存位置2000上，把一个数字拷贝到寄存器1；
		②从内存位置2004上，把一个数字拷贝到寄存器2；
		③把寄存器2和寄存器1中的内容相加，将结果存在寄存器1中；
		④将寄存器1中的内容拷贝到内存位置2008；

1.5 	高级计算机语言和编译器
	高级编程语言在计算机看来是一堆无法理解的无用数据；
	编译器：将高级程序语言翻译成机器语言指令集；

1.6 	C语言标准：C89/C90  C99  C11

1.7 	使用C语言的7个步骤
	1.定义程序目标：用一般术语表达；比如：
		程序需要那些信息（输入）；
		程序需要进行哪些计算和控制（运行）；
		程序应该报告什么信息（输出）；
	2.设计程序：比如：用户界面？组织程序？目标用户？如何表达数据？数据处理方法？
	3.编写代码：用文本编辑器创建源代码；
	4.编译：
		①将源代码转换成可执行代码（机器语言）；
		②将源代码和库代码合并成最终程序（链接器），生成可执行文件；
	5.运行程序：
		①常规环境（Windows带命令提示符、UNIX、LinUX）输入可执行文件名；
		②集成开发环境（IDE）菜单选项或者特殊键（单双击）执行；
	6.测试、调试程序：查找并修复程序错误（debug）;
	7.维护和修改代码；
	*程序越庞大越复杂，事先定义和程序设计环节工作量越大；

1.8 	编程机制
	源代码――编译器――目标代码――链接器――可执行代码
	(.c文件)		(.obj文件)	   库代码       (.exe文件)	
	  code		 目标文件	   启动代码    应用程序文件

【第二章】概述
运算符：=
函数main()、printf()
编写一个简单C程序；
创建整型变量，为其赋值并打印；
换行字符；
注释；多个函数程序；
关键字；


	

2.1
	#include<stdio.h>		//包含另一个文件；
	int main(void)		//主函数名；
	{			//表面函数开始；
		int a;		//声明变量a；
		a=1;		//赋值表达式；
		printf("%d",a);	//调用一个函数printf();	
		return 0;		//返回值；
	}			//函数结束；
2.2
	1. #include指令和头文件
	#include<stdio.h>相当于将stdio.h文件中的所有内容输入该行；实质为复制粘贴；方便共享许多程序共有信息；
	#include是一条C语言预处理信息；#表明C预处理器在编译器接手前处理这条指令；
	通常在C程序顶部信息集合，称为头文件；
	特定C实现的文档中应包含对C库函数的说明，确定了使用哪些函数需要用到哪些头文件；

	2. main()函数
	C程序一定从main()函数开始执行，除了main()函数可以任意命名其他函数名；
	int是main()函数的返回类型，返回整数给操作系统；
	int main(void)：	()内包含了一些传入函数的信息，若不需要传递任何信息，()内用单词void；

	3. 注释  // 注释到本行结尾   /*……*/ 注释掉中间部分内容；
	
	4. 花括号{}标记函数开始与终结；

	5. 声明
	int a;	这行代码完成两件事；①声明函数中有个变量a；②int表明变量a是个整数；
		int是一种数据类型，编译器以此为变量a在内存中分配存储空间；
		a  是一种标识符，是一个变量、函数或者其他实体的名称；
		C语言中所有变量都必须声明后才能使用；
	命名：尽量使用有意义的变量名；编译器能识别前63字符，可以用大小写数字下划线命名，第一位不能用数字；

	6. 赋值：
	a=1；	在执行声明时，编译器在内存中为变量a预留了空间，赋值时将值存储在预留位置；
		赋值表达式为从右侧将值赋到左侧；
		C语言是通过赋值运算而不是赋值语句完成操作；
	
	7. printf()函数
		printf()括号中的内容为main()函数传递给printf()函数的信息；()内信息为函数实际参数；
		①实际参数：传递给函数的特定值；
		②形式参数：函数中用于储存变量的值；
	
	8. return语句
		int main(void)函数中的int表明main()函数应返回一个整数；有返回值的函数需要有return语句；
		return语句是一种跳转语句；

【练习题1.】
	编写一个程序，把你的姓名打印在一行，输出如下：

	Gustav Mahler	//第1次打印的内容
	Gustav 		//第2次打印的内容
	Mahler		//仍是第2次打印的内容
	Gustav Mahler	//第3、4此打印的内容

	#include<stdio.h>
	int main(void)
	{
		printf("Gustav Mahler\n");
		printf("Gustav\nMahler\n");
		printf("Gustav ");
		printf("Mahler\n");
		getchar();
		return 0;
	}

【练习题2.】
	编写一个程序，打印你的姓名和地址。

	#include<stdio.h>
	int main(void)
	{
		printf("Name:***\nAddress:Room***, unit***, building**,***Road,***District,***City,***Province\n");
		getchar();
		return 0;
	}

【练习题3.】
	编写一个程序，把你的年龄转换成天数，并显示这两个值，不考虑闰年问题。

	#include<stdio.h>
	int main(void)
	{
		int age, day;
		age = 18;
		day = age * 365;
		printf("Your age:%d\nConvert age to days:%d\n", age, day);
		getchar();
		return 0;
	}

【练习题4.】
	编写一个程序，生成以下输出;除了main()函数以外，自定义两个函数；
	hello world
	hello world
	hello world
	i'm good

	#include<stdio.h>
	void hello(void){printf("hello world\n");}
	void good(void){ printf("i'm good\n"); }
	int main(void) 
	{
		hello(); 
		hello();
		hello();
		good();
		getchar();
		return 0;
	}

【练习题5.】
	编写一个程序，生成以下输出；除了main()函数外，自定义两个函数br()和ic()分别为“Brazil,Russia”;和“India,China”;
	各依次调用并打印一次，其余内容在main()函数中完成。

	Brazil,Russia,India,China
	India,China，
	Brazil,Russia

	#include<stdio.h>
	void br(void) { printf("Brazil,Russia"); }
	void ic(void) { printf("India,China"); }
	int main(void) 
	{
		br();
		printf(",");
		ic();
		printf("\n");
		printf("India,China,\n");
		printf("Brazil,Russia");
		getchar();
		return 0;
	}

【练习题6.】
	编写一个程序，创建一个整型变量toes，并将toes设置为10.程序中还要计算toes的两倍和平方并打印和描述；

	#include<stdio.h>
	int main(void) 
	{
		int toes;
		toes = 10;
		printf("toes=%d\n2*toes=%d\ntoes*toes=%d\n", toes, 2 * toes, toes*toes);
		getchar();
		return 0;
	}

【练习题7.】
	编写一个程序，生成以下格式输出；自定义一个函数，调用一次打印一次“smile!”
	smile!smile!smile!
	smile!smile!
	smile!
	
	#include<stdio.h>
	void smile(void) { printf("smile!"); }
	int main(void) 
	{
		smile(); 
		smile();
		smile();
		printf("\n");
		smile();
		smile();
		printf("\n");
		smile();
		printf("\n");
		getchar();
		return 0;
	}

【练习题8.】
	编写一个函数，调用one()的函数打印“one”调用two()函数打印“two”，要求输出如下：
	starting now:
	one
	tow
	three
	done!


	#include<stdio.h>
	void one(void) { printf("one"); }
	void two(void) { printf("two"); }
	int main(void) 
	{
		printf("starting now\n");
		one();
		printf("\n");
		two();
		printf("\n");
		printf("three\n");
		printf("done!\n");
		getchar();
		return 0;
	}

【第三章】数据和C

关键字int、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary
运算符 sizeof()
函数 scanf()
整数类型和浮点数类型的区别；


3.1	
	#include<stdio.h>
	int main(void)
	{
		float weight;	//浮点数变量
		float value;
		float prince;
		prince=1700.0;
		printf("please enter your weight in pounds: ");
		scanf_s("%f",&weight);	//scanf_s()读取键盘输入；%f浮点数占位符
		value=prince*weight*14.5833;	//变量与常量；
		printf("your weight in platinum is worth $%.2f.\n",value);	//%.2f .2控制精度
		printf("if platinum princes drop,eat more maintain your value.\n");
		getchar();
		getchar();
		return 0;
	}

3.3
	【数据类型关键字】

            【K&C】		【C90】		【C99】

	int		signed		_Bool
	long		void		_Complex
	short				_Imaginary
	unsigned
	char
	float
	double

	【位、字节和字】

	最小的存储单元是位(bit)，可以存储0或1；
	字(byte)节是常用的计算机存储单位;
	1字节=8位 1byte=8bit;
	既然1位可以表示0或者1，8位字节就有256种可能组合(2的8次方)；
	通过二进制编码，便可表示0-255的整数或一组字符；
	字(word)、计算机进行数据处理时，一次存取、加工和传送的数据长度称为字(word)；
	字长越大，数据转移越快；允许访问的内存也更多；

	【整数和浮点数】
	整数：2进制存储；最高位设置为符号位，1代表负数(负数补码=负数反码)，0代表正数(正数原码=反码=补码)；
	浮点数：与整数存储方案不同；采用小数部分+指数部分来表示；

3.4
	【int类型】（有符号整型）
		
	int类型的值必须是整数，可以是正整数、负整数或0，取值范围随系统，ISO C规定最小16位(-32768~32767)；
	
	1.声明int变量	
	int a;
	int b;
	int a,b;

	给变量提供值的方法：

	①赋值：
		int a;
		a=1;
	②函数获取：
		int a;
		scanf_s("%d",&a);
	

	2.初始化变量：C语言中可以直接在声明中给变量赋一个初始值
		int a=1;
	
	声明其实已经位变量创建和标记了存储空间，若初始化在声明里，则为其直接指定初始值；

	3.int类型常量
	C语言把不含小数点和指数的数作为整数，如22和-44是整型常量，但22.0和2.2E1则不是；
	C语言把大多数整型常量视为int类型，但是非常大的整数除外（long常量）；
	
	4.打印 int 值
	可以使用printf()函数；%d称为"转换说明”,它指定了printf()函数应使用什么格式来显示一个值；
	使用printf()函数时，要确保转换说明数量%d与待打印值的变量数相等，若无指定，将读取内存中任意值

	5.八进制和十六进制
	计算机如何10000是十进制十六进制还是二进制？C语言中用特定的前缀表示；
	0x或者0X前缀表示十六进制  	例如十进制16等于十六进制0x10
	0前缀表示八进制；		例如十进制16等于八进制020
	
	6.显示八进制和十六进制；
	%d――十进制
	%o――八进制
	%x――十六进制
	另外若要显示后两种进制数的前缀0、0x或0X，分别使用%#o、 %#x、 %#X，例如打印十进制的100：

	#include<stdio.h>
	int main(void)
	{
		int a = 100;
		printf("dec=%d,	octal=%o,	hex=%x\n", a, a, a);//十进制、八进制、十六进制
		printf("dec=%d,	octal=%#o,	hex=%#x,	hex=%#X\n", a,a,a,a);
		getchar();
		return 0;
	}

	【其他整数类型】：

	short int 类型(或简写为short)用于较小数值的场合以节省空间，是有符号类型；
	long  int 类型(或简写为 long)用于较大数值的场合，也是有符号类型；
	long long int (或简写为 long long)占用64位以上的更大数值场合，也是有符号类型；
	unsigned int  (或简写为unsigned)只用于非负数值的场合，
		例如16位取值范围为0~65535，而非-32768~32767，是用符号位拿来存二进制位；
	在任何有符号类型前面添加关键字signed，可强调使用有符号类型的意图。

	1.声明其他整数类型：与int相同；

	2.int long short 只规定了占位大小关系，因为对16位机或者32位机甚至64位机对应的取值范围不同；
	   通常个人PC最常见设置 long long占64位，long占32位，short占16位，int占16或32位(依计算机字长)；
	  ① 当取值范围在int内，尽量不用long，，使用long类型会减慢运算速度；其他关键字类推；
	  ②若需要从32位机移植程序到16位机的情况，若有当需要用到32位数字时，用long，其他关键字类推；

	3.long 和long long
	通常程序中使用的数字会被存储为int类型；
	若超出范围，编译器依次视其为long----unsigned long----long long-nusigned long long
	特定情形下需要用long存储一个小数字，可以加个后缀l或者L 大写字母易区分1与l；如7L；9LL；
	
	整数溢出
	#include<stdio.h>
	int main(void)
	{
		int a=2147483647;
		unsigned int b=4294967295;
		printf("%d %d %d\n",a,a+1,a+2);
		printf("%u %u %u\n",b,b+1,b+2);
		getchar();
		return 0;
	}

	观察结果，溢出后数字从定义类型范围的最小始开始
	最小看取值范围int、 unsigned int
	本例中int为32位（+标识符加31位数字，二进制下为+2147483647）范围(-2147483648~2147483647)
	所以unsigned范围为（0~4294967295）例题中a+1和b+1数字溢出后从最小处重新开始取值；

	4.打印short、long、long long和unsigned
	short		――%hd；（%hx；%ho）	//十进制、十六进制、八进制；
	long		――%ld；（%lx；%lo）	//常量后缀在转换说明里只能用小写；
	long long		――%lld；（%lldx;%lldo）
	
	unsigned		――%u；

	nusigned short	――%hu;
	unsigned long	――%lu；
	nusigned long long	――%llu；
	
	#include<stdio.h>
	int main(void)
	{
		unsigned a = 3000000000;	//int为32位下系统；
		short b = 200;
		long c = 65537;
		long long d = 12345678908642;

		printf("a=%u not %d \n", a, a);
		printf("b=%hd and %d \n", b, b);
		printf("c=%ld not %hd \n", c, c);
		printf("d=%lld not %ld", d, d);

		getchar();
		return 0;
	}
	
	①第一行输出：%d和%u的区别在于signed和unsigned的区别，两个输出不同的值在内存中的二进制排列相同；
	   但是在signed读取的时候，最高位的数字被读取成符号位；unsigned则直接为数字一部分；
	   在两个数集的交集部分，则两者输出结果相同；
	②第二行输出：输出结果相同，C编译器把short类型的值自动转换成int类型的值；int类型参数传递快效率高；
	③第三行输出：使用h修饰符可以显示较大整数被截断成short类型值的情况；
	   65537在32位里二进制是0000 0000 0000 0001 0000 0000 0000 0001 %hd只会查看后16位，所以显示为1；
	④同上；

	综上，不管是unsigned、整数溢出或者转换说明的出错，其实质都是定义数集合的范围不一样导致的；
	存储在内存中的二进制数，对不同的定义和转换说明，读取到的排列序，即在这个定义集合里的值都不一样；
	计算机能存储的状态就是0和1的有限组合，同样的组合能根据用户的定义给出更多的不同值的表达；

	【char类型】

	char类型用于存储字符，但从技术层面看，char是整数类型，char实际上存储的是整数而不是字符。

	ASCII编码――字符的本质：

	#include<stdio.h>	
	int main(void)
	{
		int i;
		for (i = 0; i <= 127; i++) 	//0-127或者0-255ASCII拓展表
			printf("%d %c\n", i, i); 
		getchar();
		return 0;
	}
	C语言把1字节定义为char类型占用的位数(bit)，因此16位或者32位系统都可以使用char类型

	1.声明char类型变量
	char a;
	char a,b;
	
	2.字符常量和初始化
	char a;
	char a='A';	//正确赋值字符初始化常量，A是字符；
	char a=A;		//错误，此时A是一个变量；
	char a="A"	//错误，此时"A"是一个字符串；
	char a=65; 	//前提是系统使用ASCII码，不推荐；

	*C语言将字符常量视为int类型而非char类型；
	例如int为32位，char为8位，可以将4个独立的ASCII编码储存在32位存储单元中;
	试运行下列代码：

	#include<stdio.h>
	int main(void)
	{
		char a='FATE';
		printf("%c\n", a);
		getchar();
		return 0;
	}
	实际这样的字符常量赋给char类型，只有最后8位有效，所以显示的是字母E；

	再试试下面的代码:

	#include<stdio.h>
	#include<windows.h>
	int main(void)
	{
		char a;
		scanf_s("%c", &a);
		printf("%c\n", a);
		Sleep(2000);
		return 0;
	}
	尝试输入多个字母，显示的仍为第一个输入的字母；

	3.非打印字符/控制字符
	如何表达这些字符
	①用ASCII码	char beep=7;
	②转义序列使用转义字符表达	char nerf='\n';
	\a	警报
	\b	退格
	\f	换页
	\n	换行
	\r	回车
	\t	水平制表符
	\v	垂直制表符
	\\	反斜杠\
	\'	单引号
	\"	双引号
	\?	问好
	\0oo	八进制值(oo八进制数，即每个o可表示0~7中的一个数)
	\xhh	十六进制值(hh十六进制数，即每个h可表示0~f中的一个数)
	
	4.打印字符

	#include<stdio.h>	
	int main(void)
	{
		char ch = 'C';
		printf("%c is %d", ch, ch);
		getchar();
		return 0;
	}


	printf()函数用%c打印字符，printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式:
	
	存储方式：  ch: 0100 0011（ASCII码中字符C）
	读取方式	%c――输出图形字符 C
		%d――输出十进制值 67
	
	5.有符号还是无符号
	根据C90标准，C语言允许在关键字char前面使用signed(-128-127)或unsigned(0-255);
	这在用char类型处理小整数时很有用，如果只用处理char处理字符，则无需任何修饰符；

	【_Bool类型】

	C99标准添加表示布尔值，即逻辑true和false；C语言用1和0表示，原则上它仅占用1位存储空间

	【可移植类型：stdint.h和inttypes.h】

	C语言提供了许多整数类型，但是某些型名在不同系统中功能不一样；
	C99新增的两个头文件；以却把C语言的类型在各个系统中的功能相同；
	stdint.h头文件：
	精确宽度整数类型，如int32_t表示整数类型的宽度正好是32位；
	最小宽度类型，如int_least8_t表示可容纳8位有符号整数值的类型中宽度最小的类型的一个别名；
	最快最小宽度类型，如int_fast8_t定义为系统中对8位有符号值而言运算最快的整数类型的别名；
	最大整数类型，如intmax_t,可存储任何有效的有符号的整数，unitmax_t表示最大无符号整数类型；
	
	C99和C11不仅提供可移植的类型名，还提供相应的输入和输出；
	比如printf()打印特定类型时，要求对应的转换说明匹配，int32_t类型的值，有%d、%ld的区分使用；
	C标准针对这情况，提供了一些字符串宏来显示可移植类型，如inttypes.h头文件中定义了PRId32字符串宏；
	范例：

	#include<stdio.h>	
	#include<inttypes.h>//支持可移植类型
	int main(void)
	{
		int32_t m32;	//声明m32为一个32位有符号整型变量;
		m32 = 45933945;
		printf("m32=%d\n", m32);
		printf("m32=%"PRId32"\n",m32);
		getchar();
		return 0;
	}
	 
	在最后一行printf()中，参数PRId32被定义在inttypes.h中的“d”替换，所以输出相等；

	【float、double 和 long double】

	浮点数的表示类似于科学记数法――指数记数法(科学记数法在计算机中的写法)；例：
	
	数字		科学记数法	指数记数法
	1000000000	1.0*10^9		1.0e9
	123000		1.23*10^5		1.23e5
	322.56		3.2256*10^2	3.2256e2
	0.00056		5.6*10^-5		5.6e-5
	
	C标准规定，float类型必须至少能表示6位有效数字，取值范围10e-37~10e37
	一般系统储存一个浮点占用32位，其中8位表示指数的值和符号，24位表示非指数部分(尾数/有效数)及其符号；
	C语言提供的另一种浮点类型是double(双精度)，至少能表示10位有效数字，一般占用64位；

	1.声明浮点型变量 与整型变量相同；

	2.浮点型常量：
	有符号的数字(包括小数点)后面跟e或者E最后是一个有符号数表示10的指数，如：
	-1.56E+12;
	2.87e-3;
	正号可以省略；不要在浮点型常量中间加空格；
	可以没有小数点如2E5或没有指数部分如19.28；但不能同时省略两者；
	可以省略小数部分如3.E16或整数部分如.45E-6,但是不能同时省略两者；
	常量示例：
	3.14159
	.2
	4e16
	.8e-5
	100.
	
	默认情况下，编译器假定浮点型常量是double类型的精度，比如
	float some;
	some=4.0*2.0;
	通常4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘机截断成float宽度；
	这样计算精度更高，但会减慢程序运行速度，所以在浮点数后面加上f或者F可以覆盖默认设置；
	使用l或L后缀可以使数字称为long double类型；没有后缀的浮点型常量是double类型；
	
	C99添加了一种新的浮点常量格式，用十六进制表示浮点型常量
	在十六进制数前加上十六进制前缀(0x或0X)，用p或者P分别代替e和E，用2的幂代替10的幂（P记数法）
	如 0xa.1fp10
	十六进制下,a等于十进制10，.1f是1/16加上15/256(f等于10进制15)，p10是2^10即1024；
	0xa.1fp10表示的十进制值为（10+1/16+15/256）*1024=10364.0

	3.打印浮点值
	printf()函数使用%f转换说明打印float和double类型浮点数；
	用%e打印指数记数法的浮点数；如果系统支持十六进制格式的浮点数，可用a或A分别代替e和E；
	打印long double使用 %Lf、%Le或者%La转换说明；
	给那些未在原型中显式说明参数类型的函数传递参数时，C编译器会把float类型的值自动换成double类型；
	例：两种方式显示float类型的值
	
	#include<stdio.h>	
	int main(void)
	{
		float a = 32000.0;
		double b = 2.14e9;
		long double c = 5.32e-5;
		printf("a=%f = %e\n",a, a);		//a=32000.000000=3.200000e+04
		printf("hexadecimal:\na = %a\n\n",a);	//a=0x1.f400000000000p+14
		printf("b=%f = %e\n", b, b);		//b=2140000000.000000=2.140000e+09
		printf("c=%Lf = %Le\n", c, c);		//c=0.000053=5.320000e-05
		getchar();
		return 0;
	}
	
	4.浮点值的上溢和下溢；

	①上溢范例：
	#include<stdio.h>	
	int main(void)
	{	
		float big = 3.4e38*100.0f;
		printf("%e\n", big);		//输出结果：inf或者infinity无穷大，上溢；
		getchar();
		return 0;
	}
	
	C语言规定当计算导致数字过大，超过当前类型能表达的范围时，给变量赋一个表示无穷大的值；
	
	②下溢范例：
	#include<stdio.h>	
	int main(void)
	{	
		float big = 0.1e-44/2;
		printf("%e\n", big);		//输出结果0.000000e+00
		getchar();
		return 0;
	}
	
	C语言把损失了类型全精度的浮点数称为‘低于正常的浮点值’
	
	还有另一个特殊的浮点值NaN(not a number);
	例如给asin()函数传递一个值，该函数返回一个角度，该角度的正弦就是传入的函数的值；
	但正弦值不能大于1，因此如果传入的参数大于1，该函数的行为是未定义的，函数返回NaN；

	演示舍入错误：

	#include<stdio.h>	
	int main(void)
	{	
		float a, b;
		a = 2.0e20 + 1.0;
		b = a - 2.0e20;
		printf("%f", b);	//输出：4008175468544.000000
		getchar();
		return 0;
	}
	
	原因为计算机缺少足够的小数位来完成正确运算；
	2.0e20 是2后面有20个0；如果把该数加1，那么发生变化的是第21位，要正确计算，程序至少要存储21位数字；
	而float类型的数字通常只能存储按指数比例缩小或放大的6或7位有效数字；

	显示精度问题

	#include <stdio.h>	
	int main()
	{
	float a;
	double b;
	a=3.1415926535897932;
	b=3.1415926535897932;	
	printf("%.15f",a);		//输出结果a=3.141592741012573;".15"表示保留小数点后15位
	printf("%.15lf",b);		//输出结果a=3.141592653589793
	getchar();			
	return 0;
	}

	【复数和虚数类型】

	3种复数类型，float_Complex、double_Complex、long double_Complex
	3种虚数类型，float_Imaginary、double_Imaginary、long double_Imaginary
	
	【其他类型】
	
	数组、指针、结构和联合等

	指针――指向变量或其他数据对象位置，如scanf()函数里用到的前缀&，告诉函数把数据放在何处；
		
	【类型大小】
	如何知道当前系统的指定类型大小是多少？%zd 或者%u %lu;

	#include<stdio.h>
	int main(void)
	{
		printf("int size =%zd bytes\n", sizeof(int));
		printf("short size =%zd bytes\n", sizeof(short));
		printf("long size =%zd bytes\n", sizeof(long));
		printf("long long size =%zd bytes\n", sizeof(long long));
		printf("unsigned size =%zd bytes\n", sizeof(unsigned));
		printf("char size =%zd bytes\n", sizeof(char));
		printf("float size =%zd bytes\n", sizeof(float));
		printf("double size =%zd bytes\n", sizeof(double));
		printf("long double size =%lu bytes\n", sizeof(long double));
		getchar();
		return 0;
	}
	
3.5
	【合理选用变量类型】

	int a=3			//正确
	int b=3.0			//不推荐；
	int c=12.99		//取值C为12，int截断小数部分，精度丢失严重
	float d=3.1415926536	//损失精度；float只保证前6位精度，编译器警告；
	
3.6	【参数与陷阱】

	printf() 和 scanf()与一般函数不同，他们的参数个数是可变的；
	第一个字符串的转换说明与后面的参数需一一对应；
	程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹配；
	错误示例：
	#include<stdio.h>
	int main(void)
	{
		int m = 4;
		int n = 5;
		float f = 7.0f;
		float g = 8.0f;
		printf("%d\n", n, m);		//参数太多
		printf("%d %d %d\n", n);	//参数太少
		printf("%d %d\n", f, g);	//转换说明类型不匹配
		getchar();
		return 0;
	}
		
3.7	【转义序列】
	
	#include<stdio.h>
	int main(void)
	{
		float salary;
		printf("\aEnter your salary:");	
		printf(" $________\b\b\b\b\b\b\b");
		scanf_s("%f",&salary);
		printf("\n\t$%.2f a month is $%.2f a year.",salary,salary*12.0);
		printf("\rGee!\n");
		getchar();
		getchar();
	}

	
	最初，printf()语句把输出发送到一个叫做缓冲区的中间存储区域，然后再发送到屏幕上；
	当缓冲区满、遇到换行字符或者需要输入的时候，刷新缓冲区；
	(从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区；)
	旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示任何内容，等待用户输入；
	在这种情况下，可以在示例中第一行输出末尾加入换行字符\n刷新缓冲区。

3.8	计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大差别；
	即使两个32位存储单元存储的位组合完全相同，但一个解释为float类型，另一个解释为long类型；
	这两个相同的位组合表示的值也完全不同；举例：
	假设一个位组合表示float类型的数256.0，如果将其解释为long类型，则值是113246208；
	#include<stdio.h>
	int main(void)
	{
		float a;
		a = 256.0;
		printf("%.1f = %lld",a,a);	//VS2017输出为long long类型4643211215818981376
		getchar();
		getchar();
	}

【练习题1.】
	通过试验(编程验证)观察系统如何处理整数上溢、浮点数上溢和下溢的情况；

	#include<stdio.h>
	int main(void)
	{
		int a;
		float b,c;
		a=1000000000000000;
		b=3.5e+60;
		c=1/b;
		printf("%d\n",a);
		printf("%f\n",b);
		printf("%f\n",c);
		getchar();
		return 0;
	}

【练习题2.】
	编写一个程序，要求提示输入一个ASCII码值(如，66)，然后打印输入的字符；

	#include<stdio.h>
	int main(void)
	{
		int ASCII;
		printf("输入一个ASCII可打印码值(33-127): ");
		scanf_s("%d",&ASCII);
		printf("%c",ASCII);
		getchar();
		getchar();
		return 0;
	}

【练习题3.】
	编写一个程序，发出一声警报，然后输出下面文本：“what was that!”
	
	#include<stdio.h>
	int main(void)
	{
		printf("\awhat was that!\n");
		getchar();
		return 0;
	}

【练习题4.】
	编写一个程序，读取一个浮点数，先打印成小数点形式，再打印成指数形式，如果系统支持，再打成P记数法；
	按以下格式输出：

	Enter a floating-point value: 64.25
	fixed-point notation: 64.250000
	exponential notation: 6.425000e+01
	p notation: 0x1.01p+6

	#include<stdio.h>
	int main(void)
	{
		float pr;
		printf("Enter a floating-point value: ");
		scanf_s("%f", &pr);
		printf("fixed-point notation: %lf\n", pr);
		printf("exponential notation: %e\n", pr);
		printf("p notation: %a\n", pr);
		getchar();
		getchar();
		return 0;
	}

【练习题5.】
	一年大约有3.156*10^7秒。编写一个程序，提示用户输入年龄，然后显示该年龄对应的秒数；

	#include<stdio.h>
	int main(void)
	{
		double sec;
		float age;	
		printf("Enter your age: ");
		scanf_s("%f", &age);
		sec = age * 3.156e+7;
		printf("your ages change to sec = %e", sec);
		getchar();
		getchar();
		return 0;
	}

【练习题6.】
	1个水分子的质量约为3.0*10^-23克，1夸脱水大约是950克，输入水的夸脱数，求水分子数量；

	#include<stdio.h>
	int main(void)
	{
		double qty;	//水分子数量
		double m;
		m = 3.0*10e-32;	//每个水分子的质量；
		float quarts;	//输入的水的夸脱数；
		printf("Enter the number of quarts for water ");
		scanf_s("%f",&quarts);
		qty = quarts * 950 / m;
		printf("there are %e of water molecules", qty);
		getchar();
		getchar();
		return 0;
	}

【练习题7.】
	1英寸相当于2.54厘米。编写一个程序，输入身高(英寸)，然后显示厘米单位身高。

	#include<stdio.h>
	int main(void)
	{
		float height;	//身高cm
		float inch;		//身高in
		printf("Enter your height by inch: ");
		scanf_s("%f", &inch);
		height = inch * 2.54;
		printf("your height is %.1f cm", height);
		getchar();
		getchar();
	}

【练习题8.】
	编写一个程序，用户输入杯数，以其他单位容量显示等价容量；
	1品脱=2杯；1杯=8盎司；1盎司=2汤勺；1汤勺=3茶勺；
	
	#include<stdio.h>
	int main(void)
	{
		float pint, cup, oz, tbsp, tsp;
		printf("Enter the number of cup: ");
		scanf_s("%f", &cup);
		pint = 0.5*cup;
		oz = 8 * cup;
		tbsp = 2*oz;
		tsp = 3*tbsp;
		printf("%.2f cup=%.2f pint\n", cup,pint);
		printf("%.2f cup=%.2f oz\n",cup,oz);
		printf("%.2f cup=%.2f tbsp\n",cup,tbsp);
		printf("%.2f cup=%.2f tsp\n",cup,tsp);
		getchar();
		getchar();
		return 0;
	}
	
【总结】

数据与转换说明：
	关键字		声明/初始化		十进制	八进制		十六进制	
整型	int		int a=1;			%d;	%o;(%#o);		%x;%#x 或%#X;
	unsigned		unsigned a=1;		%u;

	short		short a=1;			%hd;	%ho;		%hx
	unsigned short	unsigned short a=1;		%hu
	long		long a=1L;		%ld;	%lo;		%lx
	unsigned long	unsigned long a=1uL;	%lu
	long long 		long long a=1LL;		%lld
	unsigned long long  unsigned long long a=1ull;	%llu

	关键字		声明/初始化		十进制	指数记数法	
浮点型	float		float a=3.14f		%f	%e	
	double		double=3.14		%f	%e
	long double	long double=3.14L		%f	%e

	关于本机C语言整型数字取值范围：
	8位(bit)	256个数	【char】占用1字节长度；1字节的整型 unsigned (0~255)  signed数字轴左移一半
	16位	256^2个	本机 【short】占用2字节长度；unsigned(0~65535)signed数字轴左移一半
	32位	256^4个	本机【int】【long】占用4字节长度；unsigned(0~4294967295)signed数字轴左移一半
	64位	256^8个	本机【long long】占用8字节长度；unsigned(0~18446744073709551615)signed数字轴左移一半

代码验证如下：
	#include<stdio.h>
	int main(void)
	{
		int a = 2147483647;
		unsigned b = 4294967295;
		short c = 32767;
		unsigned short d = 65535;
		long e = 2147483647;
		unsigned long f = 4294967295;
		long long g = 9223372036854775807;
		unsigned long long h = 18446744073709551615;
		char ch = 'T';
		float j = 3.14159265358979323846;
		double k = 3.14159265358979323846;
		long double l= 3.14159265358979323846;
		float flp = 3.1415926e38;
		float flm = 3.1415926e-45;
		double dp = 3.1415926e307;
		double dm = 3.1415926e-324;
		long double ldp= 3.1415926e307;
		long double ldm = 3.1415926e-324;
		printf("a = %d	a+1=%d		sizeof int = %zd \n", a, a + 1, sizeof(a));
		printf("b = %u	b+1=%u		sizeof unsigned = %zd \n", b, b + 1, sizeof(b));
		printf("c = %hd	c+1=%hd		sizeof short = %zd \n", c, c + 1, sizeof(c));
		printf("d = %hu	d+1=%hu		sizeof unsigned short = %zd \n", d, d + 1, sizeof(d));
		printf("e = %ld	e+1=%ld		sizeof long = %zd \n", e, e + 1, sizeof(e));
		printf("f = %lu	f+1=%lu		sizeof unsigned long = %zd \n", f, f + 1, sizeof(f));
		printf("g = %lld	g+1=%lld		sizeof long long = %zd \n", g, g + 1, sizeof(g));
		printf("h = %llu	h+1=%llu		sizeof unsigned long long = %zd \n", h, h + 1, sizeof(h));	
		printf("ch=%c	ASCII NO.=%d	sizeof char=%zd\n",ch,ch,sizeof(ch));
		printf("j=%.20f	j*10=%e		sizeof float=%zd\n", j, j*10, sizeof(j));
		printf("k=%.20f	k*10=%e		sizeof double=%zd\n", k, k * 10, sizeof(k));
		printf("l=%.20f	k*10=%e		sizeof long double=%zd\n", l, l * 10, sizeof(l));
		printf("flp=%e	flp*10=%e\n", flp,flp*10);
		printf("flm=%e	flm/10=%e\n", flm, flm / 10);
		printf("dp=%e	dp*10=%e\n", dp, dp * 10);
		printf("dm=%e	dm/10=%e\n", dm, dm / 10);
		printf("ldp=%e	ldp*10=%e\n", ldp, ldp * 10);
		printf("ldm=%e	ldm/10=%e\n", ldm, ldm / 10);
		getchar();
		return 0;
	}

【第四章】字符串和格式化输入/输出

4.1
	#include<stdio.h>
	#include<string.h>
	#define DENSITY 62.4//预处理：define 宏定义；
	int main(void)
	{
		float weight,volume;
		int size, letters;
		char name[40];//name是一个可容纳39字符的数组;
		printf("what's your first name?\n");
		gets(name);
		printf("what's your weight in pounds?\n");
		scanf_s("%f", &weight);
		size = sizeof name;
		letters = strlen(name);//strlen()函数获取字串长度；
		volume = weight / DENSITY;
		printf("%s,your volume is %.2f cubic feet.\n", name, volume);//%s 字符串转换说明；
		printf("also,your first name has %d letters.\n", letters);
		printf("we have %d bytes to store it.\n", size);
		getchar();
		getchar();
		return 0;
	}

	【字符串和字符】	
	字符串常量"X"和字符常量'X'不同
	区别1：'X'是基本类型char；“X”是派生类型(char 数组)
	区别2："X"实际上由两个字符组成'X'和空字符 \0	//空字符作为字符串的结束；

	#include<stdio.h>
	#include<string.h>
	#define PRAISE "You are an extraordinary being."
	int main(void)
	{
		char name[40];
		printf("what's your name?\n");
		gets(name);
		printf("hello,%s.%s\n", name, PRAISE);
		printf("your name of %zd letters occupies %zd memory cells.\n", strlen(name), sizeof name);
		printf("the phrase of parise has %zd letters,", strlen(PRAISE));
		printf("and occupies %zd memory cells.\n", sizeof PRAISE);
		getchar();
		getchar();
		return 0;
	}
	例输入'peter'；
	sizeof 运算符报告，name数组有40个存储单元，但是只有前5个单元用来存储peter，所以strlen()函数得出的结果是5；
	name数组的第6个单元存储空字符\0；strlen()并未将其计入；
	对于预定义的PRAISE 用strlen()得出字符串中的字符数为31(含空格、标点)，
	而sizeof运算符给出的数字为32，因为它把字符串末尾不可见的空字符也计算在内。
	该程序并未明确告诉计算机要给PRAISE字符串预留多少空间，所以它必须计算双引号内的字符数；
	
	关于sizeof后面是否带圆括号取决于运算对象是类型还是特定量；
	运算对象是类型时，圆括号必不可少，但对于特定量，可有可无。但是建议都加圆括号；
	
4.3	【常量和C预处理器 #define】
	circumference=3.14159*diameter；	//常量3.14159代表圆周率pi(π)
	circumference=pi*diameter；		//使用符号常量能更方便、表达更多信息；
	假设程序中多出使用一个常量，有时需要变更它的值，比如经常浮动的税率。
	如果程序使用符号常量，则只需更改符号常量定义，而不用在程序中查找使用常量的地方逐一修改；
	如何创建符号常量？

	方法1：声明一个变量，然后将该变量设置为所需的常量；如
	float taxrate；
	taxrate=0.015；
	这样做就给0.015这个常量提供了一个符号名，但是taxrate是一个变量，程序可能会无意间改变它的值；
	所以C语言提供了一个更好的方案――C预处理器。
	方法2：用预处理器来定义一个常量；如
	#define TAXRATE 0.015	//格式 #define NAME value
	编译程序时，程序中所有TAXRATE都会被替换成0.015；这过程被称为“编译时替换”，这样定义的常量也称明示常量；
	符号常量名一般建议用大写名；程序中看到大写名可以立刻明白这是个符号常量，而非变量；提高可读性；
	
	#include<stdio.h>
	#define PI 3.14159
	int main(void)
	{
		float area, circum, radius;
		printf("what's the radius of your pizza?\n");
		scanf_s("%f", &radius);
		area = PI * radius*radius;
		circum = 2.0*PI*radius;
		printf("your basic pizza parameters are as follow:\n");
		printf("circumference=%.2f,area=%.2f\n", circum, area);
		getchar();
		getchar();
		return 0;
	}

	#define指令还可以定义字符和字符串常量，前者使用单引号，后者使用双引号；如
	#define BEEP '\a'
	#define TEE 'T'
	#define ESC '\033'
	#define OOPS "Now you have done it!"
	
	const限定符，用于限定一个关键量为只读。声明如下
	const int MONTHS=12；	//MONTHS在程序中不可更改，值为12

	C头文件limits.h 和 float.h 分别提供了整数类型和浮点类型大小限制相关的详细信息；
	每个头文件都定义了一系列供实现使用的符号常量；例如limits.h头文件包含以下类似代码：
	#define INT_MAX +32767
	#define INT_MIX -32768
	这些明示常量代表int类型可以表示的最大值和最小值。如果系统使用32位的int，该头文件会为这些明示常量提供不同的值。
	如果在程序中包含limits.h头文件，就可以编写下面代码：
	#include<stdio.h>
	#include<limits.h>
	int main(void)
	{
		printf("Maxmum int value on this system=%d\n", INT_MAX);
		getchar();
		return 0;
	}
	类似的float.h也定义了一些明示常量；演示如下：

	#include<stdio.h>
	#include<limits.h>//整型限制
	#include<float.h>//浮点型限制
	int main(void)
	{
		printf("some number limits for this system:\n");
		printf("Biggist int =%d\n", INT_MAX);
		printf("Smallest long long =%lld\n",LLONG_MIN);
		printf("One byte=%d bits\n",CHAR_BIT);
		printf("Largest double=%e\n",DBL_MAX);
		printf("Smallest normal float=%e\n",FLT_MIN);
		printf("float precision =%d digits\n",FLT_DIG);
		printf("float epsilon=%e\n",FLT_EPSILON);
		getchar();
		return 0;
	}


4.4.2	【printf()】

	#include<stdio.h>
	#define PI 3.141593
	int main(void)
	{
		int num = 7;
		float pies = 12.75;
		int cost = 7800;
		printf("the %d contestants are %.2f berry pies.\n",num,pies);
		printf("the value of PI is %f.\n",PI);
		printf("farewell! thou art too dear for my possessing,\n");
		printf("%c%d.\n",'$',2*cost);	//printf()函数使用的是值，无论是变量、常量还是表达式的值			
		getchar();
		return 0;
	}

	printf()函数格式
	printf(“格式字符串”，待打印项1，待打印项2……)；
	格式字符串包含两种形式：1.需要实际打印的字符；2.转换说明，数量跟待打印项相对应
	
4.4.3	printf()的转换说明修饰符

	①标记
		(-、+、空格、#和0)，可以不使用标记或者使用多个标记；示例：“%-10d”左对齐10个格位；
		-：待打印项目左对齐
		+：显示值的正负符号；值为正，在值前面显示+；若为负显示-；
		空格：若值为正，占用一空格，若值为负，显示-号；
		#：把结果转换成另一种格式；%o格式则以0开始；%x则以0x开始；
		     对于所有的浮点格式，#保证即使后面没有任何数字，也打印一个小数点字符；
		     对%g格式，#防止结果后面的0被删除；

	②数字 
		显示字段宽度，如果该字段不能容纳待打印的数字或者字符串，系统会使用更宽的字段；示例："%4d"

	③.数字
		标明精度；
		对于%e、%E和%f转换，表示小数点右边数字的位数；示例“%.2f”保留小数点后两位；
		对于%g、%G转换，表示有效数字最大位数；
		对于%s转换，表示待打印字符的最大数量；
		对于整型转换，表示待打印数字的最小位数；
		如有必要，使用前导0来达到这个位数
		只使用.表示其后跟随一个0，所以%.f和%.0f相同
	④字符：
		h：和整型转换说明一起使用，表示short int或unsigned short int类型的值；
		hh：signed char或unsigned char；
		j：intmax_t或uintmax_t；
		l：long int或 unsigned long int；
		ll：long long  或unsigned long long；
		L：long double；
		t：ptrdiff_t；
		z：size_t；

	类型可移植性：sizeof运算符以字节为单位返回类型或值的大小；系统只规定了该值为unsigned整数；
		      如果移植要查找返回值类型选择用u-int、u-long甚至u-long long
	float参数的转换：有double和long double类型的转换，printf()函数中float类型函数自动转换成double类型；	

	#include<stdio.h>
	#define PAGES 959
	int main(void)
	{
		printf("*%d*\n",PAGES);	//*959*	//不带任何修饰符，默认输出结果；
		printf("*%2d*\n", PAGES);	//*959*	//修饰符要求2字段宽度，但待打印整数有3位数字，字段扩大字段宽度；
		printf("*%10d*\n", PAGES);	//*       959*//输出10个字段宽度，7空格+3数字；
		printf("*%-10d*\n", PAGES);	//*959       *//输出10个字段宽度，7空格+3数字；-修饰符，数字左靠齐；
		getchar();
		return 0;
	}

	#include<stdio.h>
	int main(void)
	{
		const double RENT = 3852.99;	//const限定变量只读；
		printf("*%f*\n", RENT);	//*3852.990000*	//字段宽度和小数点后面的位数均为默认
		printf("*%e*\n", RENT);	//*3.852990e+03*	//指数写法；小数点左侧1位，右侧6位；
		printf("*%4.2f*\n", RENT);	//*3852.99*	//4字段宽度被扩大，小数点后两位；
		printf("*%3.1f*\n", RENT);	//*3853.0*		//3字段宽度也失效，小数点后保留1位，四舍五入；
		printf("*%10.3f*\n", RENT);	//*  3852.990*	//10字段宽度指定生效，小数点后三位；
		printf("*%10.3E*\n", RENT);	//* 3.853E+03*	//10字段宽度生效；小数点后保留三位，指数写法；
		printf("*%+4.2f*\n", RENT);	//*+3852.99*	//显示正负号；指定字段宽度失效；保留2位小数；
		printf("*%010.2f*\n", RENT);	//*0003852.99*	//指定10字段宽度，空位用0填充，小数点后保留2位；
		getchar();
		return 0;
	}
	
	#include<stdio.h>
	int main(void)
	{
		printf("%x %X %#x\n",31,31,31);		//1f 1F 0x1f
		printf("**%d**% d**% d**\n",42,42,-42);		//**42** 42**-42**
		printf("**%5d**%5.3d**%05d**%05.3d**\n",6,6,6,6);	//**    6**  006**00006**  006**
		getchar();
		return 0;
	}

	字符串输出：
	
	#include<stdio.h>
	#define BLURB "Authentic imitation!"
	int main(void)
	{
		printf("[%2s]\n", BLURB);	//指定2字段宽度，但是被扩大为可容纳所有字符字段；
		printf("[%24s]\n", BLURB);	//输出24字段宽度字符串，多余部分会显示出左边空位；
		printf("[%24.5s]\n", BLURB);	//.5精度限制输出待打印字符的个数，只输出5个字符；
		printf("[%-24.5s]\n", BLURB);	//-标记使得文本左对齐输出；
		getchar();
		return 0;
	}


4.4.4	【转换说明】
	转换说明把以二进制格式存储在计算机中的值转换成一系列字符(字符串)以便于显示；
	转换不是原始值被替换成转换后的值，而是一种翻译说明；%d的意思是把给定的值翻译成十进制整数输出；

	1.转换不匹配问题：

	①整型转换不匹配示例：
	
	#include<stdio.h>
	#define PAGES 336
	#define WORDS 65618
	int main(void)
	{
		short num=PAGES;
		short mnum=-PAGES;
		printf("num as short and unsigned short:%hd %hu\n",num,num);		//336 336
		printf("-num as short and unsigned short:%hd %hu\n",mnum,mnum);		//-336 65200
		printf("num as int and char:%d %c\n",num,num);				//336 P
		printf("WORDS as int,short,and char:%d %hd %c",WORDS,WORDS,WORDS);	//65618 82 R
		getchar();
		return 0;
	}

	第三行演示了把一个大于255的值转换成字符会发生的情况，short int是2字节；char是1字节；
	当printf()用%c打印336时候，它只查看336数字2字节中的后1字节；这种被称为截断：
	P在ASCII表中为80；   80在二进制中为 01010000；
		而336的二进制为 00000001 01010000；
	该数字被解释成“以256为摸”(modulo256),即该数字除以256后取其余数。

	②整型与浮点型混淆示例：
	
	#include<stdio.h>
	int main(void)
	{
		float n1=3.0;
		double n2=3.0;
		long n3=2000000000;
		long n4=1234567890;
		printf("%.1le %.1le %.1le %.1le\n",n1,n2,n3,n4);	//3.0e+00 3.0e+00 3.1e+46 7.1e-305
		printf("%ld %ld\n",n3,n4);			//2000000000 1234567890
		printf("%ld %ld %ld %ld\n",n1,n2,n3,n4);		//0 1074266112 0 1074266112
		getchar();
		return 0;
	}

	最后一行输出n3,n4也出错了；结果显示如果printf()语句有其他不匹配的地方，即使用对了转换说明也会出错
	问题出在C如何把信息传递给函数，即参数传递机制；

	函数调用 printf("%ld %ld %ld %ld\n",n1,n2,n3,n4);
	该调用告诉计算机把n1,n2,n3,n4的值传递给程序；这是一种常见的参数传递方式：
	程序把传入的值放入被称为“栈”(stack)的内存区域；

	计算机根据变量类型(而不是根据转换说明) 把这些值放入栈中；
		因此，n1被存储在栈中，占8字节(float类型被转换成double类型)；n2也占8字节；
		而n3和n4在栈中分别占4字节；

	然后控制转到printf()函数，
	该函数根据转换说明(而不是根据变量类型)从栈中读取值：
		%ld表明printf()应该读取4字节，所以只读取了n1的前半部分；并被解释成一个long类型整数；
		根据下一个%ld，printf()再读取4字节，读取了n1的后半部分；被解释成第二个long类型整数；
		类似的根据第三个和第四个%ld，分别读取了n2的前、后两部分，并被解释成n3，n4;

	2.printf()的返回值
	
	#include<stdio.h>
	int main(void)
	{
	int rep;
	rep=printf("hello world\n");		//输出printf()，并将这个printf()的返回值赋给rep
	printf("rep have %d characters",rep);	//输出rep返回值，hello+空格+world+\n=5+1+5+1=12字符数；
	getchar();
	return 0;
	}

	
4.4.5	【scanf()】
	printf()函数使用变量、常量和表达式；scanf()函数使用指向变量的指针；
	1.如果用scanf()读取基本变量类型的值，在变量名前加上一个&；
	2.如果用scanf()把字符串读入字符数组中，不要使用&；

	#include<stdio.h>
	#pragma warning(disable:4996)；
	int main(void)
	{
		int age;
		float assets;
		char pet[30];
		printf("Enter your age,assets,and favorite pet.\n");
		scanf("%d %f", &age, &assets);
		scanf("%s", pet);
		printf("your age : %d,\nand your assets: $%.2f,\nand your favorite pet:%s.\n", age, assets, pet);
		getchar();
		getchar();
		return 0;
	}

	【scanf_s解决办法】
	#include<stdio.h>
	int main(void)
	{
		int age;
		float assets;
		char pet[30];
		printf("Enter your age,assets,and favorite pet.\n");
		scanf_s("%d %f", &age, &assets);
		scanf_s("%s", pet,30);				/*scanf_s(,,)第三个参数的数字是限制读取边界*/
		printf("your age : %d,\nand your assets: $%.2f,\nand your favorite pet:%s.\n", age, assets, pet);
		getchar();
		getchar();
		return 0;
	}



	
	示例里面的输入三个参数，可以用回车键、tab键或者空格键来隔开；所以可以将输入在一行或者多行进行；
	其中%c是例外，scanf()会读取每个字符，包括空白。

	scanf()转换说明
	
	%c		把输入解释成字符；
	%d		把输入解释成有符号十进制整数；
	%e、%f、%g、%a	把输入解释成浮点数； 
	%E、%F、%G、%A	把输入解释成浮点数；
	%i		把输入解释成有符号十进制整数；
	%o		把输入解释成有符号八进制整数；
	%p		把输入解释成指针(地址)；
	%s		把输入解释成字符串，到下一个空白字符之前；
	%u		把输入解释成无符号十进制整数；
	%x、%X		把输入解释成有符号十六进制整数；

	scanf()如何读取输入：	
	①假设scanf()根据一个%d转化说明读取一个整数：
	scanf()函数每次读取一个字符，跳过所有空白字符，直到遇到第一个非空白字符开始读取；
	因为要读取整数，所以scanf()开始寻找一个数字字符或者一个符号(+或-)，
	如果找到一个数字或符号，便保存该字符，并读取下一个字符，如果下一个字符是数字，保存并读取下一个字符；
	scanf()不断地读取和保存字符，直到遇到非数字字符，便认为读到了整数的末尾；
	scanf()将非数字字符放回输入，这意味着下一次读取输入时，首先读到的就是这个被放回的非数字字符；
	最后scanf()计算已经读取的字符(可能还有符号)对应的数值，并将计算后的值放入指定变量中。
	
	上例中，如果第一个非空白字符是A而不是数字，scanf()将停在那里，并把A放回输入中，而不会把值赋给变量；
	如果使用字段宽度，scanf()会在字段结尾或者第一个空白字符处停止读取(满足其中之一就停止读取)

	②其他数值匹配的转换说明跟%d情况大致相同，区别在于scanf()会把更多字符识别成数字的一部分，比如十六进制A~F；
	③浮点转换说明还要求scanf()识别小数点、e记数法和新增的p计数法；
	④使用%s转换说明时，scanf()会读取除空白外所有字符；scanf()跳过空白开始读取第一个非空白字符并保存，直到下一个空白；
	⑤除了%c，其他转换说明都会自动跳过待输入值前所有空白；

	scanf()返回值
	scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0；
	当scanf()检测到"文件结尾"时，会返回EOF(EOF是stdio.h中定义的特殊值，通常#define指令把EOF定义为-1)

4.4.6	printf()和scanf()的*修饰符
	
	printf()的*修饰符：如果转换说明是%*d。那么参数列表中应包含*和d对应的值；同时也可用于浮点值指定精度和字段宽度；
	范例：
	#include<stdio.h>
	int main(void) 
	{
		unsigned width, precision;	//width:字段宽度;precision:精度;
		int number = 256;		//演示1输出项；
		double weight = 242.5;	//演示2输出项；

		printf("Enter a field width:\n");			//指定字段宽度；
		scanf_s("%d", &width);			//给字段宽度赋值；
		printf("The number is :%*d:\n",width,number);	//输出1 number；*按照指定输出字段宽度；

		printf("Now enter a width and a precision:\n");	//指定字段宽度和显示精度；
		scanf_s("%d %d",&width,&precision);		//读取宽度和精度设定；
		printf("Weight=%*.*f\n",width,precision,weight);	//输出2 weight；*.*前者字段宽度后者小数点后显示精度
		printf("Done!\n");

		getchar();
		getchar();
		return 0;
	}


	scanf()的*修饰符：把*放在%和转换字符之间，会让scanf()跳过对应的输出项；在程序需要读取文件中特定列的内容时可用上；
	范例：

	#include<stdio.h>
	int main(void)
	{
		int a,b,c;

		printf("Please enter three integers:\n");
		scanf_s("%*d %*d %d", &a,&b,&c);
		printf("The last integer was %d\n",a);

		getchar();
		getchar();
		return 0;
	}

4.4.7	printf()的用法提示
	①使用足够大的固定字段宽度让输出整齐美观；
	比如要输出三次：printf("%d %d %d\n",a,b,c,);，若用户输入不同变量，则输出可能是
	22 234 3222
	345 8 66	
	6789 224 37
	
	修改后：printf("%4d %4d %4d\n",a,b,c,);
	    22       234   3222
	  345           8      66	
	6789        224      37

	②如果要在文字中嵌入一个数字，通常指定一个小于或等于该数字宽度的字段会比较方便；
	如嵌入一个10.22
	printf("Count Jack ran %.2f miles in 3 hours.\n",distance);
	Count Jack ran 10.22 miles in 3 hours.
	若转换说明为printf("Count Jack ran %8.2f miles in 3 hours.\n",distance);
	Count Jack ran         10.22 miles in 3 hours.

4.7 	练习
	1.编写一个程序，提示用户输入名和姓，然后以“名，姓”的格式打印出来
	#include<stdio.h>
	int main(void)
	{
		char name1[40], name2[40];
		printf("Please enter your first name.\n");
		scanf_s("%s", name1, 40);
		printf("please enter your family name.\n");
		scanf_s("%s", name2, 40);
		printf("so your neme is %s,%s.", name1, name2);
		getchar();
		getchar();
		return 0;
	}
	
	2.编写一个程序，提示用户输入名和姓，并执行以下操作：
	a,打印名和姓，包括双引号；
	b.在宽度为20的字段右端打印名和姓，包括双引号；c.换字段左端；
	d.在比姓名宽度宽3的字段中打印名和姓。

	#include<stdio.h>
	int main(void)
	{
		char name1[40], name2[40];
		int a, b,c;

		printf("Please enter your first name.\n");
		scanf_s("%s", name1, 40);
		printf("please enter your family name.\n");
		scanf_s("%s", name2, 40);
		a = strlen(name2);
		a = 20 - a - 1;
		b = strlen(name1);
		b = -(20 - b - 1);
		c = strlen(name1)+ 3;

		printf("so your neme is \"%s.%s\"\n", name1, name2);
		printf("so your neme is \"%*s.%s\"\n", a, name1, name2);
		printf("so your neme is \"%s.%*s\"\n", name1, b, name2);
		printf("so your neme is \"%*s.%s\"\n", c,name1,name2);
		getchar();
		getchar();
		return 0;
	}

	3.编写一个程序，读取一个浮点数，首先以小数点记数法打印，然后以指数记数法打印。
	用下面的格式进行输出：
	a. 输入21.3或者2.1e+001；
	b.输入21.290或2.129E+001;
	#include<stdio.h>
	int main(void) 
	{
		float a;
		scanf_s("%f", &a);
		printf("%f\n", a);
		printf("%e", a);
		getchar();
		getchar();
		return 0;
	}

	4.编写一个程序，提示用户输入身高和姓名，然后以下面的格式显示用户输入信息：

	Dabney, you are 6.208 feet tall
	使用float类型，并用/作为除号，要求用户以mm为单位输入身高以米输出

	#include<stdio.h>
	#include<Windows.h>
	int main(void) 
	{
		float height;
		float feettall;	
		char firstname[40];
		char familyname[40];	

		printf("Pleast enter your height in feet\n");
		scanf_s("%f", &feettall);
		printf("Pleast enter your height in mm\n");
		scanf_s("%f", &height);
	
		printf("Pleast enter your first name\n");
		scanf_s("%s", firstname,40);
		printf("Pleast enter your family name\n");
		scanf_s("%s", familyname,40);	
	
		system("cls");
		printf("%s.%s, you are %.3f feet tall\n",firstname,familyname,feettall);
		printf("you are %.3f meters tall.", height/1000);

		getchar();
		getchar();
		return 0;
	}

	5.编写一个程序，提示用户输入以兆位每秒(Mb/s)为单位的下载速度和以兆字节(MB)为单位的文件大小；
	程序中应计算文件的下载时间，1字节等于8位，使用float，并用/作除号；
	要以下面格式打印三个变量的值，显示小数点后面两位数字：
	At 18.12 megabits per second,a file of 2.20 megabytes downloads in 0.97 seconds.

	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		float speed, file;

		printf("Please enter your download speed by Mb/s\n");
		scanf_s("%f", &speed);
		printf("Please enter your download file megabntes\n");
		scanf_s("%f", &file);
	
		system("cls");
		printf("At %.2f megabits per second,a file of %.2f megabytes downloads in %.2f seconds.", speed, file,file*8/speed);
		getchar();
		getchar();
		return 0;
	}
	
	6.编写一个程序，先提示用户输入名，然后输入姓。在一行打印输入的名和姓，再下一行分别打印名和姓的字母数；
	字母数要和相对应的名和姓结尾对齐，如下所示：
	Melissa Honeybee
	         7               8
	换字母开头对齐：
	Melissa Honeybee
	7           8
	
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		char firstname[40],familyname[40];
		int a, b;

		printf("Please enter your first name.\n");
		scanf_s("%s", firstname, 40);
		a = strlen(firstname);
		printf("Please enter your family name.\n");
		scanf_s("%s", familyname, 40);
		b = strlen(familyname);
	
		system("cls");
		printf("%s %s\n%*d %*d\n", firstname, familyname,a,a,b,b);
		printf("%s %s\n%-*d %-*d\n", firstname, familyname, a, a, b, b);
		getchar();
		getchar();
		return 0;
	}

	//关于输入姓名超出给定范围或者格式，如何删除冗余输入不影响后续的暂行办法，如下如果name[4]就没法解决超出3字节问题；
	#include<stdio.h>
	#pragma   warning(disable:4996)
	int main(void)
	{
		char name[40];
		int age,a,i;
		printf("please enter your name.\n");
		scanf_s("%s", name, 40);

		//for (a = 0; a < 4; a++) { name[a] = getchar(); }
		//fflush(stdin);
		setbuf(stdin, NULL);
		//while ((name[4] = getchar()) != EOF && name[4] != '\n');
		i = strlen(name);
		printf("your name have %d byte\n\n", i);

		printf("please enter your age.\n");
		scanf_s("%d", &age);

		printf("\nwell,%s,you are %d years old.\n", name, age);

		getchar();
		getchar();
		return 0;
	}

	7.编写一个程序，将一个double类型的变量设置为1.0/3.0，将一个float类型的变量设置为1.0/3.0；
	分别显示两次计算的结果各3次：
	一次显示小数点后面6位数字；一次显示小数点后12位数字；一次显示小数点后16位数字；
	程序中要包含float头文件，并显示FLT_DIG和DBL_DIG的值；
	1.0/3.0的值与这些值一致吗？
	
	#include<stdio.h>
	#include<float.h>
	int main(void) 
	{
		double a;
		float b;
		a = 1.0 / 3.0;
		b = 1.0 / 3.0;
		printf("%.6f\n%.12f\n%.16f\n", a, a, a);
		printf("%.6f\n%.12f\n%.16f\n", b, b, b);
		printf("%d\n%d", FLT_DIG, DBL_DIG);
		getchar();
		return 0;
	}


	8.编写一个程序，提示用户输入旅行的里程和消耗的汽油量，然后计算并显示消耗每加仑汽油行驶的英里数，保留一位小数；
	1加仑约3.785升；1英里约1.609千米；将单位是英里/加仑的值转换为升/100公里并显示结果，保留一位小数点；
	注：美国采用的方案测量消耗单位燃料的里程值，而欧洲采用单位距离消耗的燃料测量方案；
	使用#define创建符号常量或使用const限定符创建变量来表示两个转换系数；
	
	#include<stdio.h>
	#define c 100*3.785/1.609
	int main(void)
	{
		float a, b;
	
		printf("Please enter your mileage:\n");
		scanf_s("%f", &a);
		printf("Please enter your fuel consumed in gallon:\n");
		scanf_s("%f", &b);
	
		printf("your comprehensive oil consumption is:\n");
		printf("MPG:%.1f \n", a/b);
		printf("%.1f L/100KM", c*b/a );
		getchar(); 
		getchar();
		return 0;
	}


【第五章】运算符、表达式和语句

	
5.1 	循环

	数据对象：用于储存值的数据存储区域；
	左值：用于标明特定数据对象的名称或表达式；对象定位值；
	右值：能赋值给可修改左值的量，且本身不是左值；
	运算符：基本运算符=+-*/
	
5.2.1 	赋值运算符=
	
	#include<stdio.h>
	int main(void)
	 {
		int jane, tarzan, cheeta;
		cheeta = tarzan = jane = 68; //三重赋值；
		printf("cheeta    tarzan    jane\n");
		printf("%4d %8d %8d\n", cheeta, tarzan, jane);
		getchar();
		return 0;
	}	

	赋值顺序从右往左，首先把86赋值给jane,然后再赋值给tarzan；最后赋值给cheeta；

5.2.2	加法运算符+
	printf("%d",4+20);打印的是24而不是表达式4+20；
	相加的对象可以是变量也可以是常量；
	
5.2.3	减法运算符-
	takehome=224-24;
	+和-运算都被成为二元运算符，即这些运算符需要两个运算对象才能完成操作；

5.2.4	符号运算符-和+
	减号还可以用于标明或改变一个值的代数符号如
	rocky=-12；
	smokey=-rocky；
	smokey最后的值为12；
	
	二元：36-12 值为24
	一元：-16	   值为-16
	二者兼有：-（12-20） 值为8

5.2.5	乘法运算符*
	例：C没有平方函数，如果需要打印一个平方表，则：
	/*squares.c――计算1-20的平方*/
	#include<stdio.h>
	int main(void)
	{
		int num;
		num = 1;
		while (num < 21) 
		{
			printf("%d*%d=%d\n", num, num, num*num);
			num = num + 1;
		}
		getchar();
		return 0;
	}
	
	1.指数增长：
	棋盘上的米粒：第一格放1粒，第二格放2粒，第三格放4粒，第四格放8粒；
	以此类推，放满64个格子数；
	/*指数增长，让程序计算出每个格子放多少，并计算总数*/
	#include<stdio.h>
	int main(void)
	{
		int a;
		double b,c;
		a = 1;	//格子数
		b = 1.0;	//格子上米粒数
		c = 1.0;	//总米粒数
		printf("格子数	米粒数		总数\n");
		while(a<65)
		{				
			printf("%d:	%.2e	%.2e\n",a, b,c);	
			b = 2 * b;		
			a = a + 1;		
			c = c + b;		
		}
		getchar();
		return 0;
	}

	改进：制作一个指数函数查看表1；
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		int count,num;
		double result;
		count = 1;	
		result = 1.0;
		printf("please enter the number as the powerof 2\n");
		scanf_s("%d", &num);
		while (count < num+1)
		{
			count = count + 1;		
			result = 2 * result;
		}
		system("cls");
		printf("the %d power of 2 is %.2e\n", num, result);	
		getchar();
		getchar();
		return 0;
	}
	
	改进：制作一个指数函数查看表2；
	#include<stdio.h>
	int main(void)
	{
		int count,n,num;
		double result;
		count = 1;	
		n = 0;
		result = 1.0;
		printf("please enter the number as the powerof 2\n");
		scanf_s("%d", &num);

		printf("n.	result\n");
		while (count < num+2)
		{		
			printf("%d	%.2e\n", n, result);
			count = count + 1;		
			result = 2 * result;
			n = count - 1;		
		}	
		getchar();
		getchar();
		return 0;
	}
	
5.2.6	除法运算符/
	整数除法和浮点数除法不同，浮点数除法的结果是浮点数，而整数除法的结果是整数，没有小数部分；
	所以整数除法使得5/3这样的情况，实际结果有小数部分，但是被丢弃，这过程称为截断；
	#include<stdio.h>
	int main(void)
	{
		printf("int division: 5/4 is %d\n", 5 / 4);		//1
		printf("int division: 8/4 is %d\n", 8 / 4);		//2
		printf("int division: 7/4 is %d\n", 7 / 4);		//1，截断为丢弃整个小数部分，不会四舍五入；
		printf("float division: 7.0/4.0 is %.2f\n", 7.0 / 4.0);	//1.75
		printf("mixed division: 7.0/4 is %.2f\n", 7.0 / 4);	//1.75，尽量避免此类；4会被先转化成4.0
		getchar();
		return 0;
	}

5.2.7	运算符优先级：

	（）	从左往右
	+ -(一元)	从右往左(正负)
	* /	从左往右
	+ -(二元)	从左往右(加减)
	=	从右往左

5.3	其他运算符：
	
5.3.1	sizeof运算符和size_t类型
	#include<stdio.h>
	int main(void)
	{
		int n = 0;
		size_t intsize;	
		intsize = sizeof(int);	
		printf("n=%d,n has %u bytes;all ints have %u bytes.\n", n, sizeof n, intsize);
		getchar();
		return 0;
	}

5.3.2	求模运算符%
	用于整数运算，给出左侧整数除以右侧整数后的余数；
	13%5的结果为3；

	#include<stdio.h>
	#define SEC_PER_MIN 60
	int main(void)
	{
		int sec, min, left;

		printf("Convert seconds to minutes and secods!\n");
		printf("Enter the number of seconds(<=0 to quit):\n");
		scanf_s("%d", &sec);
		while(sec>0)
		{
			min = sec / SEC_PER_MIN;//截断分钟数；
			left = sec % SEC_PER_MIN;//剩下的秒数；
			printf("%d seconds is %d minutes, %d seconds.\n", sec, min, left);
			printf("Enter next value(<=0 to quit):\n");
			scanf_s("%d", &sec);
		}
		printf("Done!\n");
		getchar();
		getchar();
		return 0;
	}
	
	关于负数求模；
	11/5 得2	11%5得1
	11/-5得-2	11%-2得1
	-11/-5得2	-11%-5得-1
	-11/5得-2	-11%-2得-1
	综上：
	如果第一个运算对象是负数，那么结果就为负数；
	如果第一个运算对象为正数，那么求模结果也是正数；	

	实际上，只要a和b是整数，便可通过 a-(a/b)*b来计算；

	例如：-11%5：
	  -11-（-11/5）*5
	=-11-（-2）*5
	=-11-（-10）
	=-1


5.3.3	递增运算符++
	执行简单的任务，将其运算对象递增1；分为：
	1.前缀模式		 a++
	2.后缀模式		 ++a
	
	【前后缀相似之处】

	#include<stdio.h>
	int main(void) 
	{
		int ultra = 0, super = 0;
		while (super < 5)
		{
			super++;
			++ultra;
			printf("super=%d, ultra=%d\n", super, ultra);
		}
		getchar();
		return 0;
	}

	程序输出：
	super=1, ultra=1
	super=2, ultra=2
	super=3, ultra=3
	super=4, ultra=4
	super=5, ultra=5

	#include<stdio.h>
	int main(void) 
	{
		int ultra = 0, super = 0;
		while (super++ < 5)//super=0<5,super+1=0+1=1;执行循环,
		{
			++ultra;//ultra=1；使用ultra之前先递增ultra;
			printf("super=%d,ultra=%d\n", super, ultra);
		}	
		getchar();
		return 0;
	}

	【前后缀区别】
	#include<stdio.h>
	int main(void) 
	{
		int a=1,b=1;
		int a_post, pre_b;
		a_post = a++;	//后缀，使用a值之后，递增a
		pre_b = ++b;	//前缀，使用b值之前，递增b
		printf("a	a_post	b	pre_b\n");
		printf("%d	%5d	%5d	%5d\n", a, a_post, b, pre_b);	
		getchar();
		return 0;
	}

	结果为a=2,a_post=1,b=2,pre_b=2


	前缀形式：
	q=2*++a;		首先，a递增1；然后2乘以a并将结果给q；
	后缀形式；
	q=2*a++;		首先，2乘以a并将结果给q；然后，a递增1；

5.3.4	递减运算符--（与++同；略）
	
5.3.5	优先级
	递增递减运算符都有很高的优先级，只有圆括号优先级高于它们；
	因此，x*y++表示是(x)*(y++),而不是(x*y)(++),而且后者无效，递增和递减运算符只能影响一个变量；
	如果n++是表达式的一部分，可以视其为 先使用n，再递增；
	而++n则表示 先递增n，在使用；

5.3.6	如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增递减；
	如果一个变量多次出现在一个表达式中，不要对该变量使用递增递减

5.4	表达式和语句

5.4.1	表达式
	表达式由运算符和运算对象组成，最简单的表达式是一个单独的运算对象，一些表达式由子表达式组成；
	每个表达式都有一个值；

5.4.2	语句	
	一条语句相当于一条完整的计算机指令，大部分语句都以分号结尾；因此：
	legs=4 	只是一个表达式
	legs=4;	则是一条语句
	最简单的语句是空语句
	；//空语句
	C把末尾加上一个分号的表达式都看作是一条语句，即表达式语句
	8；
	3+4；
	但是这些语句在程序中什么也不做，不算是正真有用的语句
	确切的说，语句可以改变值或者调用函数：
	x=25;
	++x;
	y=sqrt(x);
	虽然一条语句相当于一条完整的指令，但并不是所有的指令都是语句，比如：
	x=6+(y=5);
	其中y=5是一条完整的指令，但是它只是语句的一部分，用分号识别这种情况下的语句；

	#include<stdio.h>
	int main(void) 
	{
		int count, sum;		//声明；
		count = 0;			//表达式语句
		sum = 0;			//表达式语句
		while (count++ < 20)
			{sum= sum + count;	}	//迭代语句	
		printf("sum=%d\n", sum);		//表达式语句
		return 0;			//跳转语句
	}
	
	声明创建了名称和类型，并分配内存位置，但声明不是表达式语句，如删分号，剩下也不是表达式，没有值；
	赋值表达式语句：一个变量名，后面是一个赋值运算符，再跟一个表达式，最后分号结尾；
	函数表达式语句会引起函数调用；在上例中，调用printf()函数打印结果。
	while()语句有3部分组成，首先是关键字while，圆括号内为待测试条件；如果条件为真，则执行while循环里的语句；
	while语句是一种迭代语句，也称为结构化语句；

	【副作用和序列点】

	副作用：是对数据对象或文件的修改；例如
	a=50;
	它的副作用是将变量的值设置为50；
	类似的，调用printf()函数时，它显示的信息其实是副作用(printf()的返回值是待显示字符的个数)；

	序列点：是程序的执行点，在该点上，所有的副作用都在进入下一步之前发生；
	在C中，语句中的分号标记了一个序列点，
	意思是在该语句中，赋值、递增、递减对运算对象的改变必须在程序执行下一条语句前完成；
	任何一个完整表达式的结束也是一个序列点。
	完整表达式：就是指这个表达式不是另一个更大表达式的子表达式；例如：
	表达式语句中的表达式；while循环中的测试条件表达式；

	序列点有助于分析后缀递增何时发生，例如：
	
	while(a++<10) 
		printf("a=%d\n",a);

	举例，a=5；
	该例子中，如果按照“先使用值，再递增”的后缀意思，会先printf()输出guests的值,再递增它；
	显示数字 a=5;然后a递增变成6；
	但是，表达式guests++<10是一个完整的表达式；是while循环的测试条件；所以该表达式的结束就是一个序列点；
	所以保证在执行printf()之前，发生副作用；a递增a=6;printf()输出%d调用a的值为6；
	同时，使用后缀递增保证了a在完成与10的比较后才进行递增，即a=5<10成立，输出6这个动作得以执行；

5.4.3	复合语句(块)
	
	复合语句是用花括号括起来的一条或多条语句，也成为块block；
	
	/*程序段1*/

	a=0;
	while(a++<10)
		 {b=10*a+2;}
	printf("b=%d",b);
	
	/*程序段2*/

	a=0;
	while(a++<10)
	 {
		b=10*a+2; 
		printf("b=%d",b);
	}

	程序段1，while循环只有一条赋值表达语句，while这行运行至下一个分号；循环结束后printf()只会被调用一次；
	程序段2，花括号确保两条语句都是while循环的一部分，每执行一次循环都调用一次printf()函数；

	风格提示：循环中的缩进，对编译器不起作用，编译器通过花括号和while循环的结构来识别和解释指令；
	这里的缩进是为了让使用者可以一眼看出程序是如何组织的；使用缩进和花括号的位置可以进一步提高可读性；

5.5	类型转换
	通常，在语句和表达式中应使用类型相同的变量和常量；
	但是如果使用混合类型，C虽然会采用一套规则自动转化类型，但是有一定的危险性；
	1.当类型转换出线在表达式时，无论是unsigned还是signed的char和short都会被自动转为int；
	  如有必要会被转换成unsigned int（若short与int大小相同，unsigned short就比int大）；
	  这种情况下，unsigned short会被转成unsigned int；
	由于都是从较小型转换为较大类型，所以这些转换被称为升级promotion；
	
	2.涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别；
	3.类型的级别从高至低：long double>double>float>unsignedlong long>long long>unsigned long>
			long>unsigned int>int>
	  例外：当long和int大小相同时，unsigned int 比long 的级别高，short和char均被升级到int或者unsigned int；
	4.在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型；这结果可能导致升级或降级；
	5.当作为函数参数传递时，char和short被转换成int，float被转换成double，函数原型会覆盖自动升级；
	类型升级通常都不会有什么问题，但是类型降级会导致正真的麻烦，可能会溢出；
	
	待转换的值与目标类型不匹配，涉及类型转换时：
	①目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略；
		例如目标类型是8位unsigned char，待赋的值是原始值求模256；
	②如果目标类型是一个符号整型，且待赋的值是整数，结果因实现而异；
	③如果目标类型是一个整型，且待赋的值是浮点数，该行为未定义；
	④如果把浮点数换成整数，原来的浮点值会被截断；
	下面的程序演示了这些转换规则；
	
	#include<stdio.h>
	int main(void)
	{
		char ch;
		int i;
		float fl;

		fl = i = ch = 'C';
		printf("ch=%c,i=%d,fl=%2.2f\n", ch, i, fl);
		ch = ch + 1;
		i = fl + 2 * ch;
		fl = 2.0*ch + i;
		printf("ch=%c,i=%d,fl=%2.2f\n", ch, i, fl);
		ch = 1107;
		printf("Now ch=%c\n", ch);
		ch = 80.89;
		printf("Now ch=%c\n", ch);
		getchar();
		return 0;
	}
	
5.5.1	强制类型转换运算符 cast
	在某个变量的前面放置用圆括号括起来的类项名，该类型名是希望转换成的目标类型；通用形式是 (type)
	用实际需要的类型替换(如long)替换type即可；例：
	int mice;
	mice=1.6+1.7；		//1.6+1.7=3.3,截断为int，结果为3；
	mice=（int）1.6+(int)1.7;	//1.6和1.7都被强制转换成int，截断后结果1+1=2；
	
总结
	赋值运算符：
	=	将右侧的值赋给左侧变量；如：a=2;
	算数运算符：
	+	将其左侧的值与右侧的相加；如：1+2=3;
	-	将其左侧的值减去右侧的值；如：3-2=1;
	-	作为一元运算符，改变其右侧值的符号；如：-1;
	*	将其左侧的值乘以右侧的值；如：2*3=6;
	/	将其左侧的值除以右侧的值；若都是整数，计算结果被截断；如：3/2=1;
	%	将其左侧的值除以右侧的值，取其余数(限整数)；如：16%5=1;	
	++	对其右侧的值加1(++a);对其左侧的值加1(a++);
	--	对其右侧的值减1(--a);  对其左侧的值减1(a--);
	其他运算符：
	sizeof	获得其右侧运算对象的大小(字节)，运算对象可以是类型说明符(sizeof(int))或者变量sizeof a;
	(type)	强制类型转换运算符，将其右侧的值转成圆括号内指定的类型；(float)9=9.0;

5.6	带参数的函数
	
	#include<stdio.h>
	void pound(int n);//ANSI函数原型声明
	int main(void)
	{
		int times = 5;
		char ch = '!';//ASCII码=33
		float f = 6.0f;

		pound(times);//int类型的参数
		pound(ch);//pound((int)ch);
		pound(f);//pound((int)f)
		getchar();
		return 0;
	}
	void pound(int n)//ANSI风格函数头
	{
		while (n-- > 0) { printf("#"); }
		printf("\n");	
	}

	其中，函数头：
	void pound(int n);
	如果函数不接受任何参数，函数头的圆括号中应该写上关键字void
	由于该函数接受一个类型的参数，所以圆括号中包含一个int类型变量n的声明；
	声明参数就创建了一个形式参数（形参）；pound(10)就是把10的值赋给n；n是形参
	我们称函数调用传递的值为实际参数（实参）；10就是实际参数；
	所以pound(time)把实际参数time的值5传递给函数pound(int n)，然后函数把5赋值给形式参数(变量n);
	
	(可以理解为形参是没有分配内存的，传入实际参数才分配内存，运行之后被释放了，所以n不会存数，
	下一次传实参进去又分配内存给它继续执行；）
	
	看上面例子的函数调用过程：
	第一个函数调用的是pound(time)，time的值5被赋给n，因此printf()函数打印了5个#和一个换行符；
	第二个函数调用的是pound(ch)，ch是char类型，被初始化为！字符，在ASCII中ch的值是33。但是pound()函数
	的参数类型是int，与char不匹配，程序开头的函数原型声明发挥了作用，描述了函数的返回值和参数：
	①该函数没有返回值(函数名前面有void关键字)；
	②该函数有一个int类型的参数ponud（int n）；//pound(type n);
	该例中，函数原型告诉编译器pound()需要一个int类型的参数，于是当编译器执行到pound(ch)时，把ch转成int类型；
	同理，pound(f)也让float类型的变量被自带转换成int类型；
	
	
5.7	总结
	用一个程序来涵盖本章内容：
	
	#include<stdio.h>
	const int S_PER_M = 60;		//每分钟的秒数；
	const int S_PER_H = 3600;	//每小时的秒数；
	const double M_PER_K = 0.62137;//1公里转换的英里数；
	int main(void)
	{
		double distk, distm;//距离数k-公里；m-英里；
		double rate;//平均速度（英里/小时）；
		int min, sec;//分；秒；
		int time;
		double mtime;//跑1英里需要的时间（秒）；
		int mmin, msec;//跑1英里需要的时间，以分钟秒钟为单位；

		printf("this programe bonverts your time for a metric race\n");
		printf("to a time for running a mile and to your average\n");
		printf("speed in miles per hour.\n");
		printf("Please enter,in kilometers,the distance run.\n");
		scanf_s("%lf", &distk);//%lf读取一个double类型值；

		printf("Next enter the time in minutes and seconds.\n");
		printf("Begin by entering the minutes.\n");
		scanf_s("%d", &min);	
		printf("Now enter the seconds.\n");
		scanf_s("%d", &sec);

		time = S_PER_M * min + sec;//把时间转换成秒；
		distm = M_PER_K * distk;//把公里转换成英里；
		rate = distm / time * S_PER_H;//英里/秒*秒/小时=英里/小时；
		mtime = (double)time / distm;//时间/距离=跑1英里所用的时间（秒）；
		mmin = (int)mtime / S_PER_M;//求出分钟数；截断；
		msec = (int)mtime%S_PER_M;//求出余下的秒数；

		printf("You ran %1.2f km (%1.2f miles)in %d min,%d sec.\n", distk, distm, min, sec);
		printf("That pace corresponds to running a mile in %d min,%d sec.\n", mmin, msec);
		printf("Your average speed was %1.2f mph.\n", rate);

		getchar();
		getchar();	
		return 0;
	}

5.10 	复习题
	
	1.假设所有变量类型都是int，下列各项变量的值是多少；
	x=(2+3)*6;	//x=30;
	x=(12+6)/2*3;	//y=27;
	y=x=(2+3)/4;	//x=1;y=1;
	y=3+2*(x=7/2);	//x=3;y=9;
	x=(int)3.8+3.3;	//x=6;
	x=(2+3)*10.5;	//x=52;
	x=3/5*22.0;	//x=0;
	x=22.0*3/5;	//x=13;

	3.对下列各表达式求值；
	30.0/4.0*5.0；	//37.5
	30.0/(4.0*5.0);	//1.5
	30/4*5;		//35
	30*5/4;		//37
	30/4.0*5;		//37.5
	30/4*5.0;		//35.0
	
	6.下面的程序将输出什么：
	#include<stdio.h>
	#define FORMAT "%s! C is cool!\n"
	int main(void)
	{
		int num = 10;
		printf(FORMAT, FORMAT);	//printf("%s! C is cool!\n","%s! C is cool!\n");
		printf("%d\n", ++num);	//++num 先递增num=11 再输出11；结果输出11；
		printf("%d\n", num++);	//num++ 先使用num=11 printf()输出11；再递增num=12; 
		printf("%d\n", num--);	//num--   先使用num=12 printf()输出12；再递减num=11;
		printf("%d\n", num);		//num=11;直接输出；
		getchar();
		return 0;
	}

	7.下面的程序将输出什么：
	#include<stdio.h>
	int main(void)
	{
		char c1, c2;
		int diff;
		float num;
		c1 = 'S';		//ASCII码83
		c2 = 'O';		//ASCII码79
		diff = c1 - c2;	//diff=83-79=4；
		num = diff;	//num=4.0;
		printf("%c%c%c:%d %3.2f\n", c1, c2, c1, diff, num);
		// SOS:4 4.00
		getchar();
		return 0;
	}

	8.下面的程序将输出什么：
	#include<stdio.h>
	#define TEN 10
	int main(void)
	{
		int n = 0;
		while (n++ < TEN)		//n++;先使用再递增，0<10,n=1
			printf("%5d", n);	//输出    1继续循环；输出1~10每个数字前面带4空格；
		printf("\n");		//回车
		getchar();
		return 0;
	}
	
	修改上面的程序使其可以打印字母a~g; (ASCII码，a对应97，g=103)；

	#include<stdio.h>
	#define TEN 103
	int main(void)
	{
		char n = 96;
		while (n++ < TEN) { printf("%5c", n); }
		printf("\n");
		getchar();
		return 0;
	}
	
	或者;
	
	#include<stdio.h>	
	int main(void)
	{
		char ch = 'a';
		while (ch <= 'g') { printf("%5c", ch++); }
		printf("\n");
		getchar();
		return 0;
	}
	
	10.假设下面是完整程序中的一部分，它们分别输出什么：
	①
	int x=0;
	while(++x<3);		//++x,先递增x=1,1<3成立
		printf("%4d",x);	//输出    1    2
	
		
	②
	int x=100;
	while(x++<103)		//x++,先使用100<103成立；再递增x=101
		printf("%4d\n",x);	//输出  101回车 102回车 103回车
		printf("%4d\n",x);	//输出  104回车
	分析组后一行为什么会输出104
	#include<stdio.h>	
	int main(void)
	{
		int x = 100;
		while (x++ < 103)		//x++,先使用x=100<103成立；再递增x=101
			printf("%4d\n", x);	//输出  101回车 ，继续循环
		/*
		即:x=100,x<103成立；递增后：x=101；执行printf()输出 101；
		    x=101,x<103成立；递增后：x=102；执行printf()输出 102；
		    x=102,x<103成立；递增后：x=103；执行printf()输出 103；
		    x=103,x<103不成立；
		因为while()循环条件是个完整表达式，序列点在此处；副作用产生，x递增实现，x=104
		序列点：程序执行的点，在该点上，所有的副作用都在进行下一步之前发生。
		知识点：任何一个完整的表达式的结束也是一个序列点；
		*/
		printf("%4d\n", x);		//输出104
		getchar();
		return 0;
	}




	③
	char ch='s';
	while(ch<'w')		
	{
		printf("%c",ch);	//stuv
		ch++;
	}
	printf("%c\n",ch);		//w回车

	
	11.下面的程序会输出什么：
	
	#define MESG "COMPUTER BYTES DOG"
	#include<stdio.h>
	int main(void)
	{
		int n=0;
		while(n<5)
			printf("%s\n",MESG);		//n=0;循环只输出MESG一次；
			n++;			//n++不在循环内；
		printf("That's all.\n");			//输出That's all.回车；
		return 0;
	}


	12.分别编写一条语句，完成下面各任务（使其具有副作用）：
	①将变量x的值增加10；
		x=x+10;
	②将变量x的值增加1；
		x=x+1;
	③将a与b之和的两倍赋给c；
		c=2*(a+b);
	④将a与b的两倍之和赋给c；
		c=2*a+2*b;
	⑤将变量x的值减少1；
		x=x-1;
	⑥将n除以k的余数赋值给m；
		m=n%k;
	⑦q除以b减去a，并将结果赋给p；
		p=q/b-a;
	⑧a与b之和除以c与d的乘积，并将结果赋值给x；
		x=(a+b)/(c*d);

5.11	编程练习
	
	1.编写一个程序，用分钟表示的时间转换成用小时和分钟表示的时间。
	使用#define或const创建一个表示60的符号常量或const变量；
	通过while循环让用户重复输入值，小于等于0时停止循环；	
	#include<stdio.h>
	#include<Windows.h>
	#define M_PER_H 60
	int main(void)
	{
		int time,min, hour;
		time = 1;	
		while (time > 0)
		{
			printf("This program convert time format:MIN to HOUR_MIN.\n");
			printf("Please enter the time used by minutes.\n");
			scanf_s("%d", &time);	
			hour = time / M_PER_H;
			min = time % M_PER_H;
			printf("%d minutes = %d hours and %d minutes.\n\n", time, hour, min);	
			printf("(program continues until you enter 0.)\n");
			Sleep(2000);
			system("cls");
		}		
		getchar();
		return 0;
	}

	2.编写一个程序，提示用户输入一个整数，然后打印从该数到比该数大10的所有整数，如5，5~15；
	要求打印的各值之间用一个空格、制表符或者换行符分开；
	#include<stdio.h>
	int main(void) 
	{
		int a,c;
		printf("Please enter a num.\n");
		scanf_s("%d", &a);
		c =1;
		while (c++<12)printf("%d\n", a++);				
		getchar();
		getchar();
		return 0;
	}

	
	3.编写一个程序，提示用户输入天数，然后将其转换成周数和天数；（略）
	4.编写一个程序提示用户输入身高(厘米)，并分别以厘米和英寸为单位显示；允许有小数部分；
	该程序应该能让用户重复输入身高，直到用户输入一个非正值；示例输出如下：
	Enter a height in centimeters: 182
	182.0 cm = 5 feet, 11.7 inches
	Enter a height in centimeters(<=0 to quit): 168.7
	168.7 cm = 5 feet, 6.4 inches
	Enter a height in centimeters(<=0 to quit): 0
	bye
	
	#include<stdio.h>
	#define IN_PER_CM 0.3937
	#define IN_PER_FT 12
	int main(void) 
	{
		float cm,height, inch;
		int foot;		
		printf("Enter a height in centimeters:");
		scanf_s("%f",&cm);	
		while(cm>0)
		{
			height = cm * IN_PER_CM;
			foot = (int)height / IN_PER_FT;
			inch = height - foot * IN_PER_FT;
			printf("%.1f cm = %d feet,%.1f inches\n", cm, foot, inch);
			printf("Enter a height in centimeters(<=0 to quit):");
			scanf_s("%f", &cm);		
		}
		printf("bye\n");
		getchar();
		getchar();
		return 0;
	}
	
	5.编写一个程序使其可以与用户交互，根据用户输入的数进行计算：
	假设第1天赚$1,第2天赚$2，第3天赚$3，以此类推……
	
	#include<stdio.h>
	int main(void)
	{
		int days,date,wealth;
		wealth = 0;	
		printf("Suppose you make $1 on the first day,the next day $2,and the third day $3…\n");
		printf("Please enter the number of days you want to calculate:");
		scanf_s("%d", &days);
		date = days;
		while (days>0) 
		{		
			wealth = wealth + days;
			days--;
		}
		printf("So,you made $%d in %d days.\n", wealth,date);
		getchar();
		getchar();
		return 0;
	}

	
	6.修改上一题，使其能计算整数的平方和；
	即第1天赚$1，第2天赚$4，第三天赚$9……
	//wealth = wealth + days;改成wealth = wealth + days*days;即可

	7.编写一个程序，提示用户输入一个double类型的数，并打印该数的立方值。
	自己设计一个函数计算并打印立方值，main()函数要把用户输入的值传递给该函数。

	#include<stdio.h>
	double cubic(double);
	int main(void)
	{
		double x;
		printf("This program will calculate cubic number.\n");
		printf("Enter the number:");
		scanf_s("%lf", &x);
		printf("%lf*%lf*%lf=%lf\n", x, x, x, cubic(x));
		getchar();
		getchar();
		return 0;
	}
	double cubic(double x)
	{
		return x*x*x;
	}

	8.编写一个程序，显示求模运算的结果。把用户输入的第一个整数作为求模运算符的第二个运算对象；
	该数在运算过程中保持不变；用户后面输入的数是第一个运算对象。当输入一个非正值程序结束。
	示例如下：
	
	This progran computes moduli.
	Enter an integer to sever as the second operand:256
	Now enter the first operand: 438
	438 % 256 is 182
	Enter next number for first operand(<=0 to quit):1234567
	1234567 % 256 is 135
	Enter next number for first operand(<=0 to quit):0
	Done

	
	#include<stdio.h>
	int main(void)
	{
		int a, b;
		printf("This progran computes moduli.\n");
		printf("Enter an integer to sever as the second operand:");
		scanf_s("%d", &b);
		printf("Now enter the first operand:");
		scanf_s("%d", &a);
		while(a>0)
		{
			printf("%d %% %d is %d\n", a, b, a%b);
			printf("Enter next number for first operand(<=0 to quit):");
			scanf_s("%d", &a);
		}
		printf("Done");
		getchar();
		getchar();	
		return 0;
	}

	
	9.编写一个程序，要求用户输入一个华氏温度。程序应读取double类型的值作为温度值，并把该值作为参数
	传递给一个用户自定义的函数Temperatures()。该函数计算摄氏温度和开式温度，并以小数点后两位数字的
	精度显示三种温度。要使用不同的温标来显示这三个温度值。
	摄氏温度=5.0/9.0*（华氏温度-32.0）
	开式温度=摄氏温度+273.16
	Temperatures()函数中用const创建温度转换中使用的变量。在main()函数中使用一个循环让用户重复输入温度
	当用户输入q或其他非数字时，循环结束。scanf()函数返回读取数据的数量，所以如果读取数字则返回1，
	如果读取q则不返回1.可以使用=运算符将scanf()的返回值和1做比较，测试两值是否相等。
	

	#include<stdio.h>
	double Temperatures(double);
	int main(void)
	{
		double F;
		printf("please enter the number of temperatures(F):");
		while (scanf_s("%lf", &F))
		{
			Temperatures(F);
			printf("please enter the number of temperatures(F)(q to quit)");
		}	
		return 0;
	}
	double Temperatures(double F)
	{
		double C = 5.0 / 9.0 * (F - 32.0);
		double K = C + 273.16;
		printf("%.2lf H\n%.2lf ℃\n%.2lf K\n", F, C, K);
		return 1;
	}
	

【第六章】C控制语句：循环

程序流：1.执行语句序列；2.如果满足某些条件就重复执行语句序列(循环)；3.通过测试选择执行哪一个语句序列(分支)；

3种循环：while循环 、for循环、do while循环


6.1.1 while循环

	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		long num;
		long sum = 0L;
		int status;
		printf("Please enter an integer to be summed(q to quit):");	
		status = scanf_s("%ld", &num);
		while(status==1)
		{
			sum = sum + num;	
			printf("Please enter an integer to be summed(q to quit):");
			status = scanf_s("%ld", &num);
		}
		printf("Those integers sum to %ld.\n", sum);
		Sleep(2000);
		return 0;
	}


程序结构分析(伪代码)：伪代码：用一种间的的句子表示程序思路的方法；

	把sum初始化为0
	提示用户输入数据
	读取用户输入的数据
	当输入的数据为整数的时候
		将输入值累计到sum
		提示用户继续输入
		然后读取下一个输入
	输入完成后，输出sum的值；

	总之，因为while循环是入口条件循环，程序在进入循环之前必须获取输入的数据并检查status的值
	所以在while前面要有一个scanf_s()；
	要让循环继续执行，在循环内需要一个读取数据的语句，来重置status的值；

	所以可以将下面的伪代码作为while循环的标准格式：
		获得第一个用于测试的值
		当测试为真时
			处理值
			获取下一个值

6.1.2	C风格读取循环

	原代码格式：
	status = scanf_s("%ld", &num);
	while(status==1)
	{
		/*循环行为*/
		status = scanf_s("%ld", &num);
	}

	可以简化替换为

	while(scanf_s("%ld",&num)==1)
	{
		/*循环行为*/
	}
	
	第二种形式同时使用scanf_()的两种不同特性；
	首先，如果函数调用成功，scanf_s()会把一个值存入num
	然后，利用scanf_s()的返回值(0或1)来控制while循环。
	
	因为每次迭代都会判断循环的条件，所以每次都需要调用scanf_()读取新的num值来做判断；
	所以C语言特性让你可以用下面精简版本替代标准版本：
		当获取值和判断值都成功
			处理该值


6.2 	while语句
	while循环的通用形式如下：
	while(expression)
		statment
	statment部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复杂语句。
	到目前为止，expression部分都是使用关系表达式，如果expression为真(非0)，执行statment部分一次，
	然后再次判断xepression，在expression为假(0)之前，循环的判断和执行一直重复进行
	每次循环都被成为一次迭代(iteration)
	
6.2.1	终止while循环
	while循环有一点非常重要：在构建while循环时，必须让表达式的值有变化，表达式最终要为假(0)
	否则，循环就不会终止(实际上可以使用break和if语句来终止)
	考虑下面的例子：
	index=1；
	while(index<5){/*表达式*/}；
	↑程序将无限重复；
	index=1；
	while(--index<5){/*表达式*/}；
	↑程序虽然改变了index的值，但是需要循环到该类型数据溢出；
	//表达式改成++index<5则是达到执行有限的指定次数效果；

6.2.2	何时终止循环
	
	#include<stdio.h>
	int main(void)
	 {
		int n = 5;
		while (n < 7)			 //第5行
		{
			printf("n=%d\n", n);
			n++;			//第8行
			printf("now n=%d\n", n);	//第9行
		}
		printf("the loop has finished.\n");
		getchar();
		return 0;
	}
--------------------------------------------
	n=5
	now n=6
	n=6
	now n=7
	the loop has finished.
	
	在第二次循环时，变量n在第8行首次获得值7，程序此时并未退出，它继续执行本次循环(执行第9行)，
	并在对第5行的测试条件求值时候才退出循环n=7  (n<7)不成立，退出循环，执行循环外语句。

6.2.3	while：入口循环条件
	while循环是使用入口条件的有条件循环。所谓有条件指的是语句部分的执行取决于表达式的描述/限定；
	例如(index<5),该表达式是一个入口条件(entry condition),满足该条件才能进入循环。
	
6.2.4	语法要点
	使用while时，要牢记一点：只有在测试条件后面的单独语句(简单语句或复合语句)才是循环部分；
	错误示例：
	
	#include<stdio.h>
	int main(void) 
	{
		int n = 0;
		while(n<3)	
			printf("n is %d\n", n);	//该部分为循环部分；因n没有重置而陷入死循环；
			n++;			//不在测试条件后面的单独语句；跳出循环前不执行；
		printf("that's all this program does.\n");
		getchar();
		return 0;	
	}
	
	
	综上，即使while语句本身是复合语句，但是在语句构成上，它也是一条单独的语句；
	该语句从while开始执行，到第一个分号结束。在使用了复合语句情况下到右花括号结束。

	示例：下面两个例子输出结果差别：

	#include<stdio.h>
	int main(void) 
	{
		int n = 0;
		while(n++<3)	
			printf("n is %d\n", n);	//while语句结束位置	
		printf("that's all this program does.\n");
		getchar();
		return 0;	
	}
	

	#include<stdio.h>
	int main(void) 
	{
		int n = 0;
		while(n++<3)
		；			//while语句结束位置
		printf("n is %d\n", n);	
		printf("that's all this program does.\n");
		getchar();
		return 0;	
	}
	
	在后一例中，测试条件后的单独分号是空语句(null statement),它什么也不做；
	有时故意使用带空语句的while语句，因为所有的任务都在测试条件中完成了，不需要在循环中做什么。
	例如，假设你想跳过输入到第一个非空白字符或数字，可以这样写：
	while(scanf_s("%d",&num)==1)
	;		

	只要scanf_s()读取一个整数，就会返回1，循环继续执行。
	为了提高代码可读性，应该让这行分号独占一行，不要直接把它放在测试表达式同行。
	这样一方面让读者更容易看到空语句；另一方面也提醒自己和读者，空语句是有意而为之。

6.3	用关系运算符和表达式比较大小
	＜	小于
	＞	大于
	≤	小于等于
	≥	大于等于
	==	等于
	！=	不等于
	
	示例
	while(number<6)
	while(ch!='$')
	while(scanf_s("%f",&num)==1)
	
	虽然运算关系也可以用来比较浮点数，但是要注意：比较浮点数时，尽量使用<和>
	因为浮点数的舍入误差导致在逻辑上应该相等的两数却不相等，例如3乘以1/3的积是1.0
	如果把1/3表示成小数点后6位数字，乘积则是0.999999不等于1.0
	使用fabs()函数（声明在math.h头文件中）可以方便的比较浮点数，该函数返回一个浮点值的绝对值。
	示例：

	#include<stdio.h>
	#include<math.h>
	int main(void)
	{
		const double answer = 3.14159;
		double respons;
		printf("What's the value of pi?\n");
		scanf_s("%lf", &respons);
		while(fabs(respons-answer)>0.0001)
		{
			printf("try again!\n");
			scanf_s("%lf", &respons);
		}
		printf("close enough!\n");
		getchar();
		getchar();
		return 0;
	}
	
6.3.1	什么是真
	在C语言中，表达式一定有一个值，关系表达式也不例外。
	示例：程序打印两个关系表达式的值，一个为真一个为假。
	#include<stdio.h>
	int main(void)
	{
		int truevalu, falsevalu;
		truevalue = (10 > 2);
		falsevalue = (10 == 2);
		printf("ture=%d;false=%d\n", truevalu, falsevalu);
		getchar();
		return 0;
	}

	所以对C语言而言，表达式为真的值是1，表达式为假的值是0；
	有些循环结构由于1为真，所以循环会一直执行如；while(1){...}

6.3.2	其他真值

	#include<stdio.h>
	int main(void)
	{
		int n = 3;
		while(n)
		{
			printf("%2d is true\n", n--);
		}
		printf("%2d is false\n", n);

		n = -3;
		while (n)
		{
			printf("%2d is true\n", n++);
		}
		printf("%2d is false\n", n);
		getchar();
		return 0;
	}

	也可以说，只要测试条件的值为非零，就会执行while循环。
	这是从数值方面，而不是真/假方面来看测试条件；
	要牢记：关系表达式为真，求值得1；关系表达式为假，求值得0；
	因此，这些表达式实际上相当于数值。
	因此可以很好的利用测试条件这一特性；比如用while(valu)替换while(valu!=0)

6.3.3	真值的问题
	C对真的概念约束太少会带来一些麻烦；例如：
	
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		long num;
		long sum = 0L;
		int status;

		printf("Please enter an integer to be summed(q to quit):");	
		status = scanf_s("%ld", &num);
		while(status=1)					//将等号==改为赋值=
		{
			sum = sum + num;	
			printf("Please enter an integer to be summed(q to quit):");
			status = scanf_s("%ld", &num);
		}
		printf("Those integers sum to %ld.\n", sum);
		Sleep(2000);
		return 0;
	}
	
	调试程序，本应在用户输入q结束输入并计算结果的时候，循环开始陷入重复输入提示的bug……

	由于status=1是一个赋值表达式语句，赋值后，while(status=1)循环语句实际就变成while(1),
	虽然用户输入q，status被设置为0，但是循环测试条件把status又重置为1，进入了下一次迭代；
	那为什么会陷入重复提示且无法输入呢？
	因为，如果scanf_s()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，供下次读取；
	当scanf_s()把q作为整数读取失败了，它把q留下。
	在下次循环时，scanf_s()函数从上次读取失败的地方(q)作为整数开始读取，又失败了，陷入无限循环；

	不要在本应使用==的地方使用=
	一些计算机语言如(basic)用相同的符号表示赋值运算符和关系相等运算符，但这两个运算符完全不同
	示例：
	value==5  //检查value的值是否为5；
	value=5	//把数值5赋给value；
	
	tips：如果待比较的值是常量，可以把该常量放在左侧有助于编译器捕获错误
	5=value；//语法错误；
	5==value	//检查value的值是否为5；

	这是因为C语言不允许给常量赋值，编译器会把赋值运算符的这种用法作为语法错误标记出来；

	总之，关系运算符用于构成关系表达式，关系表达式为真的时候值是1，为假时值为0.
	通常用关系表达式作为测试条件的语句如while if可以使用任何表达式作为测试条件，非零为真，零为假

6.3.4	C99新增的 _Bool 类型
	
	在编程中，表示真或假的变量称为布尔变量（boolean variable），所以_Bool是C语言中布尔变量的类型名；
	_Bool类型的变量只能存储1(真)或0(假)，如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1；
	
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		long num;
		long sum = 0L;
		_Bool input;

		printf("Please enter an integer to be summed(q to quit):");	
		input =( scanf_s("%ld", &num)==1);
		while(input)					
		{
			sum = sum + num;	
			printf("Please enter an integer to be summed(q to quit):");
			input =( scanf_s("%ld", &num)==1);
		}
		printf("Those integers sum to %ld.\n", sum);
		Sleep(2000);
		return 0;
	}
	
	C99提供了stdbool.h的头文件，该头文件让bool成为_Bool的别名，而且还把true和false分别定义为1和0；
	包含该头文件后，写出的代码可以与C++兼容，因为C++把bool ture false定义为关键字；
	如果系统不支持_Bool类型，导致无法运行该程序，可以把_Bool替换成int即可。

6.3.5	优先级和关系运算符

	1.关系运算符的优先级比算术运算符低，比赋值运算符高。
	这意味着
	 x>y+2 和 x>(y+2)相同；
	 x=y>2 和 x=(y>2)相同；//如果y大于2，则给x赋值1，否则0，y的值不会赋给x；
	
	2.关系运算符之间有不同的优先级
	高优先级组：＜ ≤ ＞ ≥
	低优先级组：== !=
	与其他大多数运算符一样，关系运算符的结合律也是从左往右；因此
	ex!=wye==zee 和 (ex!=wye)==zee 相同//先判断ex与wye是否相等得出值0或者1，再与zee比较；

	完整优先等级表
	运算符(优先级从高到低)	结合律
	（）			从左往右→
	-  +  ++  -- sizeof		从右往左←	
	*   /  %			从左往右→
	+  -			从左往右→
	<  >  ≥  ≤			从左往右→
	==  !=			从左往右→
	=			从右往左←	

6.4	不确定循环和计数循环
	不确定循环：在测试表达式为假之前，预先不知道要执行多少长循环
	计数循环：   在循环执行之前就知道要重复执行多少次

	#include<stdio.h>
	int main(void)
	{
		int a = 1;			//初始化
		while (a <= 10)		//测试
		{
			printf("goodluck\n");	//行为
			a++;		//更新计数
		}
		getchar();
		return 0;
	}
	
	在创建一个重复执行固定次数的循环中涉及3个行为：
	1.必须初始化计数器；
	2.计数器与有限的值作比较；
	3.每次循环时递增/减计数器；

	在上面的例子中，递增发生在循环的末尾，可以防止不小心漏掉递增，因此这样比(a++<=10)好，
	但是计数器的初始化放在循环外，就有可能忘记初始化。

6.5	for循环
	for循环将上述3个行为(初始化、测试和更新)组合在一起
	#include<stdio.h>
	int main(void)
	{
		int a;	
		for (a = 1; a <= 10; a++)
		{
			printf("%d	%d",a,a*a);
		}
		getchar();
		return 0;
	}
	
	关键字for后面的圆括号内有3个表达式，分别用分号隔开；
	第1个表达式是初始化；只会在for循环开始时执行一次；
	第2个表达式是测试条件，在执行循环之前对表达式求值，如果表达式为假，循环结束；
	第3个表达式执行更新，在每次循环结束时求值；
	
	这三个表达式也叫控制表达式，都是完整的表达式，所以每个表达式的副作用都发生在下一个表达式求值之前

6.5.1	利用for的灵活性
	for的灵活性源于如何使用for循环中的3个表达式
	在前面示例中，1表达式给计数器赋初值，2表达式计数器范围，3表达式递增计数器
	除此以外，for循环还有其他9种用法：

	1.递减计数
	for(a=5;a>0;a--)
	
	2.固定数递增
	for(n=2;n<60;n=n+10)
	
	3.用字符代替数字计数
	for(ch='a';ch<='z';ch++)

	4.除了测试迭代次数外，还可以测试其他条件比如
	for(a=1;a<=6;a++)替换成for(a=1;a*a<=36;a++)
	与控制次数相比，如果更关心测试条件限制，可以这样使用；
	
	5.让递增的量几何增长，而不是算术增长
	for(a=10;a<150;a=a*1.2)

	6.第三个表达式可以使用任意合法的表达式；并每次迭代都会更新该表达式的值
	for(x=1;y<=75;y=(++x*5)+50)

	7.可以省略一个或多个表达式
	n=25;
	for(a=2;n<=125;){n=n*a}//该循环保持a=2;变量n的值从初始25变50 100 200；
	另；省略第2个表达式被视为真，所以for(;;),则循环会一直运行；

	8.第1个表达式不一定是给变量赋初值，也可以使用printf()
	在执行循环其他部分之前，只对第1个表达式求一次值或执行一次；例：
	#include<stdio.h>
	int main(void)
	{
		int num = 0;
		for (printf("keep entering numbers!\n"); num != 6;)
		{scanf_s("%d", &num);}
		printf("That's the one I want!\n");
		getchar();
		getchar();
		return 0;
	}


	9.循环体中的行为可以改变循环头中的表达式；例如
	for(n=1;n<10000;n=n+delta)
	如果程序经过几次迭代后发现变量delta太小或者太大，循环中的if语句可以改变delta的值
	在交互式程序中，用户可以在循环运行时才改变delta的值；但如果delta为0循环失效；

6.6	其他赋值运算符 +=  -=  *=  /=  %=
	
	a+=20	等效于	a=a+20
	a -=20	等效于	a=a -20
	a *=20	等效于	a=a *20
	a /=20	等效于	a=a /20
	a%=20	等效于	a=a%20

	上述所列运算符右侧都使用了简单的数字，还可以使用更复杂的表达式；例如
	x*=3*y+12	等效于	x=x*(3*y+12)


6.7	逗号运算符

	示例程序：
	
	#include<stdio.h>
	int main(void)
	{
		int a, b;
		for (a = 1, b = 5; a <= 5; a++, b += 3)
		{printf("%d %d\n", a, b);}
		getchar();
		return 0;
	}
	
	该程序在初始化表达式和更新表达式中都使用了逗号运算符；
	初始化表达式中逗号使得a和b都进行了初始化；
	更新表达式中逗号使每次迭代都更新a和b的值；绝大部分计算都在for循环头中进行

	逗号运算符并不局限在for循环，但是这是它最常用的地方
	逗号运算符有2个特质：
	1.	首先它保证了被它分隔的表达式从左往右求值；(即逗号是一个序列点)
	逗号左侧所有副作用都在程序执行逗号右侧前发生；
	例如 a++,b=a+20;在该表达式中，先递增a的值，然后在b的表达式中使用a更新后的值；

	2.	整个逗号表达式的值是右侧项的值，例如：
	x=(y=3,(z=++y+2)+5);
	效果是先把3赋给y，然后y递增为4，然后4+2=6赋给z，z+5=11赋给x；x=11；
	
	另，加入在输入数字时不小心输入了逗号：
	a=249,500;
	此表达式没语法错误，编译器会将其解释成一个逗号表达式；即a=249为左侧，500为右侧表达式；
	效果类同于 
	a=249;
	500;	//tips:任何表达式后面加上一个分号就成了表达式语句，500；也是一条语句，虽然它什么都不做；
	
	另，
	a=(249,500);	//赋值给a的值是逗号右侧的子表达式的值，即a=500;
	
	逗号也可以作为分隔符。如 int a=2,b=3;此时逗号是分隔符，不是逗号运算符；




6.7.1	芝诺悖论与for循环
	
	芝诺二分法悖论
	
	从A点到B点，必须通过AB之间的中点，每一次到达中点后剩下的路程还有中点…
	按照芝诺悖论，把AB之间有限的距离无限细分，永远走不完这条路……
	用无限序列来表示总时间，假设走到AB中点花费的时间为1，则匀速走完AB需要的时间s：
	s=1+1/2+1/4+1/8+1/16+……

	#include<stdio.h>
	int main(void)
	{
		int a;//计数项
		double s, zeno;//s:所花时间总和，zeno：每次剩下一半的变量
		int limit;//查看点

		printf("Enter the number of terms you want:");
		scanf_s("%d", &limit);
		for (s = 0, zeno = 1, a = 1; a <= limit; a++, zeno = zeno * 2.0)
		{
			s = s + 1.0 / zeno;
			printf("time=%f when terms =%d.\n", s, a);
		}
		getchar();
		getchar();
		return 0;
	}
	
	
	数学家证明当项的数目接近无穷时，总和无限接近2.0，数学证明方法：
	
	s=1+1/2+1/4+1/8+1/16……
	
	将s除以2可得

	s/2=1/2+1/4+1/8+1/16……
	
	将第一个式子减去第二个式子可得
	s-s/2=1,

	即s=2；
	

6.8	出口条件循环 do while
	
	while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，
	所以有可能根本不执行循环中的内容；
	而出口条件循环则是在循环的每次迭代之后检测测试条件，
	这保证了至少执行循环中的内容一次；这种循环成为do while
	
	示例
	#include<stdio.h>
	int main(void)
	{
		int a,code;
		code = 13;
		printf("wellcome to play number riddle\n");
		do
		{	
			printf("Please enter a number you choose:");
			scanf_s("%d", &a);
		} 
		while (a != code);
		printf("congratulations!\n");
		getchar();
		getchar();
		return 0;
	}

	do while循环的通用形式：
	
	do
	        statement
	while(expression);
	
	statement可以是一条简单语句或复合语句，do while循环以分号结尾；
	do while 循环适应于那些至少要迭代一次的循环，如：
	
	do
	{
		提示用户输入密码
		读取用户输入的密码
	}while（用户输入的密码不等于密码）；
	
	
6.9	如何选择循环
	入口条件循环和出口条件循环按照是否需要必须执行一次来选择；
	通常入口条件循环常用些，好处在于：
	1.一般原则是在执行程序前测试条件比较好
	2.测试条件放在循环的开头程序可读性更高；
	3.许多应用中要求在一开始不满足测试条件时直接跳过整个循环；
	
	入口条件循环的选择用for还是while看个人喜好；
	一般当循环涉及初始化和更新变量时，用for循环比较合适，其他情况下while循环更好；
	如
	while(scanf_s("%ld",&num)==1)
	for(count=1;count<=100;count++)


6.10	嵌套循环
	嵌套循环指的是在一个循环内包含另一个循环，嵌套循环常用于按行和列显示数据
	也就是说一个循环处理一行所有的列，另一个循环处理所有的行
	示例：
	#include<stdio.h>
	#define ROWS 6
	#define CHARS 10
	int main(void)
	{
		int row;
		char ch;
		for (row = 0; row < ROWS; row++)		//外层循环，创建6行
		{
			for (ch = 'A'; ch < ('A' + CHARS); ch++) 	//内层循环，打印10字符
			{ printf("%c", ch); }
			printf("\n");
		}
		getchar();
		return 0;
	}

6.10.2	嵌套变式
		
	#include<stdio.h>
	int main(void)
	{

		const int ROWS = 6;
		const int CHARS = 6;
		int row;
		char ch;	
		for (row = 0; row < ROWS; row++)
		{
			for (ch = ('A' + row); ch < ('A' + CHARS); ch++)
			{printf("%c", ch);}
			printf("\n");
		}
		getchar();
		return 0;
	}


6.11	数组简介
	数组是按照顺序存储的一系列类型相同的值；整个数组有一个数组名，通过整数下标访问数组中单独的项或元素
	声明示例如下：
	float debts [20];
	
	声明debts是一个内含20个元素的数组，每个元素都是存储float类型的值；
	第1个元素是debts[0],第2个元素是debts[1]…以此类推直到debts[19]；
	
	数组元素编号从0开始，而不是从1开始，可以给每个元素赋值，比如
	debts[5]=32.2;
	debts[6]=1.732;
	实际上使用数组元素和使用同类型的变量一样，例如可以把值读入指定的元素中：
	scanf_s("%f",&debts[4]);	//把一个值读取入数组的第5个元素
	tips：C编译器不会检查数组的下标是否正确，例如示例声明中：
	debts[30]=20.5;	//该数组元素实际并不存在，debts[19]是该数组最后的元素；
	因为编译器不会查找这样的错误，当程序运行时，会导致数据被放置在已被其他数据占用的地方
	这可能会破坏程序的结果甚至导致程序异常中断；
	
	int num[20];	//可存储20个int类型整数的数组；
	char name[50];	//可存储50个字符的数组；
	long big[500];	//可存储500个long类型整数的数组；
	
	字符串：如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成字符串；
	you can see it.	char[15]	//字符数组，不是字符串；
	you can see it.\0	char[16]	//即是字符数组，也是字符串

	用于识别数组元素的数字被称为下标/索引/偏移量；
	下标必须是整数而且要从0开始计数，数组的元素被依次存储在内存中的相邻位置；如：
	
	int boo[4]  (每个int为2字节)

	1980	46	4816	3
	boo[0]	boo[1]	boo[2]	boo[3]
	
	char foo[4]  (每个char为1字节)

	h	e	l	p
	foo[0]	foo[1]	foo[2]	foo[3]


6.11.1	在for循环中使用数组
	示例：程序读取10个高尔夫分数，稍后进行处理；使用数组就不用创建10个不同的变量来存储10个高尔夫分数
	而且，还可以用for循环来读取数据，程序输出总分、平均分、差点(平均分与标准分的差值)

	#include<stdio.h>
	#define SIZE 10
	#define PAR 72
	int main(void)
	{	
		int index,score[SIZE];
		int sum = 0;
		float average;
		printf("Enter %d golf scores:\n", SIZE);
		for (index = 0; index < SIZE; index++) 
		{ scanf_s("%d", &score[index]); }//读取10个高尔夫分数
		printf("The scores read in are as follow:\n");
		for(index=0;index<SIZE;index++)
		{printf("%2d %5d\n", index+1, score[index]);}//验证输入
		for (index = 0; index < SIZE; index++) { sum = sum + score[index]; }//求总分
		average = (float)sum / SIZE;//求平均分
		printf("Sum of score=%d,average=%.2f\nThat's a handicap of %.0f.\n", sum, average, average - PAR);
		getchar();
		getchar();
		return 0;
	}

6.12	使用函数返回值的循环示例
	
	#include<stdio.h>
	double power(double n, int p);	//ANSI函数原型
	int main(void)
	{
		double x, xpow;
		int exp;
		printf("Enter a number and the positive integer power");
		printf("to which\nthe number will be raised.(q to quit).\n");
		while (scanf_s("%lf %d", &x, &exp) == 2)
		{
			xpow = power(x, exp);//函数调用
			printf("%.3g to the power %d is %.5g\n", x, exp, xpow);
			printf("Enter next pair of numbers or q to quit.\n");
		}
		printf("hope you enjoyed this power trip--bye!\n");
		return 0;
	}
	double power(double n, int p)	//函数定义
	{
		double pow = 1;
		int i;
		for (i = 1; i <= p; i++)
			pow *= n;
		return pow;
	}


6.12.2	使用带返回值的函数
	声明函数，调用函数，定义函数，使用关键字return，都是定义和使用带返回值函数的基本要素
	为什么在定义中说明了power()的返回类型为double，还要单独声明这个函数？
	既然在使用函数返回值之前要声明函数，为什么scanf_s()返回值之前没有声明scanf_s()
	
	编译器在程序中首次遇到power()时，需要直到它的返回类型；
	此时编译器尚未执行到power()的定义，并不知道函数中的返回类型是double
	因此必须通过前置声明，预先说明函数的返回类型，前置声明告诉编译器，该函数的定义在别处，
	其返回类型为double。如果把power()函数的定义置于main()的文件顶部，就可以省略前置声明，
	但是这不是C语言的标准风格，因为main()通常只提供整个程序的框架，最好把main()放在所有函数定义的前面；
	另外，通常把函数放在其他文件中，所以前置声明必不可少；
	scanf_s()能使用的原因是已经声明了，stdio.h头文件中包含了函数原型，它的返回类型是int


6.13	关键概念
	1.注意循环的测试条件要能使循环结束(可退出)；
	2.确保循环测试中的值在首次使用之前已经初始化；
	3.确保循环在每次迭代都更新测试的值；

	C通过求值来处理测试条件，结果为0表示假，非0表示真，带关系运算符的表达式也常用来做循环测试；
	数组由相邻的内存位置组成，只存储相同类型的数据，下标从0开始编号；
	
	使用函数设计3个步骤：
	1.通过函数原型声明函数；
	2.在程序中通过调用函数使用；
	3.定义函数；
	
	函数原型是为了方便编译器查看程序中使用的函数是否正确，函数定义描述了函数如何工作；
	现代的编程习惯是把程序要素分为接口部分和实现部分，例如函数原型和函数定义
	接口部分描述了如何使用一个特性，也就是函数原型所做的；
	实现部分描述了具体的行为，这正是函数定义所做的。

	
6.14	本章小结
	
	1.典型的while循环设计伪代码如下：

	获得初值
	while(满足测试条件)
	{
	处理该值
	获取下一个值
	}

	2.for循环也可以完成相同的任务：
	
	for(获得初始值；满足测试条件；获得下一个值)
		{处理该值}

	这些循环都使用测试条件来判断是否继续执行下一次迭代；
	一般而言，如果对测试表达式求值为非0，继续循环，否则循环结束

6.15	复习题
	
	1.写出执行完下列各行后quack的值是多少；后5行使用的均是前1行quack的值
	int quack=2；	//quack=2
	quack+=5;	//quack=quack+5	==7
	quack*=10;	//quack=quack*10	==70
	quack-=6;		//quack=quack-6	==64
	quack/=8;		//quack=quack/8	==8
	quack%=3;	//quack=quack%3	==2


	2.假设value是int类型，下面循环的输出是什么？如果value是double类型，会出现什么问题？
	
	for(value=36;value>0;value/=2)printf("%3d",value);
	
	36	18	9	4	2	1	
	
	36.0	18.0	9.0	4.5	2.25	1.125	……
	
	3.用代码表示以下测试条件：
	①.x大于5					//x>5;
	②.scanf_s()读取一个名为x的double类型的值且失败	//double x;    scanf_s("%lf",&x)==0;//scanf_s("%lf",&x)!=1;
	③.x的值等于5				//x==5;
	④.scanf_s()成功读入一个整数			//int x;    scanf_s("%d",&x)==1;
	⑤.x不等于5				//x!=5;
	⑥.x大于或等于20				//x>=20;

	5.下面的程序有点问题，请找出问题所在

	#include<stdio.h>
	int main(void)
	{					//第3行；				
		int i, j, list[10];			//第4行；	

		for (i = 1; i <= 10; i++)		//第6行；for(;;)中间分号隔开
		{				//第7行；			
			list[i] = 2 * i + 3;		//第8行；
			for (j = 1; j <= i; j++)	//第9行；	for(;;)中间分号隔开；j<=i;否则无限循环
				printf("  %d", list[j]);	//第10行；	
			printf("\n");		//第11行；	
		}				//第12行；}为for循环结尾					
		getchar();
		return 0;
	}		
	

	6.编写一个程序打印下面的图案，要求使用嵌套循环：
	$$$$$$$$
	$$$$$$$$
	$$$$$$$$
	$$$$$$$$
	
	#include<stdio.h>
	int main(void)
	{
		int a, b;	
		for (a = 0; a < 4; a++)
		{
			for (b = 0; b < 8; b++) 
				printf("$");
			printf("\n");		
		}
		getchar();
		return 0;
	}
	

	7.下面的程序各打印什么内容？
	
	①//Hi! Hi! Hi! Bye! Bye! Bye! Bye! Bye! 
	#include<stdio.h>
	int main(void)
	{
		int i = 0;
		while (++i < 4)
			printf("Hi! ");
		do
			printf("Bye! ");
		while (i++ < 8);
		getchar();
		return 0;
	}
	

	②//ACGM
	#include<stdio.h>
	int main(void)
	{
		int i;
		char ch;
		for (i = 0, ch = 'A'; i < 4; i++, ch += 2 * i)
			printf("%c", ch);
		getchar();
		return 0;
	}
	
	

	8.假设用户输入的是 Go west,young man! 下面各程序输出的是什么？
	(在ASCII码中 !紧跟在空格字符后面)

	①// Go west,youn	/*循环遇到输入g后终止；*/

	#include<stdio.h>
	int main(void)
	{
		char ch;
		scanf_s("%c", &ch,1);
		while (ch != 'g')
		{
			printf("%c", ch);
			scanf_s("%c", &ch,1);
		}
		return 0;
	}

	
	②// Hp!xfty-zpvo	/*循环遇到输入g后终止，所有输出按照输入偏移1个值*/
	
	#include<stdio.h>
	int main(void)
	{
		char ch;
		scanf_s("%c", &ch,1);
		while (ch != 'g')
		{
			printf("%c", ++ch);
			scanf_s("%c", &ch,1);
		}
		return 0;
	}	
		
	
	③//Go west,young	/*do while 遇到输入g时先输出g然后终止循环*/

	#include<stdio.h>
	int main(void)
	{
		char ch;
		do
		{
			scanf_s("%c", &ch,1);
			printf("%c",ch);
		}
		while (ch != 'g')
		return 0;
	}	
	
	④$o west,youn	/*for循环初始值执行一次ch=$赋值行为，遇到输入g后终止循环*/
	
	#include<stdio.h>	
	int main(void)
	{
		char ch;
		scanf_s("%c", &ch, 1);
		for (ch = '$'; ch != 'g'; scanf_s("%c", &ch))
			printf("%c", ch);		
		return 0;
	}
		

	9.下面的程序输出什么内容？
	
	#include<stdio.h>
	int main(void)
	{
		int n, m;
		n = 30;
		while (++n <= 33)
			printf("%d|", n);//31|32|33|

		n = 30;
		do
			printf("%d|", n);
		while (++n <= 33);	//30|31|32|33|

		printf("\n***\n");	//换行***换行

		for (n = 1; n*n < 200; n += 4)
			printf("%d\n", n);	//1换行5换行9换行13换行

		printf("\n***\n");	//换行***换行

		for (n = 2, m = 6; n < m; n *= 2, m += 2)
			printf("%d %d\n", n, m);//2 6换行 4 8换行 8 10换行

		printf("\n***\n");	//换行***换行

		for (n = 5; n > 0; n--)
		{
			for (m = 0; m <= n; m++)
				printf("=");
			printf("\n");
		}//======换行=====换行====换行===换行==换行

		getchar();
		return 0;
	}
	
	10.考虑下面的声明：
	double mint[10];
	数组名是什么？	//mint
	该数组有多少个元素	//10
	每个元素可以存储什么类型的值	//double
	下面哪一个scanf_s()的用法正确：
	①scanf_s("%lf",mint[2])
	②scanf_s("%lf",&mint[2])	//正确项
	③scanf_s("%lf",mint)
	
	11.下面程序创建了一个存储2、4、6、8等以2为计数的数组，查找程序问题：
	
	#include<stdio.h>
	#define SIZE 8
	int main(void)
	{
		int two[SIZE];
		int index;
		for (index = 1; index <= SIZE; index++)
			two[index] = 2 * index;
		for (index = 1; index <= SIZE; index++)
			printf("%d\n", two[index]);	//原程序printf("%d\n", two]);输出错误；
		getchar();
		return 0;
	}

	14.下面的程序输出什么内容：
	#include<stdio.h>
	int main(void)
	{
		int k;
		for (k = 1,printf("%d:Hi!\n", k); printf("k=%d\n", k), k*k < 26; k += 2, printf("Now k is %d\n", k))
			printf("k is %d in the loop\n", k);
		getchar();
		return 0;
	}

	//输出内容
	1:Hi!
	k=1
	k is 1 in the loop
	Now k is 3
	k=3
	k is 3 in the loop
	Now k is 5
	k=5
	k is 5 in the loop
	Now k is 7
	k=7


6.16	编程练习
	1.编写一个程序，创建一个包含26个元素的数组，并在其中存储26个小写字母并输出
	①
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY];
		int index;
		for (index = 0; index < QTY; index++)
			scanf_s("%c", &ch[index],1);	//给ch[]数组分配26个小写字母
		for (index = 0; index < QTY; index++)
			printf("%c\n", ch[index]);	//输出数组内容；	
		getchar();
		getchar();
		return 0;
	}
	//该程序仍需要手动输入a~z字母给数组；那有没有办法可以让系统自动分配字母给数组呢？
	
	②
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY];
		char a = 'a';
		int index;
		for (index = 0; index < QTY; index++)
		{
			ch[index] = a++;
			printf("%c", ch[index]);		
		}
		getchar();
		return 0;
	}

	③
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY];
		char a = 'a';
		int index=0;
		while(index<QTY)
		{
			ch[index++] = a++;
			printf("%c", ch[index-1]);			
		}
		getchar();
		return 0;
	}

	④
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY]="abcdefghijklmnopqrstuvwxyz";
		int index;
		for(index=0;index<QTY;index++)
			printf("%c",ch[index]);
		getchar();
		return 0;
	}
	//程序直接将数组内容预赋值完毕；
	
	⑤
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY];
		char a = 'a';
		int index;
		for (index = 0; index < QTY; index++)
		{
			ch[index-1] = a++;
			printf("%c", ch[index-1]);
		}
		getchar();
		return 0;
	}
	
	//想一想下面这个程序为什么不对：
	#include<stdio.h>
	int main(void)
	{
		char ch[26];
		int a,index=0;
		ch[index]='a';
		for(a=0;a<26;a++)
		{
			printf("%c",ch[index]);			
			ch[index]++;
		}
		getchar();
		return 0;
	}
	//虽然输出了26个字母，但是都是ch[0],index始终没更新给下一个数组；
	

	2.使用嵌套循环，按下面格式打印字符：	
	$
	$$
	$$$
	$$$$
	$$$$$
	
	#include<stdio.h>
	int main(void)
	{
		int a,b;
		for (a = 0; a < 5; a++)
		{
			for (b = 0; b <= a; b++)
				printf("$");
			printf("\n");
		}
		getchar();
		return 0;
	}


	3.使用嵌套循环，按下面的格式打印字母：
	F
	FE
	FED
	FEDC
	FEDCB
	FEDCBA

	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		int n,index;
		for (n = 5; n >=0; n--) 
		{
			for (index = 5; index >=n; index--)
				printf("%c", ch[index]);
			printf("\n");
		}
		getchar();
		return 0;
	}


	4.使用嵌套循环，按下面的格式打印字母：
	A
	BC
	DEF
	GHIJ
	KLMNP
	PQRSTU

	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		int n, m,index=0;
		for (n = 0; n < 6; n++)			//n控制换行数
		{
		
			for (m = 0; m <= n; m++)		//m控制每行字母数量
			{
				printf("%c", ch[index]);	//index控制输出字母
				index++;
			}
			printf("\n");
		}
		return 0;
	}



	5.编写一个程序，提示用户输入大写字母，使用嵌套循环以下面金字塔型的格式打印字母：
	
	          A         	
	        ABA
	      ABCBA
	    ABCDCBA	        
	  ABCDEDCBA
	
	打印这样的图形，要根据用户输入的字母来决定，例如上面的图形是在用户输入E后的打印结果
	提示：用外层循环处理行，每行使用3个内层循环，分别处理空格，升序字母，降序字母的输出
	
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		int a,b,c,d,row;
		char E, ch[QTY] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		printf("Please enter a capital letter: ");
		scanf_s("%c", &E, 1);
		row = E +1- 'A';
		for (a = 0; a < row; a++)			//for循环控制换行；
		{
			for (b = row-1; b > a; b--)		//for循环输入空格
				printf(" ");
			for (c = 0; c <= a; c++)		//for循环输入顺序字母
				printf("%c", ch[c]);
			for (d =0 + a; d >0; d--)		//for循环输入逆序字母
				printf("%c", ch[d-1]);
			printf("\n");
		}
		getchar();
		getchar();
		return 0;
	}




	6.编写一个程序打印一个表格，每一行打印一个整数，该数的平方，该数的立方；
	要求用户输入表格的上下限，使用for循环。
	
	#include<stdio.h>
	int main(void)
	{
		int first, last,n;
		printf("Check list\n");
		printf("Enter the number of list start form:\n");
		scanf_s("%d", &first);
		printf("And enter the number in the end:");
		scanf_s("%d", &last);
		for (n = first; n <= last; n++)
		{
			printf("n=%d;	n*n=%d;	n*n*n=%d\n",n,n*n,n*n*n);
		}
		getchar();
		return 0;
	}

	
	7.编写一个程序把一个单词读入一个字符数组中，然后倒序打印这个单词；
	提示：strlen()函数可用于计算数组最后一个字符的下标；

	#include<stdio.h>
	int main(void)
	{
		int n,i;
		char ch[40];
		scanf_s("%s", ch,40);	
		n = strlen(ch);
		for (i = n; i >= 0; i--)
			printf("%c", ch[i-1]);
		return 0;
	}



	8.编写一个程序，要求用户输入两个浮点数，并打印两数之差除以两数乘积的结果；
	在用户输入非数字之前，程序应循环处理用户输入的每对值；
	
	#include<stdio.h>
	int main(void)
	{
		float a, b,c;
		printf("Please enter two number,q to quit:\n");	
		while (scanf_s("%f", &a) == 1 && scanf_s("%f", &b) == 1)
		{
			c = (a - b) / (a*b);
			printf("%.2f", c);
		}
		return 0;
	}

	
	
	9.修改练习8，使用一个函数返回计算的结果；
	

	#include<stdio.h>
	float back(float x, float y);
	int main(void)
	{
		float a,b;
		printf("Please enter two number,q to quit:\n");
		while (scanf_s("%f", &a) == 1 && scanf_s("%f", &b) == 1)
			printf("%.2f\n",back(a,b));		
		return 0;
	}
	float back(float x, float y)
	{
		float n;
		n = 1.0;
		n = (x - y) / (x*y);
		return n;
	}


	10.编写一个程序，要求用户输入一个上限整数和一个下限整数；
	程序计算从上限到下限范围内所有整数的平方和，并显示计算结果；
	程序循环执行，直到输入的上限数小于下限数为止；
	程序的运行示例如下：
	Enter lower and upper integer limits：5  9
	the sums of the spuares form 25 to 81 is 255
	Enter next set of limits: 3  25
	the sums of the spuares form 9 to 625 is 5520
	Enter next set of limits: 5  5
	Done
	
	#include<stdio.h>
	int main(void)
	{
		int low, up,n,sum=0;	
		printf("Enter lower and upper integer limits:");
		scanf_s("%d %d", &low, &up);	
		for (n = low; n <=up; n++)
		{
			for (n = low; n <= up; n++)
				sum = sum + n * n;
			printf("the sums of the spuares form %d to %d is %d\n", low*low, up*up, sum);
			printf("Enter next set of limits:");
			scanf_s("%d %d", &low, &up);
			n = low;
			sum = 0;
		}
		printf("Done");
		return 0;
	}

	11.编写一个程序，在数组中读入8个整数，然后按倒序打印这8个整数
	#include<stdio.h>
	int main(void)
	{
		int n, i,num[8];
		for(n=0;n<8;n++)
			scanf_s("%d", &num[n]);
		for (i = 7; i >=0; i--)
			printf("%d\n", num[i]);
		return 0;
	}
	


	12.思考下面两个无限序列：
	1.0+1.0/2.0+1.0/3.0+1.0/4.0+……
	1.0- 1.0/2.0+1.0/3.0- 1.0/4.0+……
	编写一个程序计算这两个无限序列的总和，直到到达某次数。
	提示：奇数个-1相乘为-1；偶数个-1相乘为1；让用户交互地输入指定次数
	当用户输入0或者负值时结束输入。
	查看运行100项；1000，10000项后的总和，是否发现每个序列都收敛于某值？

	#include<stdio.h>
	int main(void)
	{
		int i,j,limit,k=-1;
		float n=0,m=0;
		printf("Enter the number you look up:\n");
		scanf_s("%d", &limit, 1);
		while (limit > 0)
		{
			for (i = 1; i <= limit; i++)
			{
				n = n + (1.0 / i);
				//printf("%d	%.2f\n", i, n);
			}
			for (k = 1, j = 1; j <= limit; k = k * -1, j++)
			{
				m = m + (1.0 / j)*k;
				//printf("%d	%.2f\n", j, m);
			}
			printf("%.2f\n", n + m);
			scanf_s("%d", &limit, 1);
			i = 1;
			j = 1;
			n = 0;
			m = 0;
		}
		return 0;
	}
	


	13.编写一个程序，创建一个包含8个元素的int类型数组，分别把数组元素设置为2的前8次幂。
	使用for循环设置数组元素的值，使用do while循环显示数组元素的值。
	
	#include<stdio.h>
	int main(void)
	{
		int i,j, n[9];
		n[0] = 2;
		j = 1;
		for (i = 1; i <= 8; i++)			
			n[i] = n[i-1] * 2;		
		do
		{
			printf("%d\n", n[j-1]);
			j++;
		}
		while (j <= 8);
		return 0;
	}


	14.编写一个程序，创建两个包含8个元素的double类型数组，使用循环提示用户为第一个数组输入8个值。
	第二个数组元素的值设置为第一个数组对应元素的累积之和；
	最后使用循环显示两个数组的内容，第一个数组显示成一行，第二个数组显示在下一行，元素相对应；

	#include<stdio.h>
	int main(void)
	{
		double a[8], b[8],sum;
		int i, j,k;	
		sum = 0;
		printf("Please enter 8 numbers for the first digit group:\n");
	
		for (i = 0; i < 8; i++)//为第一个数组输入8个值；
		{
			printf("Enter the number (%d/8) is:",i+1);
			scanf_s("%lf", &a[i], 1);
			//printf("the number of %d/8 is:%.2f\n", i+1, a[i]);			
		}	
	
		for (j = 0; j < i; j++)//为第二个数组输入值；
		{
			sum = sum + a[j];
			b[j] = sum;
			//printf("b[%d]=%.2f\n",j, b[j]);
		}

		printf("the first digit group:	");
		for (k = 0; k < 8; k++)
			printf("%5.2f	", a[k]);
		printf("\nthe second digit groua:	");
		for (k = 0; k < 8; k++)
			printf("%5.2f	", b[k]);
		return 0;
	}



	15.编写一个程序，读取一行输入，然后把输入的内容倒序打印出来，可以把输入储存在char类型的数组中；
	假设每行字符不超过255.回忆下，根据%c，scanf_s()函数一次只能从输入中读取一个字符；
	而且在用户按下enter键时scanf()函数会生成一个换行字符(\n)

	#include<stdio.h>
	int main(void)
	{
		char ch[255];
		int i, n;	
		scanf_s("%s", &ch,255);//输入内容;
		n = strlen(ch)-1;
		for (i = n+1; i >= 0; i--)
			printf("%c", ch[i - 1]);
		return 0;
	}


	16.达芙妮以10%的单利息投入了100美元(每年投资获利=原始投资*10%)；
	迪尔德以5%的复合利息投资了100美元(利息是当前余额的5%，包含之前的利息)；
	编写一个程序，计算需要多少年迪尔德的投资额才会超过达芙妮，并显示那时两人的投资额。

	#include<stdio.h>
	int main(void)
	{
		int i;
		double sum1, sum2;
		sum1 = 100;
		sum2 = 100;
		for (i = 1; sum2 <= sum1; i++)
		{
			sum1 = 100+10*i;
			sum2 = sum2 * 1.05;
			//printf("%d	%.2f	%.2f\n",i, sum1, sum2);
		}
		printf("after %dyears,	Daphne:%.2f $;	Deirdre: %.2f $\n", i, sum1, sum2);
		return 0;
	}



	17.chuckie赢得了100万美元(税后)，他把奖金存入年利率8%的账户，在每年的最后一天，chuckie取出10万美元；
	编写一个程序，计算多少年后chuckie会取完账户的钱？

	#include<stdio.h>
	void main(void)
	{
		double sum1, sum2;
		int i;
		sum1 = 100;
		sum2 = 100;
		for (i = 1; sum2 >= 10; i++)
		{
			sum2 = sum2*1.08-10;
			printf("%d,%.2f\n", i, sum2);
		}	
		printf("after %d years,Chuckie has no money left.", i );
		return 0;
	}


	18.Rabnud博士加入了一个社交圈，起初他有5个朋友，他注意到他的朋友数量以下面方式增长
	第1周少了1个朋友，剩下的朋友数量翻倍；第2周少了2个朋友，剩下的朋友数量翻倍；
	计算并显示博士每周的朋友数量，该程序一直运行直到超过邓巴数(一个人社交圈稳定关系上限150)
	
	#include<stdio.h>
	void main(void)
	{
		int weeks,friends;
		friends = 5;
		for (weeks = 1; friends < 150; weeks++)
		{
			friends = (friends - weeks) * 2;
			printf("%d weeks,he has %d friends.\n", weeks, friends);
		}
		return 0;
	}






【第七章】C控制语句：分支和跳转

关键字：	if、else、swith、continue、break、case、default、goto
运算符：	&&、||、?:
函数：	getchar()、putchar()、ctype.h系列
如何使用 if 和 if else 语句，如何嵌套它们；
在更复杂的测试表达式中用逻辑运算组合关系表达式
C的条件运算符
switch语句
continue、break 和 goto 语句
ctype.h 头文件提供的字符分析函数系列



7.1	if 语句
	
	程序读取一列数据，每个数据都表示每日的最低温度(℃)，然后输出统计的总天数和最低温度在0℃以下的天数占比；
	程序中的循环通过scanf_s()读入温度值，while循环每迭代一次，就递增计数器增加天数；if语句负责判断0℃以下天数；

	示例程序：		//示例程序有问题会报错，无法计算百分比；
	#include<stdio.h>
	int main(void)
	{
		const int FREEZING = 0;
		float temperature;
		int cold = 0, all = 0;
		printf("Enter the list of daily low temperatures.\n");
		printf("Use Celsius,and q to quit.\n");
		while (scanf_s("%lf", &temperature,1) == 1)
		{
			all++;
			if (temperature < FREEZING)
				cold++;
		}	
		if (all != 0)
			printf("%d days total:%.1f%% were below freezing.\n", all,100.0*(float)cold/all);
		if (all == 0)
			printf("No date entered!\n");		
		return 0;
	}
		


	if语句被称为分支语句或选择语句，它相当于一个交叉点，程序要在两条分支中选择一条执行；
	if语句的通用形式如下：
		if(expression)
			statement

	如果对expression求值为真(非0)，则执行statement，否则就跳过，statement属性与while循环一样
	if与while区别是，如果满足条件的话，while可以测试和执行多次，if只能测试和执行一次；

	
7.2	if else 语句
	
	简单形式的if语句让程序选择执行一条语句，或者跳过这条语句，if else可以让程序在两条语句之间做选择；
	
		if(expression)
			statement1
		else
			statement2

7.21	字符输入输出：getchar()和putchar()

	getchar()函数不带任何参数，它从输入队列中返回下一个字符；例如

	ch=getchar();	效果等同于	scanf_s("%c",&ch);

	putchar()函数打印它的参数；
	
	putchar(ch);	效果等同于	printf("%c",ch);

	由于这些函数只处理字符，所以它们比通用的scanf_s()和printf()函数更快更简洁；且不需要转换说明
	这两个函数定义在stdio.h头文件中；

	#include<stdio.h>
	#define space ' '
	int main(void)
	{
		char ch;
		ch = getchar();
		while (ch != '\n')
		{
			if (ch == space)
				putchar(ch);
			else
				putchar(ch + 1);
			ch = getchar();
		}
		return 0;
	}


7.2.2	ctype.h系列的字符函数
	
	C有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型
	
	#include<stdio.h>
	#include<ctype.h>	//包含了sialpha()的函数原型
	int main(void)
	{
		char ch;
		while ((ch = getchar())!= '\n')
		{
			if (isalpha(ch))		// ch为纯字母；
				putchar(ch + 1);
			else
				putchar(ch);
		}
		putchar(ch);
		return 0;
	}
	
	


	ctype.h头文件中的字符测试函数：
	
	isalnum()		字母或数字
	isalpha()		字母
	isblank()		空白字符
	iscntrl()		控制字符
	isdigit()		数字
	isgraph()		除空格之外的任意可打印字符
	islower()		小写字母
	isprint()		可打印字符
	ispunct()		标点符号
	isspace()		空白字符(空格、换行符、换页符、回车符、垂直制表符、水平制表符或其他本地化指定)
	isupper()		大写字母
	isxdigit()		十六进制数字符
	wolower()		大写转小写
	toupper		小写转大写



7.2.3	多重选择 else if

	例如电力公司电费按照使用量的分段计费：
	首360kwh		$0.13230/kwh
	续108kwh		$0.15040/kwh
	续252kwh		$0.30025/kwh
	超720kwh		$0.34025/kwh
	写一个程序计算电费：
	
	#include<stdio.h>
	#define rate1 0.13230	//费率1
	#define rate2 0.15040	//费率2
	#define rate3 0.30025	//费率3
	#define rate4 0.34025	//费率4
	#define break1 360.0	//分界点1
	#define break2 468.0	//分界点2
	#define break3 720.0	//分界点3
	#define pay1 (rate1*break1)			//一段完全费用
	#define pay2 (pay1+rate2*(break2-break1))	//二段完全费用
	#define pay3 (pay1+pay2+rate3*(break3-break2))	//三段完全费用

	int main(void)
	{
		double kwh;	//总用量
		double bill;	//电费
		printf("Please enter the kwh used.\n");
		scanf_s("%f", &kwh);
		if (kwh <= break1)				//一段内计费；
			bill = pay1 * kwh;			
		else if (kwh <= break2)			//二段计费
			bill = pay1 + (rate2*(kwh - break1));
		else if (kwh <= break3)			//三段计费
			bill = pay2 + (rate3*(kwh - break2));
		else					//四段计费
			bill = pay3 + (rate4*(kwh - break3));
		printf("The charge for %.1f kwh is $ %1.2f.\n", kwh, bill);
		return 0;
	}
	


7.2.4	else与if配对

	测试下面两个程序的结果差异；

	#include<stdio.h>
	int main(void)
	{
		int number;
		scanf_s("%d", &number);
		if (number > 6)
		{
			if (number < 12)
				printf("you're close!\n");
		}
		else
			printf("sorry,you lose a turn!\n");
		return 0;
	}



	#include<stdio.h>
	int main(void)
	{
		int number;
		scanf_s("%d", &number);
		if (number > 6)
			if (number < 12)
				printf("you're close!\n");		
		else
			printf("sorry,you lose a turn!\n");
		return 0;
	}



	
	如果没有花括号，else与离它最近的if匹配；


7.2.5	多层嵌套的if语句

	设计一个程序，给定一个整数，显示所有能整除它的约数，如果没有约数，就报告该数是一个素数
	开发程序模型：
	
	提示用户输入数字
	当scanf()返回值为1
		分析该数并报告结果
		提示用户继续输入
	
	设计如何找出约数；最直接的方法：
	for(i=2;i<num;i++)
		if(num%i==0)
			printf("%d is divisible by %d.\n",num,i);
	循环检查2~num之间的所有数字，测试它们是否能被整除，但是会有点浪费时间；
	比如16，按照程序会输出 2*8	4*4	8*2；
	在得到4*4之后，又开始得到已经找到的约数(只是次序相反)；因此，循环不用到达num，只要到它的平方根就可以

	for(i=2;（i*i）<num;i++)
		if(num%i==0)
			printf("%d is divisible by %d and %d.\n",num,i,num/i);
	
	不使用平方根而用这样的测试条件，1因为整数乘法比求平方根快；2教材还没介绍到平方根函数(真实)

	然而还需要解决两个问题才能开始编程：
	1.如果待测试数是完整的平方数怎么办?
	如16，可以被4*4；解决方法：嵌套一个if语句比较i和num/i是否相等，如果是，程序只输出一个约数；
	
	for(i=2;（i*i）<num;i++)
		if(num%i==0)
			if(i*i!=num)
				printf("%d is divisible by %d and %d.\n",num,i,num/i);	
			else
				printf("%d is divisible by %d.\n",num,i);

	2.如何知道一个数字是素数？如果num是素数，程序流不会进入if语句
	解决办法：在外循环把一个变量设置为某个值1，然后在if语句中把该值重新设置为0；
	循环完成后，检查该变量是否是1，如果是说明没有进入if语句，该数字就是素数；
	这样的变量通常被称为标记(flag)

	一直以来，C都习惯用int作为标记类型，其实新增的_Bool类型更合适；
	另外头文件stdbool.h下bool类型可替代_Bool类型，用true和false分别替代1和0；

	
	#include<stdio.h>
	#include<stdbool.h>
	int main(void)
	{
		unsigned long num;	//待测试数
		unsigned long n;	//约数
		bool prime;	//素数标记

		printf("Please enter an integer for analysis.\n");
		printf("Enter q to quit.\n");

		while (scanf_s("%lu", &num,1) == 1)
		{
			for (n = 2,prime=true; (n*n) <= num; n++)
			{
				if (num%n == 0) 
				{
					if ((n*n)!=num )
						printf("%lu is divisible by %d and %d.\n", num, n, num / n);
					else
						printf("%lu is divisible by %d.\n", num, n);
					prime = false;		//该数不是素数
				}
			}
			if (prime)
				printf("%lu is prime.\n",num);
			printf("\nPlease enter another integer for analysis.\n");
			printf("Enter q to quit.\n");
		}
		printf("Byebye\n");
		return 0;
	}



	小结：if else
	一般注解：
	形式1：如果expression为真，执行statement部分；
	if(expression)
		statement
	
	形式2：如果expression为真，执行statement1部分，否则执行statement2部分
	if(expression)
		statement1
	else
		statement2

	形式3：如果expression1为真，执行statement1部分，如果expression2为真，执行statement2部分；
	否则执行statement3部分
	if(expression1)
		statement1
	else is(express2)
		statement2
	else
		statement3

	
7.3	逻辑运算符

	if和while语句通常使用关系表达式作为测试条件，有时候多个关系表达式组合起来会很有用
	例如：编写一个程序计算输入一行句子中除了单引号和双引号以外其他字符的数量：
	这种情况下可以使用逻辑运算符，并使用句点（.）标识句子的末尾

	
	#include<stdio.h>
	#define end '.'
	int main(void)
	{
		char ch;
		int m = 0;
		while ((ch=getchar()) != end)
		{
			if (ch != '"'&&ch != '\'')
				m = m + 1;
		}
		printf("There are %d non-quote characters.\n",m);
		return 0;
	}


	逻辑运算符
	&&	与
	||	或
	！	非

	exp1和exp2为两个简单的关系表达式，则
	1.当且仅当exp1和exp2两个都为真时，exp1 && exp2才为真
	2.如果exp1或者exp2为真，则exp1||exp2为真；
	3.如果exp1为假，则!exp为真；反之亦然；

	
7.3.1	备选拼写：iso646.h头文件

	&&	and
	||	or
	!	not

7.3.2	优先级
	！运算符优先级很高，比乘法运算符还高与递增运算符的优先级相同，只比圆括号的优先级低
	&&优先级比||高，两者优先级都比关系运算符低，比赋值运算符高；因此
	表达式：	a>b&&b>c||b>d
	相当于	(a>b)&&(b>c)||(b>d)
	
7.3.3	求值顺序

	除了两个运算符共享一个运算对象情况外，C通常不保证先对复杂表达式中哪部分求值，比如
	m=(5+3)*(9+6);可能是先求值5+3，也可能先计算9+6；

	C把先计算哪部分的决定权留给编译器的设计者，以便对特定系统优化设计；
	但是对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右；
	&&和||运算符都是序列点，所以程序从一个运算对象执行到下一个运算对象之前，所有副作用都会生效；
	C保证一旦发现某个元素让整个表达式无效，便立即停止求值；
	正是由于这些规定，才能写出这样结构的代码：
	while((c=getchar()) != ' ' && c !='\n')
	如上：读取字符直到遇到第一个空格或换行符，第一个式子把读取的值赋给c，后面表达式会用到c的值
	还如：
	if(number!=0&&12/number==2)
		printf("the number is 5 or 6.\n");
	如果number的值是0，那么第一个子表达式为假，且不再对关系表达式求值，这样避免了把0作为除数

	while(x++<10&&x+y<20)
	实际上，&&是一个序列点，保证了在对右侧表达式求值之前，已经递增了x


7.3.4	范围
	&&运算符可以用于测试范围，例如要测试是否在10~100范围内，可以这样写：
	if(range>=90&&range<=100)
		printf("good show.\n");

	而不能写成if(90<=range<=100)		
	//错误写法，语义错误，而不是语法错误；
	编译器不会捕捉这样的问题，会继续执行为 (90<=range)<=100;
	对子表达式90<=range求值，要么是真(1)，要么是假(0)，这两个值都小于100；
	所以不管range值是多少，此表达式都恒为真

	许多代码都用范围测试来确定一个字符是否是小写字母
	if(ch>='a'&&ch<='z')
	但仅对ASCII这样的字符编码有效，但对EBCDIC这样的代码就没用了，移植方法是用ctype.h
	if(islower(ch))

	
7.4	一个统计单词的程序
	编写一个程序读取并报告单词的数量，该程序还可以计算字符和行数；伪代码
	①	读取一个字符
	②	当有更多输入时
	③		递增字符计数
	④		如果读完一个单词，递增单词计数
	⑤		如果读完一行，递增行数计数
	⑥		读取下一个字符
	
	②输入循环模型
	while((ch=getchar())!=stop){…}	这里stop标识输入末尾，可暂时选择文本中不常用字符比如(|)标记
	⑤统计行数：检查换行字符
	④最棘手部分，首先程序需要定义什么是该程序识别的单词；
		用相对简单的方法，把一个单词定义为一个不含空白(没有空格、制表符、换行符)的字符序列
		因此程序读取的第一个非空白字符就是单词的头，到空白字符时候结束；
	判断非空白字符表达式：	c != ' ' && c !='\n' && c != '\t'
	检测空白字符表达式：	c==' ' || c == '\n' || c == 't'
	然而使用ctype.h头文件函数issoace()更简单；isspace(c)为真是空白字符，非空白字符时候!isspace(c)为真
	
	要查找一个单词里是否有某个字符，可以在程序中输入单词的首字符时把一个标记(inword)设置为1，
	可以在此时递增单词计数，然后只要inword为1后续的非空白字符都不记为单词的开始，
	直到下一个空白字符，必须重置标记为0，然后程序准备好读取下一个单词；伪代码：
		如果c不是空白字符，且inword为假
			设置inword为真，并给单词计数
		如果c是空白字符，且inword为真
			设置inword为假

	如果使用布尔类型（_Bool）的变量，通常习惯把变量自身作为测试条件
	用if(inword)代替if(inword==true)
	用if(!inword)代替if(inword==false)
	

	完整代码：
	#include<stdio.h>
	#include<ctype.h>	//为isspace()函数提供原型
	#include<stdbool.h>	//为bool、true、false提供定义
	#define stop '|'	//结束标记符
	int main(vodi)
	{
		char c;				//读入字符
		char prev;			//读入的前一个字符
		int n=0;				//字符数
		int m=0;				//单词数
		int l=0;				//行数
		int pline = 0;			//不完整的行数
		bool inword = false;	//单词标记
		printf("Enter text to be analyzed(| to terminate):\n");
		prev = '\n';//用于识别完整的行
		while ((c = getchar()) != stop)
		{
			n++;//统计字符
			if (c == '\n')
				l++;	//统计行数
			if (!isspace && !inword)
			{
				inword = true;
				m++;	//统计单词数
			}
			if (isspace && inword)
				inword = false;
			prev = c;	//保存字符的值
		}
		if (prev != '\n')
			pline = 1;
		printf("characters=%d,words=%d,lines=%d.\n", n, m, l);
		printf("partial lines=%d.\n", pline);
		return 0;
	}


7.5	条件运算符 ?:

	条件表达式作为if else语句的一种便捷方式，如：
	
	x=(y<0)?-y:y;

	在=和；之间的内容就是条件表达式，该语句的意思是：
	如果y<0，那么x=-y;否则x=y
	
	用if else表达式为：
	
	if(y<0)
		x=-y;
	else
		x=y;


	条件表达式的通用形式如下：
	expression1？expression2：expression3

	如果exp1为真，那么整个表达式的值与exp2的值相同；
	如果exp1为假，那么整个表达式的值与exp3的值相同；

	需要把两个值中的一个赋给变量是，就可以用条件表达式，
	典型的例子是，把两个值中最大值赋给变量：
	
	max=(a>b)?a:b;

	通常条件运算符完成的任务if else也能完成，但是条件运算符代码更简洁紧凑

	示例程序：该程序计算刷给定面积需要多少罐油漆
	基本算法：用总面积除以每罐油漆能刷的面积，但是商店只卖整罐油漆，不会拆分来卖
	所以如果计算结果是1.7，就需要2罐，
	因此，该程序得到带小数的结果时应该进1
	条件运算符常用于这种情况，而且根据单复数分别打印can和cans

	#include<stdio.h>
	#define cover 350	//每罐可刷面积
	int main(void)
	{
		int sq;
		int cans;

		printf("Enter number of square feet to be painted:\n");
		while (scanf_s("%d", &sq) == 1)
		{
			cans = sq / cover;
			cans = cans + ((sq%cover == 0) ? 0 : 1);
			printf("you need %d %s of paint.\n", cans, cans == 1 ? "can" : "cans");
			printf("Enter next square (q to quit):\n");
		}
		return 0;
	}



7.6	循环辅助：continue和break

	一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中所有的语句
	continue和break语句可以根据循环中的测试结果来忽略一部分循环内容，甚至结束循环


7.6.1	continue语句

	3种循环都可以使用continue语句
	执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。
	如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环；
	示例：

	#include<stdio.h>
	int main(void)
	{
		const float MIN = 0.0f;	//最低分边界点
		const float MAX = 100.0f;	//最高分边界点

		float score;		//得分
		float total = 0.0f;		//总分
		int n = 0;			//计数器
		float min = MAX;		//最低分
		float max = MIN;		//最高分

		printf("Enter the first score(q to quit):\n");
		while (scanf_s("%f", &score) == 1)		//输入成绩float类型；非匹配数据退出；
		{
			if (score<MIN || score>MAX)		//输入得分在边界范围外；无效数；
			{
				printf("%0.1f is an invalid value.try again:", score);
				continue;//跳转至while循环的测试条件
			}
			printf("Accepting %0.1f:\n", score);	//显示本次接收数据
			min = (score < min) ? score : min;	//刷新最低分
			max = (score > max) ? score : max;	//刷新最高分	
			total += score;			//计算总得分；用来计算平均分
			n++;				//计数器累计
			printf("Enter next score(q to quit):\n");
			if (n > 0)				//有效记分时输出成绩：
			{
				printf("average of %d score is %0.1f.\n", n, total / n);
				printf("Low=%0.1f,high=%0.1f.\n", min, max);
			}
			else
				printf("No valid score were entered.\n");
		}
		return 0;
	}
	
		
	

	continue部分：筛选出无效的分数，让程序跳过处理有效输入部分的代码，对无效输入不做处理；
	continue该情况下替代了原来的方法：
	①
	if(score<0||score>100)
		{……}
	else
	{……}
	
	②
	if(score>=0&&score<=100){……}
	
	这种情况下，使用continue的好处是减少主语句组中的一级缩进，当语句很长或嵌套多的时候紧凑简洁
	continue还可以用作占位符；如下面的循环读取并丢弃输入的数据，直到读到行末尾：
	while(getchar()!='\n')
		;
	当程序已经读取一行中的某些内容，要跳到下一行开始处时，这种用法很方便，问题是一般很难注意到一个单独分号
	如果使用continue，可读性会更高：
	
	while(getchar()!='\n')
		continue;

	相反的如果用了continue没有简化代码反而更复杂，就不要使用；例如：
	
	while((ch=getchar())!='\n')
	{
		if(ch=='\t')
			continue;
		putchar();
	}
	该循环跳过制表符，并在读到换行符时退出循环，此时不用continue
	更简洁的方法是把if条件反过来使用即可：
	
	while((ch=getchar())!='\n')
	{
		if(ch!='\t')
			putchar();
	}

	
	


7.6.2	break语句
	程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段

	#include<stdio.h>
	int main(void)
	{
		float length, width;
		printf("Enter the length of the rectangle:\n");
		while (scanf_s("%f", &length, 1) == 1)
		{
			printf("length=%0.2f:\n",length);
			printf("Enter its width:\n");
			if (scanf_s("%f", &width, 1) != 1)
				break;
			printf("width =%0.2f:\n",width);
			printf("area=%0.2f:\n", length*width);
			printf("Enter the length of the rectangle:\n");
		}
		printf("Done.\n");
		return 0;
	}


	在for循环中的break，在执行完break语句后会直接执行循环后面的第一条语句，连更新部分也跳过
	嵌套在内层的break只会跳出包含它的当前循环，要跳出外层循环还需要一个break

	
	
	
7.7	多重选择：switch和break
	
	使用条件运算符和if else语句很容易编写二选一的程序
	然而程序有时候需要在多个选项中进行选择，可以用if else if……else来完成
	但是使用switch语句就可以更方便的解决这个问题
	示例：该程序读入一个字母，然后打印出与该字母开头的动物名

	
	#include<stdio.h>
	#include<ctype.h>
	int main(void)
	{
		char ch;
		printf("Give me a letter of the alphabet,and i'll give an animal name beginning with that letter.\n");
		printf("Please type in a letter;type # to end my ect.\n");
		while ((ch = getchar()) != '#')
		{
			if ('\n' == ch)
				continue;
			if (islower(ch))
				switch (ch)
				{
				case 'a':
					printf("argali,a wild sheep of Asia.\n");
					break;
				case 'b':
					printf("babirusa,a wild pig of Malay.\n");
					break;
				case 'c':
					printf("coati,racoon like mammal.\n");
					break;
				default:
					printf("that's a stumper!\n");
				}
			else
				printf("I recognize only lowercase letters.\n");
			while (getchar() != '\n')	//跳过输入行的其余部分只读取首字母
				continue;
			printf("Please type another letter or a #.\n");
		
		}
		printf("bye!\n");
		return 0;
	}



7.7.1	switch语句

	按照示例分析switch工作原理：
	对紧跟在关键字switch后圆括号中的表达式求值（ch）
	然后程序扫描标签（case 'a':等等）列表，直到发现一个匹配值为止，程序转至那一行
	如果没有匹配的标签怎么办？如果有default标签行，就转到该行，没有就继续执行switch后面的语句。
	break语句在其中起什么作用？
	它让程序离开switch语句，跳到switch语句后面的下一条语句。
	如果没有break语句，就会从匹配标签开始执行到switch末尾。（即从匹配标签开始把后续标签都执行一遍）
	
	break语句可用于循环和switch语句中，但是continue只能用于循环中；
	尽管如此，如果switch语句在一个循环中，continue便可以作为switch语句的一部分；
	这种情况下就像其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分

	一般C语言的case一般都指定一个值，不能使用一个范围
	switch在圆括号中的测试表达式的值应该是一个整数值，包括char类型；
	case标签必须是整数类型(包括char类型)的常量或整形常量表达式，不能用变量作为case标签

	switch构造如下：
	
	switch(整形表达式)
	{
		case 常量1：
			语句
		case 常量2：
			语句
		default：
			语句
	}


7.7.3	多重标签

	
	switch(ch)
	{
		case 'a':
		case 'A':
			a++;
			break;
		case 'b':
		case 'B':
			b++;
			break;
		default:
			break;
	}
	

	假设ch是字母b，switch语句会转到标签为case 'b'的位置；
	由于该标签没有关联break语句，所以程序流直接执行下一条语句，即b++;
	如果ch字母是B，程序流直接定位到case'B',
	本质上两个标签指的都是相同的语句。
	
	严格地说，case 'B'语句下的break并不重要，因为即使删除这条break程序流会接着执行default：break；
	但是从习惯上建议保留这条break，方便以后再添加新的case，防止遗漏break；

	在该例中，如果使用ctype.h系列的toupper()函数就可以避免使用多重标签，在测试前把字母转换成大写
	如：
	ch=toupper(ch);
	或者
	
	switch(toupper(ch));

	
7.7.4	switch和 if else

	如果是浮点类型的变量或表达式来进行选择，就无法使用switch
	如果根据变量在某范围内决定程序流的去向，switch也很麻烦，这种时候用if更方便
	
	
7.8	goto 语句

	goto语句有两部分：goto和标签名
	标签的命名遵循变量命名规则，如：
	goto part2；
	要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该语句标签名后紧跟一个冒号开始
	part2：printf("done.\n");

7.8.1	避免使用goto
	原则上，根本不用在C程序中使用goto语句	




7.9	关键概念
	if  、if else和switch，以及条件运算符(?:)实现智能选择；
	if、if else语句使用测试条件来判断执行哪些语句。所有非零值都被视为true，零视为false
	测试通常涉及关系表达式(比较两个值)、逻辑表达式(用逻辑运算符或更改其他表达式)
	通用原则：如果要测试两个条件，应该用逻辑运算符把两个完整的测试表达式组合起来

	
7.11	复习题
	
	1.判断下列表达式是true还是false
	①100>3&&'a'>'c'	//false
	②100>3||'a'>'c'	//true
	③!(100>3)		//false
	
	2.根据下列描述的条件，分别构造一个表达式：
	①number等于或大于90，但是小于100
	number>=90&&number<100;
	
	②ch不是字符q或k
	ch!='q'&&ch!='k';
	
	③number 在1~9之间(包括1、9)，但不是5
	（number>=1&&number<=9）&&number!=5;

	④number不在1~9之间
	number<1||number>9;

	3.下面的程序关系表达式过于复杂，而且还有些错误，请简化并改正

	
	#include<stdio.h>
	int main(void)
	{
		int weight, height;//weight以磅为单位 height以英寸为单位
		scanf_s("%d%d", &weight, &height);
		if (weight < 100 && height>64)
		{
			if (height >= 72)
				printf("You are very tall for your weight.\n");
			else
				printf("You are tall for your weight.\n");
		}
		else if (weight > 100 && height < 48)
			printf("You are quite short for your weight.\n");
		else
			printf("Your weight is ideal.\n");		
		return 0;
	}



	4.下列各表达式的值是多少？
	①5>2			//1
	②3+4>2&&3<2		//0
	③x>=y||y>x		//1
	④d=5+(6>2)		//d=6
	⑤'x'>'T'?10:5		//10
	⑥x>y?y>x:x>y		//0


	5.下面的程序将打印什么？
	
	#include<stdio.h>
	int main(void)
	{
		int num;
		for (num = 1; num <= 11; num++)
		{
			if (num % 3 == 0)
				putchar('$');
			else
				putchar('*');
			putchar('#');
			putchar('%');
		}
		putchar('\n');
		return 0;
	}
		
	//当num从1-11；每次输出*#%，当num=3/6/9的时候把*换成$,最后回车
	*#%*#%$#%*#%*#%$#%*#%*#%$#%*#%*#%[\n]

	

	6.下面的程序将打印什么

	#include<stdio.h>
	int main(void)
	{
		int i = 0;
		while (i < 3)
		{
			switch (i++) 
			{
			case 0:printf("fat ");
			case 1:printf("hat ");
			case 2:printf("cat ");
			default:printf("Oh no!");
			}
			putchar('\n');
		}
		return 0;
	}

	//	i=0;switch(0);输出：fat hat cat Oh no![\n]
	//	i=1;swithc(1);输出：hat cat Oh no![\n]
	//	i=2;swithc(2);输出：cat Oh no![\n]
	//	i=3.不进入while循环；return0；

	7.下面的程序有哪些错误？

	#include<stdio.h>
	int main(void)
	{
		char ch;
		int lc = 0;//统计小写字母
		int uc = 0;//统计大写字母
		int oc = 0;//统计其他字母

		while ((ch = getchar()) != '#')
		{
			if (ch <= 'z'&&ch >= 'a')
				lc++;
			else if (ch <= 'Z'&&ch >= 'A')
				uc++;
			else
				oc++;
		}
		printf("%d lowercase,%d uppercase,%d other.\n", lc, uc, oc+1);
		return 0;
	}


	8.下面程序将输出什么？
	#include<stdio.h>
	int main(void)
	{
		int age = 20;
		while (age++ <= 65)
		{
			if ((age % 20) == 0)
				printf("You are %d.Here is a raise.\n", age);
			if (age = 65)					//***
				printf("You are %d.Here is your gold watch.\n", age);
		}
		return 0;
	}

	//=不是==；当age=20测试完成，age=21，age在第二个if被赋值成65，进入下一个循环后一直被重置；
	输出：重复输出65那一句；



	9.给定下面的输入时，以下程序将打印什么？

	q
	c
	h
	b
	
	#include<stdio.h>
	int main(void)
	{
		char ch;
		while ((ch = getchar()) != '#')
		{
			if (ch == '\n')
				continue;
			printf("Step 1\n");
			if (ch == 'c')
				continue;
			else if (ch == 'b')
				break;
			else if (ch == 'h')
				goto laststep;
			printf("Step 2\n");
		laststep:printf("Step 3\n");
		}
		printf("Done!\n");
		return 0;
	}


	//q:	Step 1[\n]Step 2[\n]Step 3[\n]
	//c:	Step 1[\n]
	//h:	Step 1[\n]Step 3[\n]
	//b:	Step 1[\n]Done![\n]

	10.重写练习题9，不使用continue和goto语句

	#include<stdio.h>
	int main(void)
	{
		char ch;

		while ((ch = getchar()) != '#')
		{
			if (ch != '\n')
			{
				printf("Step 1\n");
				if (ch == 'b')
					break;
				switch (ch)
				{			
				default:printf("Step 2\n");
				case 'h':printf("Step 3\n");
				case 'c':;			
				}			
				ch = getchar();				
			}
			else
				ch = getchar();
		}
		printf("Done!\n");
		return 0;
	}




7.12	编程练习

	1.编写一个程序读取输入，读到#字符停止，然后报告读取的空格数、换行符数和其他字符的数量

	#include<stdio.h>
	int main(void)
	{
		char ch;
		int k=0;//空格数量
		int h=0;//换行符数量
		int q=0;//其他字符数量

		while ((ch = getchar()) != '#')
		{
			if (ch == ' ')
				k++;
			else if (ch == '\t')
				h++;
			else
				q++;	
		}
		printf("%d space,%d tab,%d other.\n", k, h, q+1);
		return 0;
	}


	2.编写一个程序读取输入，读到#字符停止。程序要打印每个输入的字符以及对应的ASCII编码
	一行打印8个字符，建议使用字符计数和求模运算符%在每8个循环周期时打印一个换行符
	
	//此程序无法包含回车[\n]

	#include<stdio.h>
	int main(void)
	{
		int n=0;//计数器；
		char ch;
		while ((ch = getchar()) != '#')
		{		
			if (ch == '\n')
				continue;
			if (n % 8 == 0)
				printf("\n");		
			printf("%c-%d	", ch, ch);
			n++;
		}
		return 0;
	}
		
	

	3.编写一个程序，读取整数直到用户输入0，输入结束后，程序应报告用户输入的偶数(不含0)个数；
	以及这些偶数的平均值、输入的奇数及其奇数的平均值.

	#include<stdio.h>
	#include<ctype.h>
	int main(void)
	{
		int num;
		int n=0, m=0;
		float tn=0,tm=0;
		while ((scanf_s("%d", &num) == 1) && num != 0)
		{
			if (num % 2 == 0)
			{
				tn = tn + num;
				n++;
			}
			if (num % 2 != 0)
			{
				tm = tm + num;
				m++;
			}
		}
		printf("odd number=%d,average=%.2f.\n",m,tm/m);
		printf("even number=%d,average=%.2f.\n",n,tn/n);
		return 0;
	}




	
	

	4.使用if else语句编写一个程序读取输入，读到#时停止，用感叹号替换句号，用两个感叹号替换原来的感叹号
	最后报告进行了多少次替换

	#include<stdio.h>
	int main(void)
	{
		char ch;
		int n=0;
		while ((ch=getchar())!='#')
		{			
			if (ch == '.')
			{
				ch = '!';
				printf("%c", ch);
				n++;
			}
			else if (ch == '!')
			{				
				printf("%c%c", ch, ch);
				n++;
			}
			else
				printf("%c", ch);		
		}
		printf("\n%d\n", n);
		return 0;
	}


	


	5.使用switch重写练习4
	
	#include<stdio.h>
	int main(void)
	{		
		char ch;
		int n = 0;
		while ((ch=getchar())!='#')
		{			
			switch (ch)
			{
			case '.':ch = '!'; printf("%c", ch); n++; continue;
			case '!':printf("%c%c", ch, ch); n++; continue;
			default:printf("%c", ch);
			}
		}
		printf("\n%d\n", n);
		return 0;
	}





	6.编写程序读取输入，读到#停止，报告ei出现的次数。

	#include<stdio.h>
	int main(void)
	{
		char ch;
		int n, m;
		n = 0;
		while ((ch = getchar()) != '#')
		{
			if (ch == 'e')
			{
				m = 1;
				printf("%c", ch);
				ch = getchar();			
				if (ch == 'i')
				{
					printf("%c", ch);
					n++;
					m = 0;
				}
				else
					printf("%c", ch);
			}
			else
				printf("%c", ch);
		}
		printf("%d", n);
		return 0;
	}



	
	7.编写一个程序，提示用户输入一周工作的小时数，然后打印工资总额、税金和净收入；假设：
	a.基本工资=1000美元/小时
	b.加班(超过40小时)=1.5倍时间
	c.税率：	前300美元为15%
		续150美元为20%
		余下的为25%
	用#define定义符号常量

	#include<stdio.h>
	#define wage 1000	//小时工资
	#define overwork 40	//加班时间界限点
	#define multiple 1.5
	#define rate1 0.15	//税率1
	#define rate2 0.2	//税率2
	#define rate3 0.25	//税率3
	#define tax1 300	//税点1
	#define tax2 450	//税点2
	#define pay1 tax1*rate1	//一段全额纳税额
	#define pay2 pay1+(tax2-tax1)*rate2	//二段全额纳税额
	int main(void)
	{
		float wages, tax,income;//总工资、那税金、净收入
		float hour,time;//工作小时数、结算工时
		printf("Please enter your work time per week:\n");
		scanf_s("%f", &hour);
		if (hour > overwork)
			time = (hour - overwork)*multiple + overwork;
		else
			time = hour;
		wages = wage * time;
		if (wages <= tax1)
			tax = wages * rate1;
		else if (wages <= tax2)
			tax = pay1 + (wages - tax1)*rate2;
		else
			tax = pay2 + (wages - tax2)*rate3;
		income = wages - tax;
		printf("your wages:%.2f.\nyour tax:%.2f.\nyour income:%.2f.\n",
			wages, tax, income);
		return 0;
	}




	8.修改练习7的假设a，让程序可以给出一个供选择的工资等级菜单，使用switch完成工资等级选择
	运行程序后，显示的菜单应该类似这样：
	**************************************************************************
	Enter the number corresponding to the desired pay rate or action:
	1)$8.75/hr		2)$9.33/hr
	3)$10.00/hr	4)$11.20/hr
	5)quit
	**************************************************************************
	如果选择1-4，程序应该询问用户工作的小时数，成需要循环运行，直到输入5
	如果输入1-5以外的数，程序应提醒用户输入正确的选项，然后再重复提示菜单
	使用#define 创建符号常量表示各工资等级和税率。

	#include<stdio.h>
	#define overwork 40	//加班时间界限点
	#define multiple 1.5
	#define rate1 0.15	//税率1
	#define rate2 0.2	//税率2
	#define rate3 0.25	//税率3
	#define tax1 300	//税点1
	#define tax2 450	//税点2
	#define pay1 tax1*rate1	//一段全额纳税额
	#define pay2 pay1+(tax2-tax1)*rate2	//二段全额纳税额
	int main(void)
	{
		double wage,wages, tax, income;//小时工资、总工资、那税金、净收入
		double hour, time;//工作小时数、结算工时
		int n;//工资档次选择数
		printf("*****************************************************************\n");
		printf("Enter the number corresponding to the desired pay rate or action:\n");
		printf("1) $8.75/hr	2) $9.33/hr\n3) $10.00/hr	4) $11.20/hr\n5)quit\n");
		printf("*****************************************************************\n");	
		while (scanf_s("%d", &n) == 1)
		{
			switch (n)
			{
			case 1:wage = 8.75;break;
			case 2:wage = 9.33;break;
			case 3:wage = 10.00;break;
			case 4:wage = 11.20;break;
			case 5:return 0;
			default:printf("Please enter the right number.\n");
				printf("*****************************************************************\n");
				printf("Enter the number corresponding to the desired pay rate or action:\n");
				printf("1) $8.75/hr	2) $9.33/hr\n3) $10.00/hr	4) $11.20/hr\n5)quit\n");
				printf("*****************************************************************\n");
				continue;		
			}
			printf("Please enter your work time per week:\n");
			scanf_s("%lf", &hour);
			if (hour > overwork)
				time = (hour - overwork)*multiple + overwork;
			else
				time = hour;
			wages = wage * time;
			if (wages <= tax1)
				tax = wages * rate1;
			else if (wages <= tax2)
				tax = pay1 + (wages - tax1)*rate2;
			else
				tax = pay2 + (wages - tax2)*rate3;
			income = wages - tax;
			printf("your wages:%.2f.\nyour tax:%.2f.\nyour income:%.2f.\n\n\n",
				wages, tax, income);
			printf("*****************************************************************\n");
			printf("Enter the number corresponding to the desired pay rate or action:\n");
			printf("1) $8.75/hr	2) $9.33/hr\n3) $10.00/hr	4) $11.20/hr\n5)quit\n");
			printf("*****************************************************************\n");
			continue;
		}	
		return 0;
	}







	9.编写一个程序，只接受正整数输入，然后显示所有小于或等于该数的素数
	#include<stdio.h>
	int main(void)
	{
		int n,m,i,k;
		while (scanf_s("%d", &n) == 1)
		{
			if (n <= 0)
				break;
			for (m = n; m > 0; m--)
			{
				for (i = 2, k = 1; i*i <= m; i++)
				{
					if (m%i == 0)
						k = 0;				
				}
				if (k)
					printf("%d\n", m);
			}
		}
		return 0;
	}




	10.1988年的美国联邦税收计划是近代最简单的税收方案，分为4各类别每个类别2各等级
	计划摘要如下：
	类型		税金
	单身		17850美元15%，超出部分28%
	户主		23900美元15%，超出部分28%
	已婚		29750美元15%，超出部分28%
	离异		14875美元15%，超出部分28%

	例如让一位工资20000美元的单身纳税人，应纳税0.15*17850+0.28*(20000-17850）美元
	编写一个程序让用户指定纳税金种类和应纳税收入，然后计算税金；程序可循环执行；

	
	#include<stdio.h>
	#define single 17850
	#define household 23900
	#define married 29750
	#define divorced 14875
	#define rate1 0.15
	#define rate2 0.28
	int main(void)
	{
		double income, tax;
		int n,m;
		printf("Please enter the right number of your tape:\n");
		printf("1.single	2.household\n3.married	4.divorced\n5.quit\n");
		while ((scanf_s("%d", &n)) == 1)
		{
			switch (n)
			{
			case 1:m = 17850;
				break;
			case 2:m = 23900;
				break;
			case 3:m = 29750;
				break;
			case 4:m = 14875;
				break;
			case 5:return 0;
			default:printf("Please choice the right number:\n");
				printf("1.single	2.household\n3.married	4.divorced\n5.quit\n");
				continue;
			}
			printf("Please enter your taxable income:\n");
			scanf_s("%lf", &income);
			if (income <= m)
				tax = income * rate1;
			else
				tax = m * rate1 + (income - m)*rate2;
			printf("your tax is %.2f\n\n", tax);
			printf("Please enter the right number of your tape:\n");
			printf("1.single	2.household\n3.married	4.divorced\n5.quit\n");
		}
		return 0;
	}



	11.ABC邮购杂货店出售的洋蓟售价为2.05美元/磅；甜菜价格为1.15美元/磅，胡萝卜售价为1.09美元/磅
	在添加运费之前，100美元的订单有5%的打折优惠；少于或等于5磅的订单收取6.5美元的运费和包装费
	5磅~20磅的订单收取14美元的运费和包装费，超过20磅的订单在14美元基础上再续重1磅增加0.5美元；
	编写一个程序，在循环中使用switch语句实现用户输入不同字母时有不同响应；
	输入a的响应是让用户输入洋蓟的磅数，b是甜菜，c是胡萝卜，q是退出订购
	程序要记录累计的重量，即，如果用户输入4磅的甜菜，然后输入5磅的甜菜，程序应报告9磅的甜菜；
	然后程序要计算货物总价、折扣(如果有的话)、运费和包装费；
	随后程序应显示所有的购买信息：物品售价、订购的重量、订购的蔬菜费用、订单的总费用、折扣、
	运费和包装费，以及所有的费用总额。

#include<stdio.h>
#define dispoint 0.05
int main(void)
{
	int n, k;//选择菜单项;标记
	double p;//单价
	double m, mA, mB, mC;//磅数
	double paya, payb, payc, payA, payB, payC, payall;//付款
	double pound, discont, freight, total;//总重量;折扣;运费;总额
	mA = 0;
	mB = 0;
	mC = 0;
	payA = 0;
	payB = 0;
	payC = 0;
	printf("Here is shopping menu:\n");
	printf("Please enter the number of the vagetable which you wangt:\n\n");
	printf("********************************\n");
	printf("vagetable	price/pound\n");
	printf("1.artichoke	$2.05\n2.beet		$1.15\n3.carrot	$1.09\n");
	printf("(Enter q to quit.)\n");
	printf("********************************\n");
	while (scanf_s("%d", &n) == 1)
	{
		switch (n)
		{
		case 1:p = 2.05; k = 1; break;
		case 2:p = 1.15; k = 2; break;
		case 3:p = 1.09; k = 3; break;
		default:printf("Please enter right number.\n");
			continue;
		}
		printf("Please enter the pound you wangt it.\n");
		scanf_s("%lf", &m);
		switch (k)
		{
		case 1:paya = p * m; payA = paya + payA; mA = mA + m; break;
		case 2:payb = p * m; payB = payb + payB; mB = mB + m; break;
		case 3:payc = p * m; payC = payc + payC; mC = mC + m; break;
		}
		printf("do you want more?(q to quit menu):\n");
		printf("********************************\n");
		printf("1.artichoke	$2.05\n2.beet		$1.15\n3.carrot	$1.09\n");
		printf("********************************\n");
	}
	payall = payA + payB + payC;
	pound = mA + mB + mC;
	if (payall > 0)
	{
		printf("\n\nTotle list:\n");
		printf("vagetable		price			pound			cost\n");

		if (mA > 0)
			printf("artichoke		$2.05		%13.2f		%12.2f\n", mA, payA);
		if (mB > 0)
			printf("artichoke		$1.15		%13.2f		%12.2f\n", mB, payB);
		if (mC > 0)
			printf("artichoke		$1.09		%13.2f		%12.2f\n", mC, payC);
		printf("\nTotal consumption of this order:		$%10.2f\n", payall);
		if (pound <= 5)
			freight = 6.5;
		else if (pound <= 20)
			freight = 14;
		else
			freight = 14 + (pound - 20)*0.5;
		if (payall > 100)
		{
			discont = payall * dispoint;
			total = payall - discont + freight;
			printf("your discont:					$-%9.2f\n", discont);
		}
		else
			total = payall + freight;
		printf("You need to pay for freight/packing:		$%10.2f\n", freight);
		printf("The tatal cost of this shopping:		$%10.2f\n", total);
	}
	printf("Wellcome to come again next time.\n");
	return 0;
}











【第八章】	字符输入/输出和输入验证

	I/O函数：输入输入函数(input\output);
	缓冲输入和无缓冲输入
	键盘模拟文件结尾条件
	重定向把程序和文件连接
	创建更友好的用户界面

	
	
8.1	单字符I/O: getchar()和putchar()

	#include<stdio.h>
	int main(void)
	{
		char ch;
		while((ch=getchar())!='#')
			putchar(ch);
		return 0;
	}


	自从ANSIC标准发布后，C就把stdio.h头文件与使用getchar()和putchar()相关联
	其实getchar()和putchar()都不是真正的函数，它们被定义为供预处理使用的宏
	

8.2	缓冲区
	回显用户输入的字符后立即重复打印该字符是属于无缓冲输入，即正在等待的程序可以立即使用输入的字符
	对于该例，大部分系统在用户按下enter键之前不会重复打印刚输入的字符，这种输入属于缓冲输入
	用户输入的字符被收集并存储在一个缓冲区的临时存储区，按下回车后，程序才可以使用用户输入的字符

	为什么要有缓冲区？
	1.把若干个字符作为一个块进行传输比逐个发送这些字符节约时间
	2.如果用户输入错误，可以直接通过键盘修正错误，确保回车后输入的是正确值

	虽然缓冲输入有很多好处，但某些交互式程序也需要无缓冲输入，比如游戏中按下一个键就执行相应的指令
	
	缓冲分为两类：完全缓冲I/O 和 行缓冲I/O
	
	完全缓冲：当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)，通常出现在文件输入中；
		缓冲区的大小取决于系统，常见大小是512字节和4096字节
	行缓冲：	指的是出现换行符时刷新缓冲区，键盘输入通常是行缓冲输入，按下回车后刷新缓冲区

8.3	结束键盘输入
	在示例程序中，只要输入的字符中不含#，那么程序在读到#时候才会结束
	但是#也是个普通字符，有时候不可避免要用到，应该用一个在文本中用不到的字符来标记输入完成
	这样的字符不会无意间出现在输入中，在你不希望结束程序的时候终止程序
	
8.3.1	文件、流和键盘输入
	文件(file)是存储器中储存信息的区域
	通常文件都保存在永久存储器中，某些程序需要访问指定的文件，有些程序不仅要打开读取和关闭文件，
	有时还要把数据写入文件
	C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数，称为底层I/O
	由于计算机系统各不相同，所以不可能为普通的底层I/O创建标准库
	//当然较高层面上，C可以通过标准I/O包来处理文件
	从概念上看，C程序处理的是流而不是直接处理文件
	流(stream)是一个实际输入或输出映射的理想化数据，这意味着不同属性和不同种类的输入，
	由属性更统一的流来表示
	于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成
	
	
	C把输入和输出设备视为存储设备上的普通文件
	尤其是把键盘和显示设备视为每个C程序自动打开的文件
	stdin流表示键盘输入，stdout流表示屏幕输出
	getchar()\putchar()\printf()和scanf()都是标准I/O包的成员，处理这两个流

	所以可以用处理文件的方式来处理键盘输入
	例如程序读取文件时要检测文件的末尾才知道应在何处停止
	因此C的输入函数内置了文件结尾检测器
	既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入
	下面我们从文件开始，学习如何结束文件


8.3.2	文件结尾

	计算机操作系统要以某种方式判断文件的开始和结束
	检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾
	CP/M IBM-DOS MS-DOS的文本文件曾经使用过这种方法
	如今这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾
	这曾经是操作系统使用的唯一标记，不过现在有一些其他选择，比如记录文件的大小
	所以现代的文本文件不一定有嵌入的Ctrl+Z，但是如果有，该操作系统会视其为一个文件结尾标记
	示例
	
	散文原文
	hello;
	hello world.	

	文件中的散文
	hello;\nhello world.\n^z

	操作系统使用的另一种方法是储存文件大小的信息
	如果文件有3000字节，程序在读到3000字节时便达到文件的末尾
	MS-DOS及其相关系统使用这种方法处理二进制文件，因为这种方法可以在文件中储存所有字符，包括Ctrl+Z
	新版的DOS也使用这种方法处理文本文件
	UNIX使用这种方法处理所有的文件

	无论操作系统实际使用何种方法检测文件的结尾，C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊值
	即(EOF)(end of file)
	scanf()函数检测到文件结尾时也返回EOF，通常，EOF定义在stdio.h头文件中
	#define EOF (-1)
	getchar()函数的返回值通常都介于(0-127)这些值对应标准字符集
	但是如果系统能识别拓展字符集，该函数返回值可能在0-255，
	无论哪种情况，-1都不对应任何字符，所以用该值标记文件结尾

	某些系统也许吧EOF定义为-1以外的值，但是定义的值一定与输入的字符所产生的返回值不同
	如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题
	这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号

	那么如何在程序中使用EOF？
	把getchar()的返回值和EOF做比较，如果两个值不同，说明没有到达文件结尾
	while((ch=getchar())!=EOF)
	
	现在修改示例程序
	
	#include<stdio.h>
	int main(void)
	{
		int ch;
		while((ch=getchar())!=EOF)
			putchar(ch);
		return 0;
	}

	注意下面几点
	1.不用定义EOF，因为stdio.h中已经定义过了
	2.不用担心EOF的实际值，头文件中已经预处理指令定义可直接使用
	3.变量ch的类型从char变为int，因为char类型的变量只能表示0-255的无符号整数
	   但是EOF的值是-1，还好，getchar()函数实际返回值的类型是int，所以它可以读取EOF字符
	   如果实现使用有符号的char类型，也可以把ch声明为char类型；
	4.由于getchar()返回的函数类型是int，如果把getchar()返回值赋给char类型的变量，一些编译器会警告丢失数据
	5.ch是整数不影响putchaar()，该函数仍然会打印等价的字符
	6.使用该程序进行键盘输入，【要设法输入EOF字符】，不能只输入EOF,也不能只输入-1
	必须找到当前系统的要求，例如大多数UNIX和Linux系统在一行开始处按下Ctrl+D会传输文件结尾信号
	许多微信计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号，一些系统把任意位置的Ctrl+Z解释成文件结尾
	
	既然程序能把用户输入的内容拷贝到屏幕上，那么考虑下该程序还可以做什么
	假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止
	或者假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据，用**.c来存储文件中输入的内容
	假设同时使用这2种方法：
	把输入从一个文件定向到**.c中，并把输出发送至另一个文件，然后便可以使用**.c来拷贝文件
	这个小程序有查看文件内容、创建一个新文件，拷贝文件的潜力

	关键是要控制输入流和输出流

	模拟EOF和图形界面
	模拟EOF的概念是在使用文本界面的命令环境中产生的，在这种环境中，用户通过敲击键盘与程序交互
	由操作系统生产EOF信号；
	但在一些实际应用中，却不能很好的转换成图形界面(如windows和Macintosh)，这些用户界面包含更复杂的鼠标移动
	和按钮点击。
	程序要模拟EOF的行为依赖于编译器和项目类型

	
8.4	重定向和文件

	输入和输出设计函数、数据和设备
	
	默认情况下，C程序使用标准I/O包查找标准输入作为输入源(stdin流)，它是把数据读入计算机的常用方式
	它可以是一个过时设备如磁带，穿孔卡或者电传打印机或者键盘甚至是一些先进技术如语音输入；
	然而现代计算机非常灵活，可以让它到别处查找输入，尤其是让一个程序从文件中查找输入，而不是从键盘

	程序可以通过两种方式适应文件
	1.显式使用特定的函数打开文件、关闭文件、读取文件、写入文件
	2.设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出
	
	换言之，把stdin流重新赋给文件，继续使用getchar()函数从输出流中获取数据，但它并不关心从流的什么位置获取数据
	重定向的一个主要问题与操作系统有关，与C无关
	尽管如此，许多C环境中（包括UNIX、Linux和windows命令提示模式）都有重定向特性
	而且一些C实现还在某些缺乏重定向特性的系统中模拟它
	

8.4.1	UNIX、Linux、DOS重定向

	UNIX(运行命令行模式时)、Linux(ditto)和windows命令行提示都能重定向输入、输出
	重定向输入让程序使用文件而不是键盘来输入；
	重定向输出让程序输出至文件而不是屏幕；

	1.重定向输入
	假设已经编译了echo_eof.c程序，并把可执行版本放入一个名为echo_eof的文件中，运行该程序，输入可执行文件名
	echo_eof
	该程序运行情况和前面描述一样，获取用户从键盘输入的输入
	现在假设你要用该程序处理名为words的文本文件
	由于该程序的操作对象时字符，所以要使用文本文件
	只需要下面的命令替代上面的命令即可：
	echo_eof<words
	<符号是UNIX和DOS/windows的重定向运算符
	该运算符使words文件与stdin流相关联，把文件中的内容导入echo_eof程序
	echo_eof程序本身并不知道(或不关心)输入的内容是来自文件还是键盘
	它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直到读到文件结尾
	因为C把文件和I/O设备放在一个层面，所以文件现在就是I/O设备

	下面是一个特殊的words文件的运行实例 $是NUIX和Linux的标准提示符，Windows/DOS系统中可能是A>或C>
	$ echo_eof<words
	******(打印内容)******
	$
	

	2.重定向输出
	现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中
	然后输入下面命令并开始输入：
	echo_eof>mywords
	>是第二个重定向运算符。
	它创建了一个mywords的新文件，然后把echo_eof的输出重定向至该文件中
	重定向把stdout从显示设备赋给mywords文件
	如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新内容
	在下一行的开始处按下Ctrl+D(NUIX)或(Ctrl+Z)即可结束该程序

	$ echo_eof>mywords
	******(打印内容)******
	[Ctrl+D]
	$

	3.组合重定向
	现在假设你希望制作一份mywords文件的副本，并命名为savewords：
	echo_eof<mywords>savewords
	或者
	echo_eof>savewords<mywords
	因为命令与重定向运算符的顺序无关
	
	但是；注意在一条命令中，输入文件和输出文件不能重名如：
	echo_eof<mywords>mywords
	原因是>mywords在输入之前已导致mywords的长度被截断为0

	总之，在UNIX、Linux、Windows/DOS系统中使用两个重定向运算符时，要遵循以下原则：
	1.	重定向运算符连接一个可执行程序和一个数据文件，不能用于连接一个数据文件和另一个数据文件；
		也不能用于连接一个程序和另一个程序；
	2.	使用重定向运算符不能够读取多个文件的输入，也不能把输出指向多个文件；
	3.	通常，文件名和运算符之间的空格不是必须的；



8.5	创建更友好的用户界面

	大部分人偶尔会写一些中看不中用的程序；
	C提供了大量的工具让输入更顺畅，处理过程更顺利
	本节的目标是，指导读者解决这些问题并创建更友好的用户界面，让交换数据输入更方便，减少错误输入的影响

8.5.1	使用缓冲输入
	缓冲输入让用户在把输入发给程序之前，可以编辑输入；
	缺点是缓冲输入要求用户输入回车键发送输入，这一动作也chuan'gei传送了换行符，程序必须处理这个换行符
	示例程序：
	
	#include<stdio.h>
	int main(void)
	{
		int guess = 1;
		printf("Pick an integer from 1 to 100.I will try to guss it.\n");
		printf("Respond with a y if my guess is right and with n if ti's wrong.\n");
		printf("Uh...is your number %d?.\n", guess);
		while (getchar() != 'y')
			printf("Well,then,is it %d?\n", ++guess);
		printf("I knew I could do it!\n");
		return 0;
	}


	注意：每次输入n时候，程序会打印两条guess，
	由于程序读取n作为用户否定了数字1，然后还读取了一个换行符否定了数字2
	一个解决方案是，使用while循环丢弃输入行最后剩余的内容，包括换行符
	这种方法的优点是，能把no和no way这样的响应视为简单的n；下面用循环修正这个问题
	while (getchar() != 'y')
	{
		printf("Well,then,is it %d?\n", ++guess);
		while (getchar() != '\n')
			continue;
	}	

	这次解决了换行符的问题，但是程序会把其他非法输入的字母视为n；
	我们用if语句筛选其他响应
	首先添加一个char类型的变量储存响应
	char response;
	修改循环如下：

	#include<stdio.h>
	int main(void)
	{
		char response;
		int guess = 1;
		printf("Pick an integer from 1 to 100.I will try to guss it.\n");
		printf("Respond with a y if my guess is right and with n if ti's wrong.\n");
		printf("Uh...is your number %d?.\n", guess);
		while ((response=getchar()) != 'y')//输入不是y时候循环
		{		
			if (response == 'n')//如果输入n,继续猜
				printf("Well,then,is it %d?\n", ++guess);
			else				//如果是非法输入其他字母
				printf("Sorry,I understand only y or n.\n");
			while (getchar() != '\n')//跳过回车键
				continue;
		}	
		printf("I knew I could do it!\n");
		return 0;
	}

	当然无论你的提示写的多么清楚，总会有人误解，然后抱怨这个程序设计的多么糟糕，
	（确实很糟糕，输入两次回车后就废了）

	#include<stdio.h>
	int main(void)
	{
		char response;
		int guess = 1;
		printf("Pick an integer from 1 to 100.I will try to guss it.\n");
		printf("Respond with a y if my guess is right and with n if ti's wrong.\n");
		printf("Uh...is your number %d?.\n", guess);
		while ((response = getchar()) != 'y')//输入不是y时候循环
		{
			if (response == 'n')//如果输入n,继续猜
				printf("Well,then,is it %d?\n", ++guess);
			else				//如果是非法输入其他字母
				printf("Sorry,I understand only y or n.\n");
			if (response == '\n')
				;
			else 
			{
				while (getchar() != '\n')//跳过回车键
					continue;
			}
		}
		printf("I knew I could do it!\n");
		return 0;
	}


8.5.2	混合数值和字符输入

	假设程序要求用getchar()处理字符输入，用scanf()处理数值输入，这两个函数都能很好的完成任务
	但是不能把它们混用；
	getchar()读取每个字符，包括空格、制表符和换行符
	scanf()在读取数字时候则会跳过空格、制表符和换行符

	下面用示例程序解释这种情况导致的问题
	程序读入一个字符和两个数字，然后根据输入的两个数字指定的行数和列数打印该字符

	#include<stdio.h>
	void display(char cr, int lines, int width);
	int main(void)
	{
		int ch;			//待打印字符
		int rows, cols;	//列和行
		printf("Enter a character and tow integers:\n");
		while ((ch = getchar()) != '\n')
		{
			scanf_s("%d %d", &rows, &cols);
			display(ch, rows, cols);
			printf("Enter another character and two integers:\n");
			printf("Enter a newline to quit.\n");
		}
		printf("bye.\n");
		return 0;
	}
	void display(char cr, int lines, int width)
	{
		int row, col;
		for (row = 1; row <= lines; row++)
		{
			for (col = 1; col <= width; col++)
				putchar(cr);
			putchar('\n');
		}
	}


	运行程序后发现只能执行一次输出，等第二次循环还未开始就直接结束了
	原因是第一次输入的结尾输入回车后，回车被getchar()读取了，进行下一轮迭代
	因为输入是回车，不会进入while循环，直接进入程序终止；输出Bye.

	要解决这个问题，程序要跳过一轮输入结束与下一轮开始之间所有的换行符或者空格
	另外，如果该程序不在getchar()测试时，而是在scanf()阶段终止程序会更好，下面是修复后：

	#include<stdio.h>
	void display(char cr, int lines, int width);
	int main(void)
	{
		int ch;			//待打印字符
		int rows, cols;	//列和行
		printf("Enter a character and tow integers:\n");
		while ((ch = getchar()) != '\n')
		{
			if (scanf_s("%d %d", &rows, &cols) != 2)
				break;		
			display(ch, rows, cols);
			while (getchar() != '\n')
				continue;
			printf("Enter another character and two integers:\n");
			printf("Enter a newline to quit.\n");
		}
		printf("bye.\n");
		return 0;
	}
	void display(char cr, int lines, int width)
	{
		int row, col;
		for (row = 1; row <= lines; row++)
		{
			for (col = 1; col <= width; col++)
				putchar(cr);
			putchar('\n');
		}
	}




8.6	输入验证

	在实际应用中，用户不一定会按照程序的指令行事；用户的输入和程序期望的不匹配时常发生；
	作为程序猿，除了完成编程的本职，还要事先预料一些可能的输入错误，检测并处理这些问题

	例如你编写了一个处理非负数整数的循环，但用户很可能输入一个负数；可用关系表达式来排除
	long n;
	scanf_s("%ld",&n);
	while(n>=0)
	{
		******
		scanf_s("%ld",&n);
	}

	另一类潜在的陷阱是，用户可能输入错误类型的值，如字符q
	这种情况的排除方法是检车scanf()函数的返回值；
	
	long n;	
	while（(scanf_s("%ld",&n)==1）&&n>=0)
	{
		******
		scanf_s("%ld",&n);
	}

	当用户输入错误类型的值时，程序结束；
	如果需要做到不退出而继续让用户再次输入正确的值，需要处理有问题的输入
	如果scanf()没有成功读取，就会将其留在输入队列中；
	这里要明确，输入实际上是字符流，可以使用getchar()函数逐字符的读取输入；
	甚至可以把这些想法都结合在一个函数中，如下：
	#include<stdio.h>
	long get_long(int m);
	int main(void)
	{
		long n;
		scanf_s("%ld", &n);
		get_long(n);
		printf("done!");
		return 0;
	}
	long get_long(int m)
	{
		long input;
		char ch;
		while (scanf_s("%ld", &input) != 1)	//如果是非法输入(非整数)
		{
			while ((ch = getchar()) != '\n')	//当非法输入不是回车的时候
				putchar(ch);//处理错误的输入
			printf(" is not an integer.\n");	//提示
			printf("Please enter an integer value.\n");	//提示
		}
		return input;
	}


	该函数要把一个int类型的值读入变量input中，如果读取失败，函数进入外层while循环
	然后内层循环逐字符的读取错误输入；注意：该函数丢弃该输入行的所有剩余内容；
	还有一个方法是，只丢弃下一个字符或单词，然后该函数提示用户再次输入；
	外层循环重复运行，直到用户成功输入整数，此时scanf()的返回值为1
	*********************************************************************************
	该程序有bug：如输入11.25，程序会舍弃.25，但是此时11仍然留在输入流里，
	程序继续提示输入，如此时输入12；程序正常运行；如把子函数返回给主函数，
	并输出input；此时输出input的值为11，而不是12；
	*********************************************************************************


	在用户输入整数后，程序可以检查该值是否有效；
	考虑一个例子，要求用户输入一个上限和一个下限来定义值的范围
	你可能希望程序检查第一个值是否大于第二个值(假设第一个值是较小的那个)
	除此之外还要检查这些值是否在允许范围内
	例如当前的档案查找一般不接受1958年以前和2014年以后的查询任务，这个限制可以在一个函数中实现

	假设程序中包含了stdbool.h头文件
	如果当前系统不允许使用_Bool，把bool替换成int，把true替换成1，false替换成0即可
	注意，如果输入无效，该函数返回true，所以函数名为bad_limits():
	bool bad_limits(long begin, long end, long low, long high)
	{
		bool not_good = false;
		if (begin > end)
		{
			printf("%ld isn't smaller than %ld.\n", begin, end);
			not_good = true;
		}
		if (begin < low || end < low)
		{
			printf("values must be %ld or greater.\n",low);
			not_good = true;
		}
		if (begin > high || end > high)
		{
			printf("value must be %ld or less.\n", high);
			not_good = true;
		}
		return not_good;
	}


	下面的程序使用了上面两个子函数来为一个进行算术运算的函数提供整数，
	该函数计算特定范围内所有整数的平方和；限制上下限是-10000000到+10000000


#include<stdio.h>
#include<stdbool.h>
long get_long(void);//验证输入是一个整数
bool bad_limits(long begin, long end, long low, long high);//验证范围是否有效
double sum_squares(long a, long b);//计算a-b之间的整数平方和

int main(void)
{
	const long MIN = -10000000L;//范围下限
	const long MAX = +10000000L;//范围上限
	long start;					//用户指定的范围最小值
	long stop;					//用户指定的范围最大值
	double answer;
	printf("This program computes the sum of the squares of integer in a range.\n");
	printf("The lower bound should not be less than -10000000\n");
	printf("And the upper bound should not be more than +10000000\n");
	printf("Enter the limits(enter 0 for bouth limits to quit):\n");
	printf("lower limit: ");
	start = get_long();
	printf("upper limit: ");
	stop = get_long();
	while (start != 0 || stop != 0)//上下限同时为0退出
	{
		if (bad_limits(start, stop, MIN, MAX))
			printf("Please try again.\n");
		else
		{
			answer = sum_squares(start, stop);
			printf("The sum of the squares of the integers from %ld to %ld is %g\n", 
				start, stop, answer);
		}
		printf("Enter the limits(enter 0 for bouth limits to quit):\n");
		printf("lower limit: ");
		start = get_long();
		printf("upper limit: ");
		stop = get_long();
	}
	printf("Done!\n");
	return 0;
}
long get_long(void)
{
	long input;
	char ch;
	while (scanf_s("%ld", &input) != 1)
	{
		while ((ch = getchar()) != '\n')
			putchar(ch);
		printf(" is not an integer.\n");
		printf("Please enter an integeer value.\n");
	}
	return input;
}
double sum_squares(long a, long b)
{
	double total = 0;
	long i;
	for (i = a; i <= b; i++)
		total += (double)i*(double)i;
	return total;
}
bool bad_limits(long begin, long end, long low, long high)
{
	bool not_good = false;
	if (begin > end)
	{
		printf("%ld isn't smaller than %ld.\n", begin, end);
		not_good = true;
	}
	if (begin < low || end < low)
	{
		printf("values must be %ld or greater.\n",low);
		not_good = true;
	}
	if (begin > high || end > high)
	{
		printf("value must be %ld or less.\n", high);
		not_good = true;
	}
	return not_good;
}


	//long get_long(void)子函数存在如11.5这样的输入误差无法擦除11这样的bug




8.6.1	分析程序

	程序应遵循模块化的编程思想，使用独立函数(模块)来验证输入和管理显示
	程序越大使用模块化编程就越重要
	
	main()函数管理程序流，为其他函数委派任务；它用：
	get_long()获取值、
	while循环处理值、
	bad_limits()函数检查值是否有效、
	sum_squares函数处理实际计算；

	
8.6.2	输入流和数字
	在编写处理错误输入的代码时，应该清楚C是如何处理输入的，如：
	is 28 12.4
	对我们而言，这就像是一个由字符、整数和浮点数组成的字符串
	但对于C而言这是一个字节流。
	第1个字节：i
	第2个字节：s
	第3个字节：空格
	第4个字节：2
	……

	所以如果get_long()函数处理这一行输入，
	第一个字符是非数字，那么整行输入都被丢弃，包括其中的数字；
	
	虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值，例如：
	42
	①如果使用%c转换说明，它只会读取字符4并且将其储存在char类型的变量中
	②如果使用%s转换说明，它会读取字符4和2这两个字符，并将其储存在字符数组中
	③如果使用%d转换说明，scanf()同样会读取两个字符，但是随后会计算出它们对应的整数值：
		4*10+2；即42，然后将表示该整数的二进制数存储在int类型的变量中
	④如果使用%f转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0，存储在float变量中
	
	简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值
	使用转换说明限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有字符

	
8.7	菜单浏览
	许多计算机程序都把菜单作为用户界面的一部分
	菜单给用户提供方便的同时，却给程序员带来了一些麻烦
	我们看看其中涉及了哪些问题

	菜单给用户提供了一份响应程序的选项；假设：
	Enter the letter of your choice:
	a.advice	b.bell
	c.count	d.quit
	
	理想状态是，用户输入程序所列选项之一，然后程序根据输入选择完成任务；
	目标1：用户遵循指令时程序顺利运行
	目标2：当用户没有遵循指令，程序也能顺利运行
	
	显而易见，目标2实现难度大，因为很难预料用户在程序使用时所有错误情况

	现在的应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸图标，
	而不是我们示例中的命令行模式；
	但是两者的处理过程大致相同：给用户提供选项，检查并执行用户的响应
	保护程序不受误操作的影响；
	除了界面不同，它们底层的程序结构也几乎相同
	但是，使用图形界面更容易通过限制选项控制输入

	
8.7.1	任务

	我们来更具体地分析一个菜单程序需要执行哪些任务
	它需要获取用户的响应，根据响应来执行动作
	另外程序应该提供返回菜单的选项
	switch是根据选项决定行为的好工具，while语句可以实现重复访问菜单
	因此我们写出以下伪代码：
		获取选项
		当选项不是'q'时
			转至相应的选项并执行
			获取下一个选项

8.7.2	使执行更顺利

	当你决定实现这个程序时，就要开始考虑如何让程序顺利运行
	(处理正确输入和错误输入时都能顺利运行)
	例如你做的时让获取选项部分的代码筛选掉不合适的响应，只把正确的响应传入switch
	这表明需要为输入过程提供一个只返回正确响应的函数，程序结构如下：

	#include<stdio.h>
	char get_choice(void);
	void count(void);
	int main(void)
	{
		int choice;
		while((choice = get_choice()) != 'q')
		{
			switch (choice)
			{
				case 'a':printf("Buy low,sell high.\n");
					break;
				case 'b':putchar("\a");
					break;
				case 'c':count();
					break;
				default:printf("Program error!\n");
					break;
			}
		}
		return 0;
	}
	定义函数getchar()只能返回abc和q，下面是一个简单笨拙的方法：
	
	char get_choice(void)
	{
		int ch;
		printf("Enter the letter of your choice:\n");
		printf("a.advice	b.bell\nc.count	q.quit\n");
		ch = getchar();
		while ((ch<'a' || ch>'c') && ch != 'q')
		{
			printf("Please respond with a,b,c,or q.\n");	
			ch = getchar();		
		}
		return ch;
	}

	
	缓冲输入依旧带来麻烦，程序每次把用户输入的回车键产生的换行符视为错误响应
	为了让程序的界面更流畅，该函数应该跳过这些换行符
	这类问题有多种解决方案
	一种是用名为get_first()的新函数替换getchar()函数，读取一行的第一个字符并丢弃剩余字符
	这种方法的优点是，把类似act这样的输入视为简单的a，不会把act中的c继续视为下一个响应
	修改如下：
	#include<stdio.h>
	char get_choice(void);
	void count(void);
	char get_first(void);
	int main(void)
	{
		int choice;
		while((choice = get_choice()) != 'q')
		{
			switch (choice)
			{
				case 'a':printf("Buy low,sell high.\n");
					break;
				case 'b':putchar("\a");
					break;
				case 'c':count();
					break;
				default:printf("Program error!\n");
					break;
			}
		}
		return 0;
	}
	char get_choice(void)
	{
		int ch;
		printf("Enter the letter of your choice:\n");
		printf("a.advice	b.bell\nc.count	q.quit\n");
		ch = get_first();
		while ((ch<'a' || ch>'c') && ch != 'q')
		{
			printf("Please respond with a,b,c,or q.\n");	
			ch = get_first();		
		}
		return ch;
	}
	char get_first(void)
	{
		int ch;
		ch = getchar();
		while (getchar() != '\n')
			continue;
		return ch;
	}

	
8.7.3	混合字符和数值输入

	前面分析过混合字符和数值输入会产生一些问题，创建菜单也有这样的问题
	例如，假设count()函数的代码如下：
	
	#include<stdio.h>
char get_choice(void);
void count(void);
char get_first(void);
int main(void)
{
	int choice;
	while((choice = get_choice()) != 'q')
	{
		switch (choice)
		{
			case 'a':printf("Buy low,sell high.\n");
				break;
			case 'b':putchar("\a");
				break;
			case 'c':count();
				break;
			default:printf("Program error!\n");
				break;
		}
	}
	return 0;
}
char get_choice(void)
{
	int ch;
	printf("Enter the letter of your choice:\n");
	printf("a.advice	b.bell\nc.count		q.quit\n");
	ch = get_first();
	while ((ch<'a' || ch>'c') && ch != 'q')
	{
		printf("Please respond with a,b,c,or q.\n");	
		ch = get_first();		
	}
	return ch;
}
char get_first(void)
{
	int ch;
	ch = getchar();
	while (getchar() != '\n')
		continue;
	return ch;
}
void count(void)
{
	int n, i;
	printf("Count how far?Enter an integer:\n");
	scanf_s("%d", &n);
	for (i = 1; i <= n; i++)
		printf("%d\n", i);
	while (getchar() != '\n')
		continue;
}
	
	

	最后菜单程序：

	#include<stdio.h>
char get_choice(void);
void count(void);
char get_first(void);
int get_int(void);
int main(void)
{
	int choice;
	void count(void);
	while((choice = get_choice()) != 'q')
	{
		switch (choice)
		{
			case 'a':printf("Buy low,sell high.\n");
				break;
			case 'b':putchar("\a");
				break;
			case 'c':count();
				break;
			default:printf("Program error!\n");
				break;
		}
	}	
	return 0;
}
void count(void)
{
	int n, i;
	printf("Count how far?Enter an integer:\n");
	n = get_int();	
	for (i = 1; i <= n; i++)
		printf("%d\n", i);
	while (getchar() != '\n')
		continue;
}
char get_choice(void)
{
	int ch;
	printf("Enter the letter of your choice:\n");
	printf("a.advice	b.bell\nc.count		q.quit\n");
	ch = get_first();
	while ((ch<'a' || ch>'c') && ch != 'q')
	{
		printf("Please respond with a,b,c,or q.\n");	
		ch = get_first();		
	}
	return ch;
}
char get_first(void)
{
	int ch;
	ch = getchar();
	while (getchar() != '\n')
		continue;
	return ch;
}
int get_int(void)
{
	int input;
	char ch;
	while (scanf_s("%d", &input) != 1)
	{
		while ((ch = getchar()) != '\n')
			putchar(ch);
		printf(" is not an integer.\n");
		printf("Please enter an integer.\n");
	}
	return input;
}

	



8.8	关键概念
	C程序把输入作为传入的字节流
	getchar()把每一个字符解释成一个字符编码
	scanf()韩式以同样的方式看待输入，可根据转换说明，转化成数值
	许多操作系统都提供重定向，允许文件替代键盘输入，用文件替代显示器输出

	程序通常接受特殊形式的输入，可以在设计程序时考虑用户在输入时可能犯的错
	在输入验证部分处理这些错误情况，让程序更强健更友好
	
	对于一个小程序，输入验证可能是代码中最复杂的部分，这类问题有多种方案处理
	如可以终止程序，也可以给用户提供多次或无限次机会重新输入

8.9	本章小结
	
8.10	复习题

	1.putchar(getchar())是一个有效表达式，它能实现什么功能？getchar(putchar())是否也是有效表达方式？
	//输出读取到的字符包括空格制表回车；getchar(putchar())不是有效表达式,putchar()内缺少参数；
	getchar(putchar(getchar()))
	
	2.下面的语句分别完成什么任务？
	a.putchar('H');	//输出字符 H
	b.putchar('\007');	//如果系统使用ASCII，发处一声警报，
	c.putchar('\n')	//输出换行符
	d.putchar('\b')	//退后一格

	3.假设有一个名为count的可执行程序，用于统计输入的字符数
	设计一个使用count程序统计essay文件中字符数的命令行
	并把统计结果保存在essayct文件中	
	count<essay>essayct
	
	4.给定复习题3中的程序和文件，下面哪一条是有效的命令？
	a.essayct<essay	//有效
	b.count essay
	c.esay>count
	
	5.EOF是什么？//文件结尾标记
	
	6.对于给定的输出(ch 是int类型，而且是缓冲输入)，下面各段程序的输出分别是？
	a.	输入如下：
		If you quit,i will.[enter]
		程序段如下：
		while((ch=getchar())!='i')
			putchar(ch);
		//If you qu

	b.	输入如下：
		Harhar[enter]
		程序段如下
		while((ch=getchar())!='\n')
		{	
			putchar(ch++);
			putchar(++ch);
		}

		HJacrthjacrt

	7.C如何处理不同计算机系统中的不同文件和换行约定？
	8.在使用缓冲输入的系统中，把数值和字符混合输入会遇到什么潜在问题？

	
8.11	编程练习
	下面的一些程序要求输入以EOF终止
	如果你的操作系统很难或根本无法使用重定向，请使用一些其他测试来终止输入
	
	1.设计一个程序，统计在读到文件结尾之前读取的字符数
	#include<stdio.h>
	int main(void)
	{
		char ch;
		int n=0;
		while ((ch = getchar()) != EOF)		
			n++;
		printf("%d",n);	
		return 0;
	}
	
	2.编写一个程序，在遇到EOF之前，把输入作为字符流读取。
	程序要打印每个输入的字符及其相应的ASCII十进制值；
	tips：空格符前面的字符都是非打印字符，要特殊处理
	如果非打印字符是换行符或制表符，则分别打印\n或\t
	否则，使用控制字符表示法，例如：
	ASCII的1是ctrl+A,可显示为^A
	注意A的ASCII值是ctrl+A的值加上64
	其他非打印字符也有类似关系；
	除每次遇到换行符打印新的一行以外，每行打印10对值
	

#include<stdio.h>
int main(void)
{
	char ch;
	int n,i,k;
	i=0;
	while ((ch = getchar()) !=EOF)
	{
		n = (int)ch;
		if (n < 32) 
		{
			if (ch == 10)
			{
				printf("\\n--%d	\n", n);
				i = -1;
			}
			else if (ch == 9)
			{
				printf("\\t--%d	", n);
			}
			else
			{
				k = n + 64;
				printf("%c%c--%d	", 94, k,n);
			}
		}
		else
		{
			putchar(ch);
			printf("--%d	", n);
		}
		i++;	
		while (i%10==0)
		{
			printf("\n");
			break;
		}
	}
	return 0;
}
	
	

	3.编写一个程序，在遇到EOF之前，把输入作为字符流读取。
	该程序要报告输入中的大写字母和小写字母个数；
	假设大小写字母数值是连续的，或者使用ctype.h库中的分类函数
	#include<stdio.h>
	#include<ctype.h>
	int main(void)
	{
		char ch;
		int up=0,low=0,n=0;
		while ((ch = getchar()) != EOF)
		{
			if (isupper(ch))
				up++;
			else if (islower(ch))
				low++;
			else
				n++;
		}
		printf("upper:%d\nlower:%d\n", up, low);		
		return;
	}
	

	

	4.编写一个程序，在遇到EOF之前，把输入作为字符流读取
	该程序要报告平均每个单词的字母数
	不要把空白统计为单词的字母，实际上标点符号也不应该统计
	(考虑使用ctype.h的ispunct()函数：标点符号)

#include<stdio.h>
#include<ctype.h>
int main(void)
{
	char ch;
	int n=0, m=0, k=0;//单词数量，字母数量，标记
	double average;	
	while ((ch = getchar()) != EOF)
	{
		while (ch != '\n'&&ch != '\t'&&ch != ' ' && !ispunct(ch))
		{
			if (k == 0)
			{m++; n++;k = 1; break;}
			else
			{m++;k = 1; break;}
		}
		if (ch == '\n' || ch == '\t' || ch == ' ' || ispunct(ch))
			k = 0;
	}
	average = (double)m / (double)n;
	printf("%d	%d	%.2f", m, n, average);
	return 0;	
}

	


	5.修改猜字数游戏，使用更智能的猜测策略，例如程序最初猜50；询问用户大了还是小了
	如果猜小了，那么下一次猜测的值应该是50和100的中值，也就是75；
	如果这次猜大了，那么下一次猜测的值应该是50和75的中值，等等
	使用二分查找策略，如果用户没有欺骗程序，那么程序很快就会猜到正确答案
#include<stdio.h>
#define start 50
int main(void)
{
	char response;
	int guess = start;
	int big=101, small=0;
	printf("Pick an integer from %d to %d.I will try to guss it.\n",small+1,big-1);
	printf("Respond with a y if my guess is right and with n if ti's wrong.\n");
	printf("Respond with s if ti's small.\n");	//猜小了，往大猜
	printf("Respond with b if ti's big.\n");	//猜大了，往小猜
	printf("Uh...is your number %d?.\n", guess);
	while ((response = getchar()) != 'y')//输入不是y时候循环
	{
		if (response == 'b')//猜大了，往小猜
		{
			big = guess;
			guess = (guess+small)/2;
			printf("Well,then,is it %d?\n",guess);
		}
		else if(response=='s')//猜小了，往大猜
		{
			small = guess;
			guess = (guess + big) / 2;
			printf("Well,then is it %d?\n", guess);
		}
		else				//如果是非法输入其他字母
			printf("Sorry,I understand only 'y' or 's' or 'b'.\n");
		if (response == '\n')
			;
		else
		{
			while (getchar() != '\n')//跳过回车键
				continue;
		}
	}
	printf("I knew I could do it!\n");
	return 0;
}
	



	6.修改程序8.8中的get_first()函数，让该函数返回读取的第一个非空白字符
	并在一个简单的程序中测试

#include<stdio.h>
char get_first(void);
int main(void)
{	
	char m;
	m = get_first();
	putchar(m);
	return 0;
}
char get_first(void)
{
	int ch;
	ch = getchar();	
	while (1) 
	{
		if (ch == ' ' || ch == '\n' || ch == '\t')
		{
			ch = getchar();
			continue;
		}
		else
			break;
	}
	return ch;
}




	8.编写一个程序，显示一个提供加减乘除法的菜单，获得用户选择的选项后，
	程序提示用户输入两个数字，然后执行用户刚才选择的操作。
	该程序只接受菜单提供的选项
	程序使用float类型的变量存储用户输入的数字，如果用户输入失败，允许再次输入
	除法计算时如果用户输入第二个数0，提示用户重新输入一个新值
	该程序的一个运行示例如下：
	Enter the operation of your choice:
	a.  add		s.subtract
	m. multiply 	d.divide
	q.  quit
	a//输入a
	Enter first number:22.4//输入22.4
	Enter second number:one//输入one
	one is not an number.
	Please enter a number,such as 2.5 -1.78E8,or 3:1//输入1
	22.4+1=23.4
	Enter the operation of your choice:
	a.  add		s.subtract
	m. multiply 	d.divide
	q.  quit
	d//输入d
	Enter first number:18.4//输入18.4
	Enter second number:0//输入0
	Enter a number other than 0:0.2//输入0.2
	18.4/0.2=92
	Enter the operation of your choice:
	a.  add		s.subtract
	m. multiply 	d.divide
	q.  quit
	q//输入q
	Bye.

#include<stdio.h>
void add(float add1, float add2);	//加法子函数
void subtract(float sub1, float sub2);	//减法子函数
void multiply(float mul1, float mul2);	//乘法子函数
void divide(float div1, float div2);	//除法子函数
void menu(void);		//菜单
float input(void);		//输入
char getfirst(void);	//首字母选项
int main(void)
{
	char ch;
	float num1 = 0, num2 = 0;
	menu();
	while ((ch = getfirst()) != 'q')
	{
		switch (ch)
		{
		case 'a':add(num1, num2); menu(); getchar(); continue;
		case 's':subtract(num1, num2); menu(); getchar(); continue;
		case 'm':multiply(num1, num2); menu(); getchar(); continue;
		case 'd':divide(num1, num2); menu(); getchar(); continue;
		default:printf("please enter a,s,m,d or q to quit.\ntry again.\n"); continue;
		}
	}
	printf("Bye.");
	return 0;
}
void menu(void)
{
	printf("Enter the operation of your choice:\n");
	printf("a.add		s.subtract\nm.multiply	d.divide\nq.quit\n");
}
float input(void)
{
	float put;
	char ch;
	while ((scanf_s("%f", &put)) != 1)
	{
		while ((ch = getchar()) != '\n')
			putchar(ch);
		printf(" is not an number.\n");
		printf("Please enter a number,such as 2.5,-1.78E8,or 3:");
	}
	return put;
}
char getfirst(void)
{
	char first;
	first = getchar();
	while (getchar() != '\n')
		continue;
	return first;
}
void add(float add1, float add2)
{
	printf("Enter first number:");
	add1 = input();
	printf("Enter second number:");
	add2 = input();
	printf("%g+%g=%g\n", add1, add2, add1 + add2);	
}
void subtract(float sub1, float sub2)
{
	printf("Enter first number:");
	sub1 = input();
	printf("Enter second number:");
	sub2 = input();
	printf("%g-%g=%g\n", sub1, sub2, sub1 - sub2);
	
}
void multiply(float mul1, float mul2)
{
	printf("Enter first number:");
	mul1 = input();
	printf("Enter second number:");
	mul2 = input();
	printf("%g*%g=%g\n", mul1, mul2, mul1*mul2);	
}
void divide(float div1, float div2)
{
	printf("Enter first number:");
	div1 = input();
	printf("Enter second number:");
	div2 = input();
	if (div2 == 0)
	{
		printf("Enter a number other than 0:");
		div2 = input();
	}
	printf("%g/%g=%g\n", div1, div2, div1 / div2);	
}


【第九章】	函数
	
	关键字：return
	运算符：*(一元)、&(一元)
	函数及其定义方式
	如何使用参数和返回值
	如何把指针变量用作函数参数
	函数类型
	ANSI C原型
	递归

	
	
9.1	复习函数
	函数概念
	如何组织程序？C的设计思想是，把函数用作结构件块，我们已经用过C标准库的函数
	如printf() scanf() getchar() putchar()和strlen()；
	函数是完成特定任务的独立程序代码单元，语法规则定义了函数的结构和使用方式
	
	为什么要使用函数？首先，可以省去编写重复代码的苦差。其次，让程序更加模块化
	提高代码可读性，方便后期修改、完善

	例如编写一个程序完成以下任务：
	*读入一些列数字
	*分类这些数字
	*找出这些数字的平均值；
	*打印一份柱状图

	可以使用下面的程序

	#include<stdio.h>
	#define SIZE 50
	int main(void)
	{
		float list[SIZE];
		readlist(list SIZE);
		sort(list SIZE);
		average(list SIZE);
		bargraph(list SIZE);
		return 0;
	}
	当然还要编写四个函数readlist();sort();average();bargraph()来实现细节
	
	描述性函数名能清楚地表达函数的用途和组织，然后单独设计和测试每个函数，直到完成任务
	如果这些函数能够通用，还可以用于其他程序

	许多程序员喜欢把函数看作是根据传入信息(输入)及其生成的值或响应的动作(输出)来定义的“黑盒”
	如果不是自己编写的函数，根本不用关心黑盒的内部行为
	例如使用printf()时，只需知道给该函数传入格式字符串或一些参数以及它生成的输出，无需了解内部代码
	以这种方式看待函数有助于集中注意力在程序的整体设计，而不是函数的实现细节上
	因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系

	如何了解函数？
	①如何定义函数
	②如何调用函数
	③如何建立函数间的通信
	

9.1.1	创建并使用简单函数
	示例：
	创建一个在一行打印40个星号的函数，并在一个打印表头的程序中使用该函数

#include<stdio.h>
#define NAME "GIGATHINK,INC."
#define ADDRESS "101 Megabuck Plaza"
#define PLACE "Megapolis,CA 94904"
#define WIDTH 40

void starbar(void);//函数原型
int main(void)
{
	starbar();//调用函数
	printf("%s\n", NAME);
	printf("%s\n", ADDRESS);
	printf("%s\n", PLACE);
	starbar();
	return 0;
}
void starbar(void)//定义函数
{
	int count;
	for (count = 1; count <= WIDTH; count++)	
		putchar('*');
	putchar('\n');
}

	程序输出如下
	**********************************
	GIGATHINK,INC.
	101 Megabuck Plaza
	Megapolis,CA 94904	
	**********************************

	
9.1.2	分析程序
	该程序要注意以下几点
	1.程序在3处使用了starbar标识符：
		函数原型：告诉编译器函数starbar()的类型
		函数调用：表明此处执行函数
		函数定义：明确地指定了函数要做什么

	2.函数和变量一样，有多种类型，任何程序在使用函数之前都要声明该函数的类型
	因此在main()函数定义的前面出现了ANSI C风格的函数原型
	void starbar(void);
	()圆括号表明starbar是一个函数名；
	第一个void是函数类型，void类型表明函数没有返回值
	第二个void表明该函数不带参数；
	分号表明这是在声明函数，不是定义函数

	也就是说，这行声明了程序将使用一个名为starbar()，没有返回值，没有参数的函数
	并告诉编译器在别处查找该函数的定义；
	
	3.一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型，这些信息称为该函数的签名
	对于starbar()函数而言，其签名是该函数没有返回值，没有参数。

	4.程序把starbar()原型置于main()的前面，当然也可以放在main()里面的声明变量处，两处都可以
	
	5.在main()中，执行了下面的语句时调用了starbar()函数；
		starbar()；
	这是调用void类型函数的一种形式；当计算机执行到这一语句时候，会找到该函数的定义并执行其中内容
	执行完starbar()中的代码后，计算机返回主调函数main()继续执行下一行；

	6.程序把starbar()和main()放在一个文件中，当然也可以把他们放在两个文件中。
	把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同程序中使用同一个函数
	如果把函数放在一个单独的文件中，要把#define和#include指令也放入该文件

	7.starbar()函数中的count是局部变量，意思是该变量只属于starbar()函数
	可以在程序中其他地方包括main()中也是用count，这不会引起名称冲突，他们是同名的不同变量

	如果把starbar()看作是一个黑盒子，那么它的行为是打印一行星号；
	不用给该函数提供任何输入，因为调用它不需要其他信息，而且它没有返回值，所以也不会给main()提供任何信息
	简而言之，starbar()不需要与主调函数通信；
	
	接下来看一个函数间需要通信的例子

9.1.3	函数参数

	上一个示例中，如果文字能居中会更加美观，可以通过打印文字之前打印一定数量的空格来实现
	这与打印一定数量的*类似，只不过是打印的是一定数量的空格
	虽然这是两个任务，但是任务非常相似，与其为他们各编写一个函数，不然写一个更通用的函数
	我们设计一个新函数show_n_char()；
	唯一要改变的是使用内置的值来显示字符和重复的次数，这通过使用函数参数来传递这些值

	具体分析：
	假设可用的空间是40个字符宽，调用show_n_char('*',40)应该正好打印一行40个星号，
	就像starbar()之前做的那样
	第二行GIGATHINK,INT.的空格怎么处理？这是15个字符宽，所以有25个空格，左侧应该留14个空格
	因此可调用show_n_char('*',12)。
	
#include<stdio.h>
#include<string.h>					//为strlen()提供原型
#define NAME "GIGATHINK,INC."
#define ADDRESS "101 Megabuck Plaza"
#define PLACE "Megapolis,CA 94904"
#define WIDTH 40
#define SPACE ' '

void show_n_char(char ch,int num);//函数原型
int main(void)
{
	int spaces;
	show_n_char('*', WIDTH);
	putchar('\n');
	show_n_char(SPACE,12);
	printf("%s\n", NAME);
	spaces = (WIDTH - strlen(ADDRESS)) / 2;
	show_n_char(SPACE,spaces);
	printf("%s\n", ADDRESS);	
	show_n_char(SPACE, (WIDTH - strlen(PLACE)) / 2);
	printf("%s\n", PLACE);
	show_n_char('*', WIDTH);
	putchar('\n');
	return 0;
}
void show_n_char(char ch, int num)//定义函数
{
	int count;
	for (count = 1; count <= num; count++)	
		putchar(ch);	
}


9.1.4	定义带形式参数的函数

	函数定义从下面的ANSI C风格的函数头开始：
	void show_n_char(char ch,int num);
	该行告知编译器void show_n_char()使用两个参数ch和num，ch是char类型，num是int类型
	这两个变量被称为形式参数，简称形参；
	和定义在函数中变量一样，形参也是局部变量，属于该函数私有。
	这意味着在其他函数中使用同名变量不会引起名称冲突；
	每次调用函数，就会给这些变量赋值
	
	注意，ANSI C要求在每个变量前面都声明类型，如：
	void dibs(int x,y,z);		//无效的函数头
	void dibs(int x,int y, int z);	//有效的函数头
	
	void show_n_char(ch,num)
	char ch;
	int num;
	
	void dibs(x,y,z)
	int x,y,z;
	
	这些ANSI C之前的形式正在逐渐淘汰

	
	虽然show_n_char()接受来自main()的值，但是它没有返回值，因此它的类型是void；
	
	
9.1.5 	声明带形式参数函数的原型

	在使用函数之前，要用ANSC形式声明原型：
	void show_n_char(char ch,int num);
	当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型；
	根据个人喜好，也可以省略成变量名：
	void show_n_char(char,int);

9.1.6	调用带实际参数的函数
	
	在函数调用中，实际参数提供了ch和num的值
	show_n_char(SPACE,12);
	实际参数是空格字符和12，这两个值被赋给show_n_char()中相应的形参ch和num
	简而言之：
	形参是被调函数中的变量，实际参数是主调函数赋给被调函数的具体值
	如上所示，实际参数可以是常量、变量甚至是更复杂的表达式
	无论实际参数是何种形式被求值，最后该值被拷贝给被调函数相应的形式参数
	show_n_char(SPACE, (WIDTH - strlen(PLACE)) / 2);
	构成该函数第二个实际参数的是一个很长的表达式，对该表达式求值为10，然后10被赋给变量num
	被调函数不知道也不关心传入的值是来自常量变量还是表达式
	再次强调，实际参数是具体的值，该值要被赋给作为形参的变量
	因为被调函数使用的值是从主调函数中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，
	都不会影响主调函数中的原始数据。


9.1.7	黑盒视角
	从黑盒子视角看show_n_char()，待显示的字符和显示的次数是输入(ch,num)；
	执行后的打印结果是打印指定数量的字符；
	输入以参数的形式被传递给函数，这些信息清楚的表明了如何在main()中使用该函数；
	黑盒子的核心部分是：ch、num和count都是show_n_char()私有的局部变量
	也就是说如果main()有一个count变量那么改变它的值不会改变show_n_char()中的count
	反之亦然，黑盒子发生了什么对主调函数是不可见的；

9.1.8	使用return从函数中返回值
	
	前面介绍了如何把信息从主调函数传递给被调函数，反过来，函数的返回值可以把信息从被调函数传回主调函数
	我们创建一个返回两个参数中较小值的函数；
	由于函数被设计用来处理int类型的值，所以被命名为imin()，
	另外创建一个简单的main()用于检查imin()是否正常工作；
	这种被设计用于检测函数的程序有时被称为驱动程序，该驱动程序调用一个函数，如果函数成功通过了测试，
	就可以安装在一个更重要的程序中使用。
	代码：
	
#include<stdio.h>
int imin(int, int);
int main(void)
{
	int a, b;
	printf("Enter a pair of integers(q to quit):\n");
	while (scanf_s("%d%d", &a, &b) == 2)
	{
		printf("The lesser of %d and %d is %d.\n", a, b, imin(a, b));
		printf("Enter a pair of integers(q to quit):\n");
	}
	printf("Bye.\n");
	return 0;
}
int imin(int n, int m)
{
	int min;
	if (n < m)
		min = n;
	else
		min = m;
	return min;
}


	scanf()返回成功读取数据的个数，如果输入不是两个整数会导致循环结束；
	如果输入三个整数，则第三个会留在输入流里成为下一次输入的第一个参数；

	关键字return后面的表达式的值就是函数的返回值；
	变量min属于imin()函数私有，但是return语句把min的值传回了主调函数；
	下面这条语句的作用是把min的值赋给lesser：
	lesser=imin(n,m);
	而不能写成：
	imin(n,m);
	lesser=min;
	因为主调函数甚至不知道min的存在；记住，imin()中的变量是imin()的局部变量
	函数调用imin(a,b)只是把两个变量的值拷贝了一份；
	
	返回值不仅可以赋给变量，也可以被用作表达式的一部分，例如可以这样：
	answer=2*imin(z,zstar)+25;
	printf("%d\n",imin(-32+answer,LIMIT));
	返回值不一定是变量的值，也可以是任意表达式的值，例如：
	imin(int n,int m)
	{
		return (n<m)?n:m;
	}
	条件表达式的值是n和m中的较小者，该值要被返回给主调函数；
	
	如果函数返回值的类型与函数声明的类型不匹配会怎样？
	int what_if(int n)
	{
		double z=100.0/(double)n;
		return z;
	}
	
	实际得到的返回值相当于把函数中指定的返回值给与函数类型相同的变量所得到的值
	因此在本例中，相当于把z的值赋给int类型的变量，然后返回给int类型变量的值；
	例如，有下面的函数调用：
	result=whta_if(64);
	虽然在whta_if()函数中赋给z的值是1.5625，但是return语句返回确却是int类型的值1

	使用return语句的另一个作用是，种植函数把控制返回给主调函数的下一条语句；
	因此可以这样写imin():
	imin(int n,intm)
	{
		if(n<m)
			return n;
		else
			return m;
	}

	许多C程序员认为只在函数末尾使用一次return语句比较好，这样更方便浏览程序的人理解函数的控制流
	但是在函数中使用多个return语句也没有错；

	对用户而言，这三个版本的函数用起来都一样，因为所有的输入和输出都完全相同，
	不同的只是函数内部的实现细节，下面的版本也没问题：
	imin(int n,intm)
	{
		if(n<m)
			return n;
		else
			return m;
		printf("well,done.\n")
	}
	return 语句导致printf()语句永远不会被执行；


	另外还可以这样使用return：
	return；
	这条语句会导致终止函数，并把控制返回给主调函数，因为return没有任何表达式，所有没有返回值；
	只有在void函数中才会用到这种形式

9.1.9	函数类型

	声明函数时候必须声明函数类型，带返回值的函数类型应该与其返回值类型相同，
	没有返回值的函数应声明为void类型；
	如果没有声明函数的类型，旧版本的C编译器会假定函数的类型是int，C99不再支持这种假定

	类型声明式函数定义的一部分，要记住，函数类型指的是返回值的类型，不是函数参数的类型；
	比如：
	double klink(int a,int b)
	定义了一个带有两个int类型参数的函数，其返回值是double类型；

	要正确的使用函数，程序在第一次使用函数之前必须知道函数的类型；
	方法之一是，把完整的函数定义放在第一次调用函数的前面，然而这种方法增加了程序的阅读难度
	而且，要使用的函数可能在C库或其他文件中，因此，通常做法是提前声明函数，
	函数声明可以放在主调函数外，也可以放在主调函数内，但一定要在使用该函数之前声明；

	ANSI C标准库中，函数被分成了多个系列，每一个系列都有各自的头文件
	这些头文件中除了其他内容，还包含了本系列所有函数的声明；
	不要混淆函数的声明和定义，声明是告知编译器函数的类型，定义则提供实际代码；

9.2	ANSI C函数原型

	在ANSI C标准之前，声明函数的方案有缺陷，因为只需要声明函数的类型，不声明任何参数；
	我们看一下使用旧式的函数声明会导致什么问题
	int imin();
	以上函数声明并未给出函数的参数个数和类型，
	因此如果调用该函数时使用的参数个数不对或类型不匹配，编译器根本不会察觉出来；
	#include<stdio.h>
	int imax();
	int main(void)
	{
		printf("the maximum of %d and %d is %d.\n", 3, 5, imax(3));
		printf("The maximum of %d and %d is %d.\n", 3, 5, imax(3.0, 5.0));
		return 0;
	}
	int imax(n, m)
	{
		return(n > m ? n : m);
	}
	
	输出结果 529219；1074266112；
	第1次调用时省略了imax的一个参数，第2次调用时两个浮点参数不是整形参数；
	
	主调函数把它的参数储存在被称为栈的临适储存区，被调函数从栈中读取这些参数；
	对于该例，这俩个过程并未相互协调；主调函数根据函数调用中的实际参数决定传递的类型；
	而被调参数根据它的形式参数读取数值，
	因此，函数调用imax(3)把一个整数放在栈中，当iman()函数开始执行时，它从栈中读取两个整数
	而实际上栈中只存放了一个带读取的整数，所以读取的第二个值是当时恰好在栈中的其他值
	第2次调用imax()函数时，它传递的是float类型的值，这次把两个double类型的值放在栈中
	在我们的系统中，两个double类型的值就是两个64位的值，所以128位的数据被存放在栈中
	当imax()从栈中读取两个int类型的值时，它从栈中读取前64位（每个int变量占32位）；
	这些数据对应两个整数，其中较大的被输出为结果；

	
9.2.2	ANSI的解决方案
	
	针对参数不匹配问题，ANSI C标准要求在函数声明时还要声明变量的类型，
	即使用函数原型来声明函数的返回类型、参数的数量和每个参数的类型；如
	int imax(int,int);或
	int imax(int a,int b);
	第1种形式使用逗号分隔的类型列表
	第2种形式在后面添加了变量名，这里的变量名时假名，不必与函数定义的形式参数名一致；

	有了这些信息，编译器可以检查函数调用是否匹配函数原型，参数数量类型是否匹配；
	例如上例中imax(3.0,5.0)会被转换成imax(3,5)；

	#include<stdio.h>
	int imax(int,int);
	int main(void)
	{
		printf("the maximum of %d and %d is %d.\n", 3, 5, imax(3));
		printf("The maximum of %d and %d is %d.\n", 3, 5, imax(3.0, 5.0));
		return 0;
	}
	int imax(int n,int m)
	{
		return(n > m ? n : m);
	}
	
	运行后编译器会警告第一次调用函数参数太少的错误信息，换成imax(3,5)后编译正常；
	第二次调用虽然没有错误消息，但是编译器还是会给出警告：double转换成int可能会丢失数据
	例如：
	imax(3.9,5.4)相当于imax(3,5)

	错误和警告的区别是：错误无法编译，而警告仍然允许编译；
	一些编译器在进行类似的类型转换时不会通知用户，因为C标准对此未作要求；
	
9.2.3	无参数和未指定参数

	假设有下面的函数原型：
	void print_name();
	一个支持ANSI C的编译器会假定用户没有用函数原型来声明函数，它将不会检查参数
	为了表明函数确实没有参数，应在圆括号中使用void关键字：
	void print_name(void);
	
	编译器解释为print_name()不接受任何参数，然后在调用函数时，编译器会检查以确保没有使用参数
	
	一些函数接受许多参数，例如对于printf()，第1个参数是字符串，但是其余的参数的类型和数量都不固定的情况；
	ANSI C 允许使用部分原型；例如使用下面的原型：
	int printf(const char *,...);
	这种原型表明，第1个参数是一个字符串，可能还有其他未指定的参数；
	C库通过stdarg.h头文件提供了一个定义这类形参数量不固定的函数的标准方法；16章节会介绍

9.2.4	函数原型的优点
	
	函数原型是C语言的一个强有力的工具
	它让编译器捕获在使用函数时可能出现的许多错误和疏漏；
	如果编译器没有发现这些问题，就很难察觉出来，是否必须使用函数原型？不一定，但是这样弊大于利；
	
	有一种方法可以省略函数原型却保留函数原型的优点，就是把整个函数定义放在第一次调用函数之前；效果相同
	int imax(int a,int b){return a>b?a:b;}
	int main(void)
	{
		int z;	
		z=imax(10,5);
		return 0
	}
	此时函数定义也相当于函数原型，对于较小的函数，这种用法也很普遍；


9.3	递归
	
	C允许函数调用它自己，这种调用过程称为递归；
	递归有时难以捉摸，有时却很方便实用；
	结束递归是使用递归的难点，如果递归代码中没有终止递归的条件测试部分，会无限递归；
	
	可以使用循环的地方通常都可以使用递归，有时用循环有时用递归更好；
	递归方案更简洁，但效率却没有循环高；

9.3.1	演示递归
	
	我们通过一个程序示例，来学习什么是递归
	
	#include<stdio.h>
	void up_and_down(int);
	int main(void)
	{
		up_and_down(1);
		return 0;
	}
	void up_and_down(int n)
	{
		printf("Level %d:n location %p\n", n, &n);//1#
		if (n < 4)
			up_and_down(n + 1);
		printf("LEVEL %d:n location %p\n", n, &n);//2#
	}

	分析代码：
	①首先，主调函数main()调用了带参数1的up_and_down()函数，进入被调函数：
	执行结果是up_and_down()的形参数值是1，所以打印出1# level 1；

	②执行if语句，n<4成立，被调函数再调用二级的up_and_down()，n=2,输出1# level 2
	依次类推下面两次调用打印分别是1# level 3,和1# level 4
	
	③当执行到第4级时，n的值是4，if 测试条件为假，up_and_down(n+1)停止调用自己；
	跳过if语句并打印下一行2# LEVEL 4，第4级调用结束，控制被传回它的主调函数第3级调用
	
	③在第3级调用中，执行的最后一条语句是if语句，返回后继续执行if语句后面的，输出2# LEVEL3
	
	④依次类推，逐级返回控制输出2# LEVEL 2和2# LEVEL 1
	
	注意，每级递归的变量n都属于本级递归私有，
	这从程序输出的地址值(&n)可以看出，level 1和LEVEL 1变量n都是n=1,所以地址值相同；

9.3.2	递归的基本原理

	第1，每级函数调用都有自己的变量，也就是说第1级n和第2级n的值不同，所以程序创建了4个单独的变量
	每个变量的名称都是n，但是它们的值不相同，当程序返回up_and_down()第1级调用时，n值仍是初值1

	递归中的变量n演变如下：
	
	变量		n	n	n	n
	1级调用后		1
	2级调用后		1	2
	3级调用后		1	2	3
	4级调用后		1	2	3	4
	从4级调用返回后	1	2	3
	从3级调用返回后	1	2	
	从2级调用返回后	1
		
	从1级调用返回main()后结束全部

	
	第2，每次函数调用都会返回一次，当函数执行完毕后，控制权被传回上一级递归；
	程序必须按顺序逐级返回递归，从某一级返回上一级，不能跳级到main()函数中的一级调用；
	
	第3，递归函数中位于递归调用之前的语句，均按被调函数的顺序执行，例如1#位于递归调用之前
	它按照递归的顺序：第1级、第2级、第3级、第4级，被执行了4次；
	
	第4，递归函数中位于递归调用之后的语句，均按照被调函数相反的顺序执行，例如2#位于递归后
	其执行顺序是：第4级、第3级、第2级、第1级，也被执行了4次；
	递归调用这种特性在解决涉及相反顺序的编程问题时很有用；

	第5，虽然每级递归都有自己的变量，但是并没有拷贝函数的代码；
	程序按照顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码，每次为递调用创建变量
	
	最后，递归函数必须包含能让递归调用停止的语句；
	通常用if或其他等价的测试条件在函数形参等于某特定值时终止递归，为此每次递归调用的形参都要使用不同值
	例如示范程序up_and_down(n)调用up_and_down(n+1)，最终实际参数等于4的时候if的测试条件(n<4)为假；

9.3.3	尾递归
	
	最简单的递归形式是把递归调用置于函数的末尾，即正好在return语句之前，这种形式被称为尾递归；
	尾递归是最简单的递归形式，相当于循环
	
	下面介绍的示例程序，分别用循环和尾递归计算阶乘；
	一个正整数的阶乘是从1到该数的所有整数的乘积，例如3的阶乘写作3！，是1*2*3，另外0！等于1；符数没有阶乘
	
#include<stdio.h>
long fact(int n);
long rfact(int n);
int main(void)
{
	int num;
	printf("This program calculates factorials.\n");
	printf("Enter a value in the range 0-12(q to quit):\n");
	while ((scanf_s("%d", &num)) == 1)
	{
		if (num < 0)
		printf("No negative numbers,please.\n");
		else if (num > 12)
			printf("Please input under 13.\n");
		else
		{
			printf("loop:%d factorial=%d\n",num,fact(num));
			printf("recursion:%d factorial=%d\n", num, rfact(num));
		}
		printf("Enter a value in the range 0-12(q to qiut):\n");
	}
	printf("Bye.\n");
	return 0;
}
long fact(int n)
{
	long m;
	for (m = 1; n > 1; n--)
		m = m * n;
	return m;
}
long rfact(int n)
{
	long m;
	if (n > 0)
		m = n * rfact(n - 1);
	else
		m = 1;
	return m;	
}





	
9.3.4	递归和倒序计算
	
	递归在处理倒序时非常方便(在解决这类问题中，递归比循环简单)
	编写一个函数，打印一个整数的二进制数；二进制表示法根据2的幂来表示数字；
	例如234=2*10^2+3*10^1+4*10^0,
	我们要设计一个以二进制形式表示整数的方法或算法。
	
	①	例如十进制5，在二级制中，奇数的末尾一定时1，偶数末尾一定是0，通过5%2即可确定，
	二进制的最后一位是1还是0；
	一般而言，对于数字n，二进制的最后一位是n%2；
	因此，计算的第一位数字实际上是待输出二进制数的最后一位；这一规律提示我们：
	在递归函数的递归调用之前计算n%2;在递归之后打印计算结果；
	这样，计算的第1个值正好是最后一个打印的值；

	②要获得下一位数字，继续把原数除以2，如果是偶数那么二进制下一位数就是0，奇数就是1；
	只要结果大于2，就说明还有二进制位；

#include<stdio.h>
void to_binary(unsigned long n);
int main(void)
{
	unsigned long num;
	printf("Enter an integer(q to qiut):\n");
	while ((scanf_s("%lu", &num)) == 1)
	{
		printf("Binary equivalent:");
		to_binary(num);
		putchar('\n');
		printf("Enter an integer(q to qiut):\n");
	}
	printf("Done.\n");
	return 0;
}
void to_binary(unsigned long n)
{
	int m;	
	if (n >= 2)
	{
		m = n % 2;		
		to_binary(n / 2);
		printf("%d", m);
	}
	else
		printf("%d",n);
	return;
}		

	不用递归，能否实现这种转换？当然可以，但是由于这种算法要首先计算最后一位二进制数，
	所以在显示结果之前必须把所有的位数都储存在别处（如数组）15章会介绍；


9.3.5	递归的优缺点
	递归既有优点也有缺点，优点是为某些编程问题提供了最简单的解决方案；
	缺点是一些递归算法会快速消耗计算机的内存资源，另外递归不妨版阅读和维护；
	例如：
	斐波那契数列的定义如下：第一个和第二个数字都是1，而后续的每个数字都是前两个数字之和；
	如该数列的前几个数为：1、1、2、3、5、8、13......
	下面我们要创建一个函数，接受正整数n，返回相应的斐波那契数值
	首先来看递归，递归提供一个简单的定义，如果把函数名命名为Fibonacci()，那么如果n是1或2，
	Fibonacci(n)应返回1；对于其他值，则应返回Fibonacci(n-1)+Fibonacci(n-2);

	unsigned long Fibonacci(unsigned n)
	{
		if(n>2)
			return Fibonacci(n-1)+Fibonacci(n-2);
		else
			return 1;
	}

	这个递归函数只是重述了数学定义的递归。
	该函数使用了双递归，即函数每一级递归都要调用本身两次，这暴露了一个问题；
	
	为了说明这个问题，假设调用Fibonacci(40)；这是第一级递归调用，将创建一个变量n
	然后在该函数中要调用Fibonacci()两次，在第2级递归中要分别创建两个变量n；
	到下一级调用又要进行两次调用，由于每一级变量都是上一级递归的2倍，
	所有变量的数量呈指数增长！
	在第五章介绍过一个计算小麦粒数的例子，指数增长很快会产生非常大的值，
	在本例中，指数增长的变量很快就消耗掉计算机的大量内存，很可能导致程序崩溃

	所有的C函数皆平等
	程序中每个C函数都是平等的，每个函数都可以调用其他函数，也被其他函数调用；
	main()函数比较特殊，当它与程序中的其他函数放在一起时，最开始执行的是main()函数的第一条语句
	但它其实也可以被自己或其他函数递归调用――尽管很少这样做。

	
9.4	编译多源代码文件的程序
	使用多个函数最简单的方法是把它们都放在同一个文件中，
	然后像编译只有一个函数的文件那样编译该文件即可，其他方法因操作系统而异；下面举例说明

9.4.1	UNIX
	假定在NUIX系统安装了UNIX C编译器cc（最初的cc已经停用，但许多NUIX给cc改了名如gcc或clang）
	假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译并生成一个名为a.out的可执行文件：
	cc file1.c file2.c
	另外，还生成两个名为file1.o和file2.o的目标文件；
	如果后来改动了file1.c，而file2.c不变，可以使用下面命令编译第一个文件，并与第2个文件的目标代码合并：
	cc file1.c file2.o
	UNIX系统的make命令可自动管理多文件程序；
	注意OS X的Terminal工具可以打开UNIX命令环境但是必须先下载命令行编译器（gcc和clang）

9.4.2	Linux与UNIX相同；
	假定在Linux系统安装了GUN C编译器gcc
	假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译并生成一个名为a.out的可执行文件：
	gcc file1.c file2.c
	另外，还生成两个名为file1.o和file2.o的目标文件；
	如果后来改动了file1.c，而file2.c不变，可以使用下面命令编译第一个文件，并与第2个文件的目标代码合并：
	gcc file1.c file2.o

9.4.3	DOS命令行编译器
	绝大多数DOS命令行编译器的工作原理和UNIX的cc命令类似,只不过使用不同的名称而已；
	其中对象文件的扩展名是.obj,而不是.o
	一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码的中间文件

9.4.4	Windows和苹果的IDE编译器
	Windows和Macintosh系统使用的集成开发环境中的编译器是面向项目的；
	项目描述的是特定程序使用的资源，资源包括源代码文件；
	这种IDE中的编译器要创建项目来运行单文件程序；
	对于多文件程序，要使用相应的菜单命令，把源代码文件加入一个项目中。
	要确保所有的源代码文件都在项目列表中列出；
	许多IDE都不用在项目列表中列出头文件，因为项目只管理使用的源代码文件；
	源代码文件中的#include指令管理该文件中使用的头文件，但是Xcode要在项目中添加头文件

9.4.5	使用头文件
	如果把main()放在第1个文件中，把函数定义放在第2个文件中，
	那么第1个文件仍然要使用函数原型；
	把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型；
	C标准库就是这样做的；
	例如把I/O函数原型放在stdio.h中，把数学函数原型放在math.h中；
	你也可以用自定义的函数文件；

	另外，程序中经常用C预处理器定义符号常量；这种定义只储存了那些包含#define指令的文件；
	如果把程序的一个函数放进一个独立的文件中，你也可以使用#define指令访问每个文件；
	最直接的方法是在每个文件中再次输入指令，但这个方法耗时又容易出错，
	另外还会有维护的问题：如果修改了#define定义的值，就必须在每个文件中修改；

	更好的做法是，把#define指令放进头文件，然后在每个源文件中使用#include指令包含该文件即可

	总之，把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯；
	我们考虑一个例子：
	假如要管理4加酒店的客房服务，每家酒店的房价不同，但是每家酒店所有房间的折扣价格相同；
	对于预定住宿多天的客户，第2天房费是第1天的95%，第3天是第2天的95%，以此类推
	设计一个程序让用户指定酒店和入住天数，然后计算并显示总费用
	同时，程序要实现一份菜单，允许用户反复输入数据，除非用户选择退出

//usehotel.c
#include<stdio.h>
#include"hotel.h"//定义符号常量，声明函数

int main(void)
{
	int nights;
	double hotel_rate;
	int code;

	while ((code = menu()) != QUIT)
	{
		switch (code)
		{
		case 1:hotel_rate = HOTEL1;
			break;
		case 2:hotel_rate = HOTEL2;
			break;
		case 3:hotel_rate = HOTEL3;
			break;
		case 4:hotel_rate = HOTEL4;
			break;
		default:hotel_rate = 0.0;
			printf("Oops!\n");
			break;
		}
		nights = getnights();
		showprice(hotel_rate, nights);
	}
	printf("Thank you and goodbye.\n");
	return 0;
}

	
//hotel.c
#include<stdio.h>
#include"hotel.h"
int menu(void)
{
	int code, status;
	printf("\n%s%s\n", STARS, STARS);
	printf("Enter the number of the desired hotel:\n");
	printf("1)Fairfield Arms		2)Hotel Olympic\n");
	printf("3)Chertworthy Plaza		4)The Stockton\n");
	printf("5)quit\n");
	printf("%s%s\n", STARS, STARS);
	while ((status = scanf_s("%d", &code)) != 1 || (code < 1 || code>5))
	{
		if (status != 1)
			scanf_s("%*s");//处理非整数输入
		printf("Enter an integer from 1 to 5,Please.\n");
	}
	return code;
}
int getnights(void)
{
	int nights;
	printf("How many nights are needed?\n");
	while (scanf_s("%d", &nights) != 1)
	{
		scanf_s("%*s");
		printf("Please enter an integer,such as 2.\n");
	}
	return nights;
}
void showprice(double rate, int nights)
{
	int n;
	double total = 0.0;
	double factor = 1.0;
	for (n = 1; n <= nights; n++, factor *= DISCOUNT)
		total += rate * factor;
	printf("The total cost will be $%0.2f.\n", total);
}


//hotel.h
#define QUIT 5
#define HOTEL1 180.00
#define HOTEL2 225.00
#define HOTEL3 255.00
#define HOTEL4 355.00
#define DISCOUNT 0.95
#define STARS "***********************************"

//显示选择列表
int menu(void);

//返回预定天数
int getnights(void);

//根据费率、入住天数计算费用，并显示结果
void showprice(double rate, int nights);



	第1个程序包含main()函数，提供整个程序的组织结构；
	第2个程序包含支持的函数，我们将这些函数在独立的文件中；
	第3个程序列出来一个文件头，包含了该程序所有源文件中使用的自定义符号和函数原型
	在UNIX和DOS环境中，#include"hotels.h"指令中的双引号表明被包含的文件位于当前目录中
	如果使用IDE，需要知道如何把头文件合并成一个项目；

	顺带一提，该程序中有几处编写的很巧妙，
	尤其是menu()和getnights()函数通过测试scanf()的返回值来跳过非数值数据，
	而且调用scanf("%*s")跳至下一个非空白字符；
	注意menu()函数中是如何检查非数值输入和超出范围的数据：
	while ((status = scanf_s("%d", &code)) != 1 || (code < 1 || code>5))
	以上代码段利用了C语言的两个规则：
	从左往右对逻辑表达式求值；一旦求职结果为假，立即停止求值；
	只有scanf()成功读入一个整数值后，才会检查code的值

	用不同的函数处理不同的任务时应检查数据的有效性。


9.5	查找地址：&运算符

	指针是C语言最重要的概念之一，用于储存变量的地址，如scanf()函数中就使用地址作为参数
	概括的说，如果主调函数不使用return返回的值，则必须通过地址才能修改主调函数中的值；
	一元&运算符给出变量的储存地址；
	如果pooh是变量名，&pooh就是变量的地址；可以把地址看作是变量在内存中的位置；假设
	pooh=24
	假设pooh的储存地址是0B76（PC地址通常用16进制形式表示），那么：
	printf("%d%p",pooh,&pooh);
	将输出如下内容：
	24 0B76

	示例程序使用了地址运算符查看不同函数中的同名变量分别储存在什么位置：
	#include<stdio.h>
	void mikado(int);
	int main(void)
	{
		int pooh = 2, bah = 5;//main()函数局部变量
		printf("In main(),pooh=%d and &pooh =%p\n",pooh,&pooh);
		printf("In main(),bah=%d and &bah =%p\n",bah,&bah);
		mikado(bah);	
		return 0;
	}
	void mikado(int bah)
	{
		int pooh = 2;//mikado()函数的局部变量
		printf("In mikado(),pooh=%d and &pooh =%p\n",pooh,&pooh);
		printf("In mikado(),bah=%d and &bah =%p\n",bah,&bah);
	}


	输出结果：
	In main(),pooh=2 and &pooh =0000008FBE0FFBE4
	In main(),bah=5 and &bah =0000008FBE0FFC04
	In mikado(),pooh=10 and &pooh =0000008FBE0FFAC4
	In mikado(),bah=2 and &bah =0000008FBE0FFBC0
	
	每个十六进制数对应4位，该例显示16个十六进制，对应64位地址；
	该例说明了什么？
	①首先，两个pooh的地址不同，两个bah的地址也不同；计算机将它们看出是4个独立的变量；
	②其次，主调函数调用时候只是把实际参数传递给了被调函数的形参，
	即main()中的pooh的值2，传递给mikado()中的bah，该传递只传递值2，变量并未改变；

	我们强调第二点是因为这并不是在所有语言中都成立，例如FORTRAN中，子例程会影响主调例程的原始变量
	子例程的变量名可能与原始变量不同，但是它们的地址相同；
	但是在C语言中不是这样，每个C函数都有自己的变量，可以防止原始变量被被调函数中的副作用意外修改；
	然而正如下节所述，这也带来了一些麻烦：
	
	
9.6	更改主调函数中的变量
	
	有时候需要在一个函数中更改其他函数的变量。例如普通的排序任务中交换两个变量的值；
	假设要交换两个变量x和y的值，简单的思路是：
	x=y;
	y=x;
	这完全不起作用，因为执行到第二行时，x的原始值已经被y的原始值替换了，因此要多写一行代码：
	temp=x;
	x=y;
	y=temp;
	上面3行代码可以实现交换值的功能，可以编写一个函数并构造一个驱动程序来测试；

	#include<stdio.h>
	void change(int, int);
	int main(void)
	{
		int x, y;
		x = 10, y = 20;
		printf("x=%d,y=%d\n",x,y);
		change(x, y);
		printf("x=%d,y=%d", x, y);
		return 0;
	}
	void change(int a, int b)
	{
		int temp;
		temp = a;
		a = b;
		b = temp;
		return;
	}
	
	运行结果：
	x=10,y=20
	x=10,y=20

	两个变量值按照显示来看并未交换！我们添加一些输出来检查问题出在哪：
	#include<stdio.h>
	void change(int, int);
	int main(void)
	{
		int x, y;
		x = 10, y = 20;
		printf("x=%d,y=%d\n",x,y);
		change(x, y);
		printf("x=%d,y=%d\n", x, y);
		return 0;
	}
	void change(int a, int b)
	{
		printf("2#:a=%d,b=%d\n", a, b);//交换前实参传递给形参的值
		int temp;
		temp = a;
		a = b;
		b = temp;
		printf("2#:a=%d,b=%d\n", a, b);//交换后返回的值
		return;
	}

	
	运行结果：
	x=10,y=20
	2#:a=10,b=20
	2#:a=20,b=10
	x=10,y=20

	看来change()没有问题，它交换了a和b的值，
	问题出在把结果传回main()时，change()使用的变量不是main()的变量
	因此交换a和b的值对x和y的值没有影响。
	是否能用return语句把值传回main()？
	return(a)
	x=change(x,y);
	这只能改变x的值，而y的值仍旧没改变，用return语句只能把被调函数中一个值传回主调函数
	现在要传回两个值，可以使用指针；

9.7	指针简介

	什么是指针？
	从根本上看，指针是一个值为内存地址的变量(或数据对象)；
	正如char类型的变量值是字符，int类型的变量值是整数，指针变量的值是地址；

	本章将介绍如何把指针作为函数参数使用，以及为何要这样用
	假设一个指针变量名是ptr，可以编写如下语句：
	ptr=&pooh；	//把pooh的地址赋值给ptr
	
	对于这条语句，我们说ptr指向pooh；
	ptr和&pooh的区别是ptr是变量，而&pooh是常量
	或者，ptr是可修改的左值，而&pooh是右值，还可以吧ptr指向别处：
	ptr=&bah；	//把ptr指向bah，而不是pooh

	现在ptr的值是bah的地址

	要创建指针变量，先要声明指针变量的类型。假设想把ptr声明为int类型变量地址的指针
	就要用到下面介绍的新运算符*

9.7.1	间接运算符*

	假设已知ptr指向bah，如下所示:
	ptr=&bah;
	然后使用间接运算符*找出储存在bah中的值；
	该运算有时也称为解引用运算符，不要把间接运算符和二元乘法运算符混淆；
	虽然它们使用的符号相同，但语法功能不同
	val=*ptr；	//找出ptr指向的值
	
	{ptr=&bah;val=*ptr}两个语句放一起等于
	val=bah;
	
	由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能；

9.7.2	声明指针
	int * pi		//pi是指向int类型变量的指针
	char *pc		//pc是指向char类型变量的指针
	float *pf,*pg;	//pf、pg都是指向float类型变量的指针
	
	类型说明符表明了指针所指向对象的类型，星号*表明声明的变量是一个指针；
	int *pi;声明的意思是pi是一个指针，*pi是int类型

	pc指向的值(*pc)是char类型，pc本身是什么类型？我们描述它的类型是 指向char类型的指针；
	pc的值是一个地址。在大部分系统内部，该地址由一个无符号整数表示，但是指针不是整数类型；
	一些处理整数的操作不能用来处理指针，反之亦然。
	例如可以把两个整数相乘，但是不能把两个指针相乘；
	所以指针实际上是一个新类型，ANSIC专门为指针提供了%p格式转换说明

9.7.3	使用指针在函数间通信

	本节着重介绍如何使用指针解决函数间的通信问题
		
	#include<stdio.h>
	void change(int *a, int *b);
	int main(void)
	{
		int x, y;
		x = 10, y = 20;
		printf("x=%d,y=%d\n",x,y);
		change(&x, &y);
		printf("x=%d,y=%d\n", x, y);
		return 0;
	}
	void change(int *a, int *b)
	{	
		int temp;
		temp = *a;
		*a = *b;
		*b = temp;	
		return;
	}

	分析函数：
	首先看函数调用
	change(&x, &y);
	该函数传递的不是x和y的值，而是它们的地址；
	因为x、y是整数
	所以a和b是指向整数的指针，所以其声明如下：
	void change(int *a, int *b);
	
	接下来在函数中声明了一个交换值时必需的临时变量
	int temp；
	通过temp=*a把x的值储存在temp中；
	记住，a的值是&x，所以a指向x，这意味着*a可以表示x的值；
	所以不要写成temp=a;
	因为这条语句赋给temp的是x的地址，而不是x的值
	函数要交换的是x和y的值，而不是它们的地址；

	与此类似，把y的值赋给x；*a=*b;
	这条语句相当于x=y;

	
	我们总结一下该程序做了什么
	我们需要一个函数交换x和y的值；把x和y的地址传递给函数，我们让chang()访问这两个地址；
	使用指针和*运算符，该函数可以访问储存在这些位置的值并改变它们

	一般而言，可以把变量相关的两类信息传递给函数：
	①传递值    如	function1(x);
	②传递地址如	function2(&x);

	第一种形式要求函数定义中的形式参数必须是一个与x的类型相同的变量；function1(int num);
	第二种形式要求函数定义中的形式参数必须是一个指向正确类型的指针；function2(int *ptr);

	如果要计算或处理值，那么用第一种形式的函数调用
	如果要在被调函数中改变主调函数的变量，则使用第二种形式的函数调用
	我们用过的scanf()函数就是这样，当程序要读入一个变量时，调用的是scanf("%d",&num);
	scanf()读取一个值，然后把该值储存到指定的地址上。

	
	变量：名称、地址和值
	变量的名称和变量的值之间关系密切。
	编写程序时，可以认为变量有两个属性，名称和值；(还有其他性质如类型，暂不讨论)
	计算机编译和加载程序后，认为变量也有两个属性，地址和值，地址就是变量在计算机内部的名称

	在许多语言中，地址都归计算机管理，对程序员隐藏，然而在C中，
	①可以通过&运算符访问地址
	②可以通过*运算符获得地址上的值
	
	普通变量把值作为基本量，把地址作为通过&运算符获得的派生量，
	而指针变量把地址作为基本了，把值通过*运算符获得的派生量；

	使用&和*和指针可以操纵地址和地址上的内容；

	
	小结：函数
	①形式：

	典型的ANISC 函数的定义形式为：

	返回类型 名称(形参声明列表)
	函数体

	形参声明列表是用逗号隔开的一系列变量声明，除形参变量外，函数的其他变量均在函数体花括号内声明
	示例：
	int diff(int x,int y)	//形参x,y;待主调函数实参传入
	{
		int z;	//声明局部变量
		z=x-y;
		return z;	//返回一个值，类型int
	}

	②传递值：
	实参用于把值从主调函数传递给被调函数，如果变量a和b的值分别是5和2，那么调用diff(a,b)；
	把5和2分别传递给变量x和y；
	5和2称为实际参数，diff()函数定义中的变量x和y称为形式参数；
	使用关键字return把被调函数中的一个值传回主调函数；
	被调函数一般不会改变主调函数中的变量，如果要改变，应使用指针作为参数；
	
	③函数的返回类型
	函数返回值的类型；如果返回值与声明的返回类型不匹配，返回值将被转换成函数声明的返回类型

	④函数签名：
	函数的返回类型和形参列表构成了函数签名；
	因此函数签名制定了传入函数的值和函数返回值的类型(即规定输入和输出函数的值的类型)
	
	
9.8	关键概念
	如果让一个函数处理一个任务，程序会更好理解，更方便调试；
	要理解函数是如何把信息从一个函数传递到另一函数，也就是理解函数参数和返回值的工作原理
	
	另外，要明白函数形参和其他局部变量都属于函数私有，因此声明在不同函数中的同名变量是完全不同的变量
	而且函数无法直接访问其他函数中的变量，这种限制保护了数据的完整性
	但是当确实需要在函数中访问另一个函数的数据时，可以把指针作为函数的参数；

9.10	复习题
	1.实际参数和形式参数区别：一个在主调函数，一个在被调函数；实参传递数值给形参；

	2.根据下面各函数的描述，分别编写它们的ANSIC函数头；不需写函数体
	①double()接受一个int类型的参数，打印若干个(参数指定数目)个0
		//void double(int);
	②gear()接受两个int类型的参数，返回int类型的值
		//int gear(int,int);
	③guess()不接受参数，返回一个int类型的值
		//int guess(void);
	④stuff_it()接受一个double类型的值和double类型的变量地址，把第1个值储存在指定位置
		//void stuff_it(double n,double *m);

	3.根据下面的描述，分别编写它们ANSIC函数头
	①n_to_char()接受一个int类型的参数，返回一个char类型的值
		//char n_to_char(int);
	②digit()接受一个double类型的参数和一个int类型的参数，返回一个int类型的值
		//int digit(double,int);
	③which()接受两个可储存double类型变量的地址，返回一个double类型的地址
		//double *which(double *n,double *m);
	④random()不接受参数，返回一个int类型的值
		//int random(void)
	
	4.设计一个函数，返回两个整数之和
	int backint(int n,int m)
	{
		return n+m;
	}
	
	5如果把复习题4改成返回两个double类型的值之和，应该如何修改
	double backint(double n,double m)
	{
		return n+m;
	}
			
	6.设计一个名为alter()的函数，接受两个int类型的变量x和y，把它们的值分别改成之和和之差
	void alter(int *x,int *y)
	{
		int temp;
		temp=*x;
		*x=*x+*y;
		*y=temp-*y;
		return;
	}
	
	8.编写一个函数，返回3个整数参数中的最大值
	int imax(int x, int y, int z)
	{
		int m;
		m=(x < y) ? y : x;
		if (m < z)
			m = z;
		return m;
	}
	
	9.给定下面的输出：
	Please choose one of the following:
	1)copy files	2)move files
	3)remove files	4)quit
	Enter the number of your choice:
	
	①编写一个函数，显示一份有4个选项的菜单，提示用户进行选择
	②编写一个函数，接受两个int类型的参数分别表示上下限；
	该函数从用户的输入中读取整数，如果整数超出规定上下限，函数再次打印菜单提示用户输入；
	然后获取一个新值，如果用户输入的整数在规定范围内，该函数则把该整数返回主调函数；
	如果用户输入一个非整数字符，该函数返回4；
	③使用上面两个函数编写一个最小型的程序，不需要实现菜单中各选择项的功能，但要获取有效响应；

#include<stdio.h>
void menu(void);
int input(int, int);
int main(void)
{
	int a, b,rep;
	a = 1;
	b = 4;
	menu();
	rep=input(a, b);	
	while (rep != b)
	{
		switch (rep)
		{
		case 1:printf("copy files.\n"); menu(); rep = input(a, b); continue;
		case 2:printf("move files.\n"); menu(); rep = input(a, b); continue;
		case 3:printf("remove files.\n");menu(); rep = input(a, b); continue;
		default:printf("Error!\n"); break;
		}
	}
	printf("Bye.\n");
	return 0;
}
void menu(void)
{
	printf("Please choose one of the following:\n");
	printf("1)copy files	2)move files\n3)remove files	4)quit\n");
	printf("Enter the number of your choice :\n");
}
int input(int x, int y)
{
	int choice;	
	while (1) 
	{
		if (scanf_s("%d", &choice) != 1)
		{
			while (getchar() != '\n')
				continue;
			choice = 4;
			break;
		}
		else if (choice < 1 || choice>4)
		{
			printf("It's not a ringht choice,try again.\n");			
			menu();			
			continue;
		}
		else
			break;
	}
	return choice;
}

	
	
	10.编程练习
	1.设计一个函数min(x,y),返回两个double类型的较小值；并在驱动程序中测试该函数；
	#include<stdio.h>
	double min(double x, double y){return (x < y) ? x : y;}
	int main(void)
	{
		double a = 1.25, b = 2.6;
		printf("%g", min(a, b));
		return 0;
	}

	2.设计一个函数chline(ch,i,j),打印指定的字符j行i列，并在驱动程序中测试该函数；
	#include<stdio.h>
	void chline(char, int, int);
	int main(void)
	{
		chline('*', 2, 5);
		return 0;
	}
	void chline(char ch, int x, int y)
	{
		int i,k;
		for (i = 0; i < x; i++)
		{
			for (k=0;k<y;k++)
				printf("*");
			printf("\n");
		}
	}

	
	3.编写一个函数，接受3个参数；一个字符和两个整数。字符参数是待打印字符，
	第一个整数指定一行中打印字符的次数，第二个整数指定打印行数；
	编写一个调用该函数的程序；
	#include<stdio.h>
	void chline(char, int, int);
	int main(void)
	{
		chline('*', 2, 5);
		return 0;
	}
	void chline(char ch, int x, int y)
	{
		int i,k;
		for (i = 0; i < y; i++)
		{
			for (k=0;k<x;k++)
				printf("*");
			printf("\n");
		}
	}

	
	4.两数的调和平均数这样计算：
	先得到两数的倒数，然后计算两个倒数的平均值，最后计算结果的倒数；
	编写一个函数，接受两个double类型的参数，返回这两个参数的调和平均数
	#include<stdio.h>
	double mean(double x, double y);
	int main(void)
	{	
		double a = 10.0;
		double b = 30.0;	
		printf("%g", mean(10, 30));
		return 0;
	}
	double mean(double x, double y)
	{	
		double result;
		result = 2 / ((1 / x) + (1 / y));
		return result;
	}

	5.编写并测试一个函数，large_of()，该函数把两个double类型变量的值替换成较大的值；
	例如，large_of(x,y)会把x和y中较大的值重新赋给两个变量。

	#include<stdio.h>
	double large_of(double, double);
	int main(void)
	{	
		double a = 100.0;
		double b = 30.0;	
		a = large_of(a,b);
		b = large_of(a, b);
		printf("a=%g,b=%g", a, b);
		return 0;
	}
	double large_of(double x, double y)
	{		
		return (x > y) ? x : y;	
	}

	****************************************************************
	#include<stdio.h>
	void large_of(double *x, double *y);
	int main(void)
	{	
		double a = 100.0;
		double b = 300.0;	
		large_of(&a, &b);
		printf("a=%g,b=%g", a, b);
		return 0;
	}
	void large_of(double *x, double *y)
	{			
		if (*x > *y)
			*y = *x;
		else
			*x = *y;
	}

	
	
	6.编写并测试一个函数，该函数以3个double变量的地址作为参数，
	把最小值放入第1个变量，中间值放入第2个变量，最大值放入第3个变量
#include<stdio.h>
void sorting(double *x, double *y,double *z);
int main(void)
{	
	double a = 1.0;
	double b = 3.0;	
	double c = 2.0;
	sorting(&a, &b,&c);
	printf("a=%g,b=%g,c=%g", a, b,c);
	return 0;
}
void sorting(double *x, double *y,double *z)
{			
	double max,mid,min;
	if (*x > *y)
	{
		max = *x;
		if (*y > *z)
		{
			mid = *y;
			min = *z;
		}
		else
		{
			mid = *z;
			min = *y;
		}
	}
	else
	{
		max = *y;
		if (*x > *z)
		{
			mid = *x;
			min = *z;
		}
		else
		{
			mid = *z;
			min = *x;
		}
	}
	if (*z > max)
	{
		max = *z;
		if (*x > *y)
		{
			mid = *x;
			min = *y;
		}
		else
		{
			mid = *y;
			min = *x;
		}
	}
	*x = min;
	*y = mid;
	*z = max;
}

*****************************************************
#include<stdio.h>
void sorting(double *x, double *y,double *z);
int main(void)
{	
	double a = 3.0;
	double b = 2.0;	
	double c = 1.0;
	sorting(&a, &b,&c);
	printf("a=%g,b=%g,c=%g", a, b,c);
	return 0;
}
void sorting(double *x, double *y,double *z)
{			
	double max,mid,min;
	if (*x >= *y&&*x >= *z)
	{
		max = *x;
		mid = (*y > *z) ? *y : *z;
		min = (*y > *z) ? *z : *y;
	}
	if (*y >= *x&&*y >= *z)
	{
		max = *y;
		mid = (*x > *z) ? *x : *z;
		min = (*x > *z) ? *z : *x;
	}
	if (*z >= *x&&*z >= *y)
	{
		max = *z;
		mid = (*x > *y) ? *x : *y;
		min = (*x > *y) ? *y : *x;
	}
	*x = min;
	*y = mid;
	*z = max;
}



	7.编写一个函数，从标准输入中读取字符，直到遇到文件结尾。程序要报告每个字符是否是字母。
	如果是，还要报告该字母在字母表中的数值位置，例如，c和C在字母表中的位置都是3.
	合并一个函数，以一个字符作为参数，如果该字符是一个字母则返回一个数值位置，否则返沪-1

#include<stdio.h>
#include<ctype.h>
char input(void);
void rep(char);
int main(void)
{
	input();
	return 0;
}
char input(void)
{
	char ch;	
	while ((ch = getchar()) != EOF)
	{			
		if (ch == ' ' || ch == '\t' || ch == '\n')
			continue;
		if ((isupper(ch) == 1))
		{
			putchar(ch);
			printf(" is a alpha.\n");
			printf("in the alphabet,the number is %d.\n", ch - 64);
		}
		else if ((islower(ch) == 2))
		{
			putchar(ch);
			printf(" is a alpha.\n");
			printf("in the alphabet,the number is %d.\n", ch - 96);
		}
		else
		{
			putchar(ch);
			printf(" is not a alpha.\n");
		}
		rep(ch);
	}
	return 0;
}
void rep(char ch)
{
	if ((isalpha(ch)) != 0)
		printf("And it's ASCII number is:%d\n", ch);
	else
		printf("-1\n");
}



	8.在第六章的程序清单6.20中，pow()函数返回一个double类型的正整数次幂，改进该函数，
	使其能正确计算负幂，另外函数需要处理0的任何次幂都是0，任何数的0次幂都为1
	（函数应报告0的0次幂未定义，因此把该值处理为1）
	要使用一个循环，并在程序中测试该函数

#include<stdio.h>
double power(double n, int p);	
int main(void)
{
	double x, xpow;
	int exp;
	printf("Enter a number and the positive integer power");
	printf("to which\nthe number will be raised.(q to quit).\n");
	while (scanf_s("%lf %d", &x, &exp) == 2)
	{
		if (x == 0&&exp==0)
		{
			printf("it's undefined,the value is treated as 1\n");
			printf("Enter next pair of numbers or q to quit.\n");
			continue;
		}
		xpow = power(x, exp);
		printf("%.3g to the power %d is %.5g\n", x, exp, xpow);
		
		printf("Enter next pair of numbers or q to quit.\n");
	}
	printf("hope you enjoyed this power trip--bye!\n");
	return 0;
}
double power(double n, int p)	
{
	double pow = 1;	
	int i;	
	for (i = 1; i <= p; i++)
		pow *= n;
	if (p < 0)
		pow = pow / power(n, -p);		
	return pow;
}



	9.使用递归函数重写练习8
	
	double power(double n, int p)
	{
		double pow=1;
		if(p>0)
			pow=n*power(n, p-1);	
		if(p<0)
			pow = 1 / power(n, -p);		
		return pow;
	}

	
	
	10.为了让程序9.8中的to_binary函数更通用，编写一个to_base_n()函数；
	该函数接受两个在2-10进制范围内的参数，然后以第二个参数中指定的进制打印第一个参数的值
	例如to_base_n(129,8)显示的结果为201，也就是129的八进制数；并测试该函数。

#include<stdio.h>
void to_base_n(unsigned long n,int m);
void to_binary(unsigned long n);	
int main(void)
{
	unsigned long num;
	int base;
	printf("Enter an integer,and the number of base(2.8.10.16).(q to qiut):\n");
	while ((scanf_s("%lu%d", &num,&base)) == 2)
	{
		printf("Binary equivalent:");
		to_base_n(num,base);
		putchar('\n');
		printf("Enter an integer(q to qiut):\n");
	}
	printf("Done.\n");
	return 0;
}
void to_binary(unsigned long n)
{
	int m;
	if (n >= 2)
	{
		m = n % 2;
		to_binary(n / 2);
		printf("%d", m);
	}
	else
		printf("%d",n);
	return;
}
void to_base_n(unsigned long n, int m)
{
	switch (m)
	{
	case 2:to_binary(n); return;
	case 8:printf("%o", n); return;
	case 10:printf("%d", n); return;
	case 16:printf("%x", n); return;
	default:printf("unsupported,try again.\n"); return;
	}
}

************************************************************************
#include<stdio.h>
void to_binary(unsigned long n,int m);	
int main(void)
{
	unsigned long num;
	int base;
	printf("Enter an integer,and the number of base(2~10);(q to qiut):\n");
	while ((scanf_s("%lu%d", &num,&base)) == 2)
	{
		printf("Binary equivalent:");
		to_binary(num,base);
		putchar('\n');
		printf("Enter an integer(q to qiut):\n");
	}
	printf("Done.\n");
	return 0;
}
void to_binary(unsigned long n,int m)
{
	unsigned temp;
	if (n >= m)
	{
		temp = n % m;
		to_binary(n / m,m);
		printf("%d", temp);
	}
	else
		printf("%d",n);
	return;
}





	11.编写并测试Fibonacci()函数，该函数用循环替代递归计算斐波那契数列；	
	1，1，2，3，5，8，13，21......

#include<stdio.h>
void Fibonacci(void);
int main(void)
{
	Fibonacci();
	printf("Bye.\n");
	return 0;
}
void Fibonacci(void)
{
	unsigned long n, i, sum, k, m;
	printf("Enter the digit number of Fibonacci.\n");
	printf("Enter q to quit\n");
	while ((scanf_s("%d", &n) > 0))
	{
		sum = 0;
		k = 1;
		m = 0;
		if (n > 1)
			for (i = 1; i < n; i++)
			{
				sum = sum + k;
				k = k + m;
				m = sum - k;
			}
		if (n == 1)
			sum = 1;
		if (n == 0)
		{
			printf("wrong number.try again.\n");
			continue;
		};
		printf("the Fibonacci number is:%lu\n", sum);
		printf("Enter the digit number of Fibonacci.\n");
		printf("Enter q to quit\n");
		continue;
	}
	return;
}

********************************************************************************
#include<stdio.h>
unsigned long Fibonacci(unsigned long);
int main(void)
{
	unsigned long num,result;
	printf("Enter the digit number of Fibonacci.\n");
	printf("Enter q to quit\n");
	while ((scanf_s("%lu", &num)) == 1)
	{
		if (num == 0) 
		{ 
			printf("wrong number.try again.\n");
			continue;
		}			
		result = Fibonacci(num);		
		printf("the Fibonacci number is:%lu\n", result);
		printf("Enter the digit number of Fibonacci.\n");
		printf("Enter q to quit\n");
		continue;
	}	
	printf("Bye.\n");
	return 0;
}
unsigned long Fibonacci(unsigned long n)
{
	unsigned long i, sum, k, m;	
		sum = 0;
		k = 1;
		m = 0;
		if (n > 1)
			for (i = 1; i < n; i++)
			{
				sum = sum + k;
				k = k + m;
				m = sum - k;
			}
		else
			sum = 1;		
		return sum;
}
	
	
		
	
	


【第10章】数组和指针
	关键字 static
	运算符 & *(一元)
	如何创建并初始化数组
	指针和数组的关系
	编写处理数组的函数
	二维数组

	
10.1	数组
	数组由数据类型相同的一系列元素组成；
	需要使用数组时，通过声明告诉编译器数组内含多少元素及元素类型
	编译器根据这些信息正确的创建数组；普通变量可以使用的类型，数组元素都可以用，如：
	float candy[365];	//内含365个float类型元素的数组
	char code[12];	//内含12个char类型元素的数组
	int states[50];	//内含50个int类型元素的数组

	[]方括号表明candy、code和states都是数组，方括号中的数字表明数组中的元素个数；
	要访问数组中的元素，通过使用数组下标(索引)表示数组中的各元素；
	数组元素的编号从0开始，所以candy[0]表示candy数组的第1个元素，candy[364]表示最后一个元素；
	
	
10.1.1	初始化数组
	数组通常被用来储存程序需要的数据，例如一个内含12个整数元素的数组可以储存12个月的天数；
	在这种情况下，在程序一开始就初始化数组比较好；下面介绍初始化数组的方法

	只储存单个值的变量，有时也称为标量变量；如
	int a=1;
	C使用新的语法来初始化数组，如下所示：
	int powers[8]={1,2,4,6,8,16,32,64};
	
	如上所示，用以逗号分隔的值列表(用花括号括起来)来初始化数组，各值之间用逗号分隔。
	在逗号和值之间可以使用空格。
	有时需要把数组设置为只读，这样程序只能从数组中检索值，不能把新值写入数组，
	要创建只读数组，应该用const声明和初始化数组，如：
	const int days[3]={31,28,26};
	这样修改后程序在运行过程中就不能修改该数组中的内容；
	和普通变量一样，应该使用声明来初始化const数据，因为一旦声明为const，便不能再给它赋值。

	使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它赋初值。
	编译器使用的值是内存相应位置上现有的值。
	
	储存类别警告
	数组和其他变量类似，可以把数组创建成不同的储存类别
	本章描述的数组属于自动存储类别；
	意思是这些数组在函数内部声明，且声明时未使用关键字static。
	不同的储存类别有不同的属性，对于一些其他储存类别的变量和数组，如果在声明时未初始化，
	编译器会自动把它们的值设置为0；

	初始化列表中的项数与数组的大小一致，如果不一致会怎样？
	①部分初始化：
	当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0；
	如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；
	但是如果部分初始化数组，剩余的元素会被初始化为0
	
	②自动计数匹配：
	当初始化列表的项数多余数组元素个数，编译器会将它视为错误；
	其实可以省略方括号内的数字，让编译器自动匹配数组大小和初始化列表中的项数：

	#include<stdio.h>
	int main(void)
	{
		const int days[] = { 31,28,31,30 };
		int i;
		for (i = 0; i < sizeof days / sizeof days[0]; i++)
			printf("month %d has %d days.\n", i + 1, days[i]);
		return 0;
	}
	
	运行结果：
	month 1 has 31 days.
	month 2 has 28 days.
	month 3 has 31 days.
	month 4 has 30 days.
	
	如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小
	注意for循环中的测试条件；
	由于人工计算容易出错，所以让计算机来计算数组的大小。
	sizeof运算符给出它的运算对象的大小(以字节为单位)，所以sizeof days是整个数组的字节大小；
	而sizeof day[0]是数组中一个元素的字节大小，整个数组字节大小除以单个元素的字节大小就是元素个数
	(前提是每个元素字节大小一致，但是数组在分配同类型元素时分配的内存空间，每个元素是一致的)
	自动计数的弊端：无法察觉初始化列表中的项数是否有遗漏。只按照现有元素统计元素个数；	

10.1.2	指定初始化器
	C99增加了一个新特性，指定初始化器
	利用该特性可以初始化指定的数组元素，例如只初始化数组中的最后一个元素：
	传统的语法必须初始化最后一个元素之前的所有元素才能初始化它：
	int art[6]={0,0,0,0,0,212};
	指定初始化器可以在初始化列表中使用带方括号的下标指明待初始化的元素：
	int art[6]={[5]=212};	
	对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0；

	#include<stdio.h>
	#define months 12
	int main(void)
	{
		int days[months] = { 31,28,[4]=31,30,31,[1]=29 };
		int i;
		for (i = 0; i < months; i++)
			printf("%2d	%2d\n", i + 1, days[i]);
		return 0;
	}
	
	运行结果如下：

	 1      31
	 2      29	//初始化中days[1]=28;又被指定初始化器初始化为[1]=29②
	 3       0
	 4       0
	 5      31	//days[4]=31
	 6      30	//指定初始化[4]=31后面跟的第1个元素①
	 7      31	//指定初始化[4]=31后面跟的第2个元素①
	 8       0
	 9       0
	10       0
	11       0
	12       0

	以上输出揭示了指定初始化器的两个重要特性：
	①如果指定初始化器后面有更多的值，那么这些值被用于指定初始化元素后面的元素；
	②如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。
	
	如果未指定元素大小会怎么样？
	int stuff[]={1,[6]=23};		//=stuff[7]
	int stuff[]={1,[6]=4,9,10};	//=stuff[9]

	
10.1.3	给数组元素赋值
	声明数组后，可以借助数组下标给数组元素赋值：
	
	#include<stdio.h>
	#define size 50
	int main(void)
	{
		int i,evens[size];	
		for (i = 0; i < size; i++)
		{
			evens[i] = 2 * i;
			printf("%d\n", evens[i]);
		}
		return 0;
	}

	示例程序中使用循环给数组的元素依次赋值；
	C不允许把数组作为一个单元赋值给另一个数组；除初始化外也不允许使用花括号列表的形式赋值
	#include<stdio.h>
	#define size 5
	int main(void)
	{
		int oxen[size] = { 5,3,2,8 };	//初始化没问题
		int yaks[size];
		yaks = oxen;		//不允许
		yaks[size] = oxen[size];	//数字下标越界*
		yaks[size] = { 5,3,2,8 };	//不起作用
		return 0;
	}
	
	oxen数组的最后一个元素是oxen[size-1],所以yaks[size] 和 oxen[size]都超出了两个数组的末尾；
	
	
	
10.1.4	数组边界
	在使用数组时，要防止数组下标超出边界，也就是说必须确保下标时有效值；例如
	int doofi[20];
	那么在使用该数组时，要确保程序中使用的数组下标在0-19的范围内，因为编译器不会检查出这种错误。
	使用越界的数组下标会导致程序改变其他变量的值，有些还会导致程序异常终止。
	数组元素的编号从0开始，最好是在声明数组时使用符号常量来表示数组的大小
	#include<stdio.h>
	#define size 4
	int main(void)
	{
		int i,arr[size];
		for(i=0;i<size;i++)
		......
	}
	
	这样做能确保整个程序中的数组大小始终一致。


10.1.5	指定数组的大小
	
	#define size 4
	int main(void)
	{
		int i,arr[size];	//整数符号常量
		double lost[144];	//整数字面常量
	......
	}
	
	声明数组时只能在方括号中使用整型常量表达式；就是由整型常量构成的表达式；
	sizeof表达式被视为整型常量，但是const值不是，另外表达式的值必须大于0；

	int n=5,m=8;
	float a1[5];		//可以
	float a2[5*2+1];		//可以
	float a3[sizeof(int)+1];	//可以
	float a4[-4];		//不可以，数组大小必须大于0
	float a5[0];		//不可以，同上
	float a6[2.5];		//不可以，数组大小必须时整数
	float a7[(int)2.5];		//可以，已被强制转换为整型常量
	float a8[n];		//C99之前不允许，变长数组
	float a9[m];		//同上；

	边长数组VLA，声明VLA时不能进行初始化，以后会介绍，先略过；

	
10.2	多维数组
	
	某气象研究员要分析5年内每个月的降水量数据，首先要解决的是如何表示数据；
	一个方案是创建60个变量，每个变量储存一个数据；	//过于笨拙，放弃
	使用一个内含60个元素的数组；			//比60个变量要好
	创建5个数组，每个数组12个元素			//能把每年的数据分开储存
	但是如果要研究50年的降水量呢？，是否要创建50个数组？是否还有更好的方案？

	处理这种情况应该使用数组的数组，主数组有5个元素(每年)，每个元素是内含12个元素的数组(每月)
	float rain[5][12];	//内含5个数组元素的数组，每个数组元素内含12个float类型的元素；
	
	理解该声明的一种方法是，先查看中间部分，再看声明的其余部分；
	rain[5] 	//是一个内含5个元素的数组
	float...[12]	//一个内含12个float类型元素的数组

	也就是说每个元素的类型是 float[12],也就是说rain的每个元素本身都是一个内含12个float类型值的数组

	我们要在气象分析程序中用到这个二维数组，该程序的目标是，计算每年的总降水量，每年平均降水量
	和月平均降水量。
	要计算年总降水量，必须对一行数据求和；要计算某月份的平均降水量，必须对一列数据求和；
	二维数组很直观实现这些操作也很容易

#include<stdio.h>
#define months 12
#define years 5
int main(void)
{
	const float rain[years][months]=
	{
		{4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},
		{8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},
		{9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},
		{7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},
		{7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}
	};
	int year, month;
	float subtot, total;
	printf("YEAR RAINFALL(inches)\n");
	for (year = 0, total = 0; year < years; year++)//每一年，各月的降水量总和
	{
		for (month = 0, subtot = 0; month < months; month++)
			subtot += rain[year][month];
		printf("%5d %15.1f\n", 2010 + year, subtot);
		total += subtot;//5年总降水量
	}
	printf("\nThe yearly average is %.1f inches.\n\n", total / years);
	printf("Monthly averages:\n\n");
	printf("Jan	Feb	Mar	Apr	May	Jun	Jul	Aug	Sep	Oct	Nov	Dec\n");
	for (month = 0; month < months; month++)//每个月，5年的降水总量
	{
		for (year = 0, subtot = 0; year < years; year++)
			subtot += rain[year][month];
		printf("%4.1f	",subtot/years);
	}
	printf("\n");
	return 0;
}	
	程序使用了两个嵌套循环for循环；
	
	第1个嵌套for循环的内层循环，在year不变的情况下，遍历month计算某年的总降水量；
	而外层循环，改变year的值，重复遍历month，计算5年的总降水量；
	
	这种嵌套循环结构常用于处理二维数组；
	一个循环处理数组的第一个下标，另一个循环处理数组的第二个下标：
	for(year=0,total=0;year<years;year++)//处理每一年的数据
	{
		for(month=0,subtot=0;month<months;month++)
			{......}//处理每月的数据
		......//处理每一年的数据
	}
	
	第2个嵌套for循环和第一个结构相同，但是内层循环遍历year，外层循环遍历month。
	记住，每执行一次外层循环，就完整遍历一次内层循环；
	因此在改变月份之前，先遍历完年，得到某月5年间的平均降水量，以此类推；
	for (month = 0; month < months; month++)
	{
		for (year = 0, subtot = 0; year < years; year++)
			{......}//处理每年的数据
		......//处理每月的数据
	}


10.2.1	初始化二维数组

	与初始化一维数组一样，如果初始化数据列表不足，会将剩余部分初始化为0；
	如果列表数据溢出，则会出错，但有内花括号则不影响其他行的初始化；

	关于内部花括号：
	int m[2][3]={{5,6},{7,8}};	int m[2][3]={5,6,7,8};
	5  6  0			5  6  7  
	7  8  0			8  0  0

	如果没有内部花括号，在初始化的数值不够的时候会按照先后顺序逐行初始化，
	直到用完所有的值，后面没有初始化的元素被统一初始化为0；

	
10.2.2	其他多维数组

	int box[10][20][30]
	可以把一维数组想象成一行数据，二维数组就是数据表，三维数组就是一叠数据表；
	例如把box想象成10个二维数组(每个二维数组都是20行30列)堆叠起来；
	通常处理三维数组需要使用3重嵌套循环，斯维数组需要使用4重嵌套循环，以此类推

	
10.2.3	指针和数组
	指针提供一种以符号形式使用地址的方法；
	因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员要传达的指令以更接近机器的表达方法
	因此使用指针的程序更有效率；尤其是指针能有效地处理数组；
	数组表示法其实是在变相地使用指针
	
	我们举一个变相使用指针的例子：数组名是数组首元素的地址，如act是一个数组，那么：
	act==&act[0];
	act和&act[0]都表示数组首元素的内存地址，两者都是常量，在程序的运行过程中都不会改变；
	但是，可以把它们的值赋给指针变量，然后可以修改指针变量的值。
	下面示例程序，注意一个指针加上一个数时，它的值发生了什么变化：

	#include<stdio.h>
	#define size 4
	int main(void)
	{
		short dates[size];
		short *pti;//指针变量,pti指向一个short类型的地址
		short index;
		double bills[size];
		double *ptf;//指针变量
		pti = dates;//把数组地址赋给指针
		ptf = bills;
		printf("%23s %15s\n", "short", "double");
		for (index = 0; index < size; index++)	
			printf("pointers + %d:%10p %10p\n", index, pti + index, ptf + index);	
		return 0;
	}
	
	运行结果
		                  short          double
	pointers + 0:0000004375EFF808 0000004375EFF868	//两个数组的初始值
	pointers + 1:0000004375EFF80A 0000004375EFF870	//指针地址加1后的地址
	pointers + 2:0000004375EFF80C 0000004375EFF878	//指针地址加2
	pointers + 3:0000004375EFF80E 0000004375EFF880	//指针地址加3

	在我们的系统中，地址按字节编址，short类型占用2字节，double类型占用8个字节；
	在C中，指针加1指的是增加一个储存单元；
	对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址；
	这是为什么必须声明指针所指向对象类型的原因之一；
	只知道地址不够，因为计算机要知道储存对象需要多少字节；
	即使指针指向的是标量变量，也需要知道变量的类型，否则*pti就无法正确的取回地址上的值	
	因为pti是short类型，所以指针+1，其值每次递增2字节

	
	*********************************************************************************************************
	pti		pti+1		pti+2		pti+3
	
	56014	56015	56016	56017	56018	56019	56020	56021	――机器地址
	------------------	------------------	------------------	------------------
	dates[0]		dates[1]		dates[2]		dates[3]		――数组元素
	
	short dates[y],*pti;
	pti=dates;	（或者 pti=&dates[0];）	//把数组dates首元素的地址赋给指针变量pti


	①指针的值是它所指向对象的地址，地址的表示方式依赖于计算机内部的硬件；
	许多计算机都是按字节编址，意思是内存中的每一个字节都按顺序编号；
	
	②在指针前面使用*运算符可以得到该指针所指向对象的值
	
	③指针+1，指针的值递增它所指向类型的大小(以字节为单位)

	下面的等式体现了C语言的灵活性
	dates+2==&date[2]		//相同的地址
	*(dates+2)==dates[2]	//相同的值

	以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值；
	从本质上看，同一个对象有两种表示法；也就是说，
	定义a[n]的意思是*(a+n)；
	可以认为*(a+n)的意思是”到内存的a位置，然后移动n个单元，检索储存在那里的值“。
	顺带一提，不要混淆*(a+n)和*a+n
	间接运算符*的优先级高于+，所以*a+2相当于*(a)+2
	*(dates+2)		//dates第三个元素的值
	*dates+2		//dates第一个元素的值加上2

	明白了数组和指针的关系，便可以在编写程序时适时使用数组表示法或指针表示法；
	#include<stdio.h>
	#define months 12
	int main(void)
	{
		const int days[months] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
		int index;
		for (index = 0; index < months; index++)
		{
			printf("month %d has %d days.\n", index + 1, days[index]);	//数组表示法
			printf("month %d has %d days.\n", index + 1, *(days + index));	//指针表示法
		}
		return 0;
	}
	
	
	这里days是数组首元素的地址，days+index是元素days[index]的地址；而*(days+index)则是该元素的值
	该例演示了可以用指针表示数组，反过来也可以用数组表示指针，在使用以数组为参数的函数时要注意这点

10.4	函数，数组和指针

	假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为marbles的int类型数组；
	应该如何调用该函数？也许是下面这样：
	total=sum(marbles);
	那么该函数的原型是什么？
	记住，数组名是该数组首元素的地址，所以实际参数marbles是一个储存int类型值的地址；
	应该把它赋值给一个指针形式参数，即该形参是一个指向int的指针：
	int sum(int *ar);
	sum()从该参数获得了什么信息？
	它获得了该数组首元素的地址，知道要在该位置上找出一个整数。
	注意，该参数并未包含数组元素个数的信息，我们有两种方法让函数获得这个信息。
	方法1：在函数代码中写上固定的数组大小：
	int sum(int *ar)
	{
		int i;
		int total=0;
		for(i=0;i<10;i++)
			total+=ar[i];//*(ar+i)
		return total;		
	}
	
	既然能使用指针表示数组名，也可以用数组名表示指针。
	该函数定义有限制，只能计算10个int类型的元素；

	方法2：把数组大小作为第二个参数：
	int sum(int*ar,int n)
	{
		int i;
		int total=0;
		for(i=0;i<n;i++)
			total+=ar[i];
		return total;
	}
	
	关于函数的形参，还有一点要注意，只有在函数原型或函数定义头中，才可以使用int ar[]代替int *ar;
	int sum(int ar[],int n);
	int *ar形式和intar[]形式都是表示ar是一个指向int类型的指针，但是int ar[]只能用于声明形参
	第二种形式(int ar[])体系读者指针ar指向的不仅仅是一个int类型的值，还是一个int类型的数组的元素

	注意 声明数组形参
	因为数组名是该数组首元素地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针，
	只有这种情况下C才会把int ar[]和int *ar解释成一样；
	int sum(int *ar,int n);①
	int sum(int *,int);
	int sum(int ar[],int n);②
	int sum(int [],int);
	这四种原型都是等价的
	但是在函数定义中不能省略参数名，可使用①②

#include<stdio.h>
#define size 10
int sum(int ar[], int n);
int main(void)
{
	int marbles[size] = { 20,10,5,39,4,16,19,26,31,20 };
	long answer;
	answer = sum(marbles, size);
	printf("The total number of marbles is %ld.\n", answer);
	printf("The size of marbles is %zd bytes.\n", sizeof marbles);
	return 0;
}
int sum(int*ar, int n)
{
	int i;
	int total = 0;
	for (i = 0; i < n; i++)
		total += ar[i];
	printf("The size of ar is %zd bytes.\n", sizeof ar);
	return total;
}
	
	运行结果：
	The size of ar is 8 bytes.
	The total number of marbles is 190.
	The size of marbles is 40 bytes.

	注意marbles的大小是40字节，这没问题，因为它内含10个int类型的值，每个int占4字节
	但是ar是8字节；这是因为ar并不是数组本身，它是一个指向marbles数组首元素的指针；
	在我们系统中用8字节储存地址，所以指针变量的大小是8字节；

	简而言之，marbles是一个数组，ar是一个指向marbles数组首元素的指针；
	根据C数组和指针的特殊关系，可以用数组法来表示指针ar
	

	
10.4.1	使用指针形参
	
	函数要处理数组必须知道何时开始，何时结束。sum()函数使用有个指针形参标识数组的开始，
	用一个整型参数表明待处理数组的元素个数(指针形参也表明了数组中的数据类型)。
	但是这并不是给函数传递必备信息的唯一方法，还有一种方法是传递两个指针；
	第一个指针指明数组的开始处，第二个指针指明数组的结束处，如下例：
	
#include<stdio.h>
#define size 10
int sum(int *start, int *end);
int main(void)
{
	int marbles[size] = { 20,10,5,39,4,16,19,26,31,20 };
	long answer;
	answer = sump(marbles, marbles+size);
	printf("The total number of marbles is %ld.\n", answer);	
	return 0;
}
int sump(int*start, int *end)
{	
	int total = 0;
	while (start < end)
	{
		total += *start;	//把数组元素的值加起来
		start++;			//让指针指向下一个元素
	}
	return total;
}
	
	指针start开始指向marbles数组的首元素，所以赋值表达式total += *start；
	把首元素20加给total，然后表达式start++递增指针变量start，使其指向数组的下一个元素；
	因为start是指向int的指针，，start递增1相当于其值递增int类型的大小。

	注意，sum()函数用另一种方法结束加法循环，sum()函数把元素的个数作为第二个参数，
	并把该参数作为循环测试的一部分；
	for(i=0;i<n;i++)
	而sump()函数则使用第二个指针来结束循环
	while(start<end)
	因为while循环的测试条件是一个不等式的关系，所以循环最后处理的一个元素是end所指向位置
	的前一个元素，这意味着end指向的位置实际上在数组最后一个元素的后面。
	C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。
	这使得while循环的测试条件是有效的，因为start在循环中最后的值是end.
	使用这种越界指针的函数调用更为简洁：
	answer = sump(marbles, marbles+size);
	因为下标从0开始，所以marbles+size指向数组末尾的下一个【位置】。
	如果end指向数组的最后一个【元素】而不是下一个【位置】，则必须使用下面的代码：
	answer = sump(marbles, marbles+size-1);
	这种写法既不简洁也不好记，很容易导致编程错误。
	虽然C保证了marbles+size有效，但是对marbles[size](即储存在该位置上的值)未作任何保证；
	所以程序不能访问该位置。
	还可以把循环体压缩成一行代码：
	total+=*start++;
	一元运算符和++的优先级相同，但是结合律是从右往左，所以start++先求值，然后才是*start
	也就是说，指针start先递增后指向。
	使用后缀形式(即start++而不是++start)，意味着先把指针指向位置上的值加到total上，然后再递增指针；
	如果使用*(start)++则先使用start指向的值，然后递增该值，而不是递增指针；
	这样，指针将一直指向同一个位置，但是该位置上的值发生了变化；
	虽然*start++的写法比较常用，但是*(start++)这样写更清楚；

	下面程序演示了这些优先级的情况：
	#include<stdio.h>
	int data[2] = { 100,200 };
	int moredata[2] = { 300,400 };
	int main(void)
	{
		int *p1, *p2, *p3;
		p1 = p2 = data;
		p3 = moredata;
		printf(" *p1=%d,	*p2=%d,	*p3=%d\n", *p1, *p2, *p3);
		printf("*p1++=%d,	*++p2=%d,	(*p3)++=%d\n", *p1++, *++p2, (*p3)++);
		printf(" *p1=%d,	*p2=%d,	*p3=%d\n", *p1, *p2, *p3);
		return 0;
	}
	
	运行结果：	
	*p1=100,      	 *p2=100,     	*p3=300
	*p1++=100,    	 *++p2=200,     	 (*p3)++=300
	*p1=200,      	 *p2=200,       	*p3=301

	只有 (*p3)++改变了数组元素的值，其他两个操作分别把p1和p2指向数组的下一个元素；

	
10.4.2	指针表示法和数组表示法

	对于C语言，ar[i]和*(ar+1)这两个表达式都是等价的，无论ar是数组名还是指针变量，表达式都没问题；
	但是只有当ar是指针变量时，才能使用ar++这样的表达式；

	指针表示法(尤其是与递增运算符一起使用时)更接近机器语言，因此一些编译器再编译时能生成效率更高的代码；
	然而许多程序员认为他们的主要任务是确保代码正确，逻辑清晰，而优化代码留给编译器去做。(个人赞同)

10.5	指针操作
	可以对指针进行哪些操作？下面的示例程序演示了8种不同的操作；
	为了显示每种操作的结果，该程序打印了指针的值(指向的地址)，储存在指针指向地址上的值，以及指针自己的地址

#include<stdio.h>
int main(void)
{
	int urn[5] = { 100,200,300,400,500 };
	int *ptr1, *ptr2, *ptr3;
	ptr1 = urn;		//把一个地址(数组首元素)赋值给指针
	ptr2 = &urn[2];	//把一个地址(数组第3个元素)赋给指针

	//①解引用指针，以及获得指针的地址
	printf("pointer value,		dereferenced pointer,	pointer address:\n");
	printf("ptr1=%p,		*ptr1=%d,	&ptr1=%p\n", ptr1, *ptr1, &ptr1);

	//②指针加法
	ptr3 = ptr1 + 4;
	printf("\nadding an int to a pointer:\n");
	printf("ptr1+4=%p,	*(ptr1+4)=%d\n", ptr1 + 4, *(ptr1 + 4));
	ptr1++;//③递增指针
	printf("\nvalues after ptr1++:\n");
	printf("ptr1=%p,		*ptr1=%d,	&ptr1=%p\n", ptr1, *ptr1, &ptr1);
	ptr2--;//④指针递减
	printf("\nvalues after --ptr2:\n");
	printf("ptr2=%p,		*ptr2=%d,	&ptr2=%p\n", ptr2, *ptr2, &ptr2);
	--ptr1;//⑤恢复为初始值
	++ptr2;//⑥回复为初始值
	printf("\npointers reset to original values:\n");
	printf("ptr1=%p,		ptr2=%p\n", ptr1, ptr2);
	//一个指针减去另一个指针
	printf("\nsubtracting one pointer from another : \n");
	printf("ptr2=%p,		ptr1=%p,	ptr2-ptr1=%td\n", ptr2, ptr1, ptr2 - ptr1);
	//一个指针减去一个整数
	printf("\nsubtracting an int  from a pointer:\n");
	printf("ptr3=%p,		ptr3-2=%p\n", ptr3, ptr3 - 2);
	return 0;
}

	运行结果：

pointer value,     		dereferenced pointer,	pointer address:
ptr1=0000001B1F8FF688,          *ptr1=100,     		 &ptr1=0000001B1F8FF6B8

adding an int to a pointer:
ptr1+4=0000001B1F8FF698,      *(ptr1+4)=500

values after ptr1++:
ptr1=0000001B1F8FF68C,          *ptr1=200,      		&ptr1=0000001B1F8FF6B8

values after --ptr2:
ptr2=0000001B1F8FF68C,          *ptr2=200,     		 &ptr2=0000001B1F8FF6D8

pointers reset to original values:
ptr1=0000001B1F8FF688,          ptr2=0000001B1F8FF690

subtracting one pointer from another :
ptr2=0000001B1F8FF690,          ptr1=0000001B1F8FF688,  	ptr2-ptr1=2

subtracting an int  from a pointer:
ptr3=0000001B1F8FF698,          ptr3-2=0000001B1F8FF690











	

	①赋值：可以把地址赋值给指针。例如，用数组名、带地址运算符的变量名、另一个指针，来进行赋值；
		注意L地址应该和指针类型兼容，比如不能把double类型的地址赋值给int的指针；
	
	②解引用：*运算符给出指针指向地址上储存的值
	
	③取址：和所有变量一样，指针变量也有自己的地址和值，如本例中：
	ptr1的地址		0000001B1F8FF6B8		//该指针的储存地址
	ptr1的值		0000001B1F8FF688，	//也就是urn的地址
	因此&ptr1是指向ptr1的指针，ptr1是指向urn[0]的指针；
	所以*&ptr1的值是ptr1的地址0000001B1F8FF688
	ptr1=0000001B1F8FF688, *ptr1=100,&ptr1=0000001B1F8FF6B8,*&ptr1=0000001B1F8FF688
	
	④指针与整数相加：可以用+运算符把指针与整数相加，整数会和指针所指向类型的大小相乘(类型单字节大小)；
	然后，把结果与初始地址相加；
	因此ptr1+4等于4*(int)(ptr1指向类型为int 类型是数组)；加上初始地址urn[0],等效于urn[4]；
	如果相加的结果超出了初始指针的数组范围，计算结果是未定义的；
	除非正好超过数组末尾第一个位置，C保证该指针有效，但其储存的值无效；
	
	⑤递增指针：递增指向数组元素的指针，可以让该指针移动至该数组的下一个元素；
	因此ptr1++,相当于把ptr1的值加上4(系统int为4字节)，ptr1指向urn[1],*ptr1的值为200；
	ptr1的值从urn[0]的地址变为urn[1]的地址，但ptr1本身的变量储存地址未变；
	
	下图说明了递增指向int的指针：
	
	urn[0]		urn[1]		    urn[2]	        	ptr1		数组元素
	---------------------------------------------------------------------------------------------------------
	00DC 00DD	00DE 00DF	00F0 00F1		0C00 0C01	数组地址			
	---------------------------------------------------------------------------------------------------------	
	100		200		300		00DC		数组元素的值
	↑						↑
	ptr1是地址00DC上的值				ptr1=urn;,
	初始值为100					把ptr1设置为00DC；
							ptr1++递增后
							此处被设置为00DE；	ptr1的地址值未变

	⑥指针减去一个整数：使用-运算符从一个指针中减去一个整数；
	指针必须是第一个运算对象，整数是第二个运算对象，这跟指针与整数相加不同，加法顺序可以调换；
	该整数将乘以指针指向类型的大小，然后用初始地址减去乘积，所以ptr3-2与&urn[2]等价；
	因为ptr3指向的是&urn[4]，减去2个int字节大小后为&urn[2]，其值为数组urn[2]的地址值
	
	⑦递减指针：同递增；前缀或后缀的递增递减运算符都可以使用；
	
	⑧指针求差：可以计算两个指针的差值。求差的两个指针分别指向同一个数组的不同元素，通过计算，
	求出两个元素之间的距离，差值的单位与数组类型的单位相同，如本例结果为2，
	意思是这两个指针所指向的两个元素相隔两个int字节，而不是2字节；
	只要两个指针指向相同的数组，C都能保证相减运算有效；

	⑨比较：使用关系运算符可以比较两个指针的值，前提是两个指针都是指向相同类型的对象。
	
	注意，这里的减法有两种，
	可以用一个指针减去另一个指针得到一个整数，该整数为指向类型的字节单位差；
	或者是用一个指针减去一个整数，得到另一个指针。
	在递增或递减指针时还要注意一些问题，编译器不会检查指针是否仍指向数组元素；
	C只能保证指向数组任意元素的指针和指向数组后面第一个位置的指针有效；超出为未定义；
	另外，可以解引用指向数组任意元素的指针，即使指针指向数组后面一个位置是有效的，也能解引用越界指针；

	千万不要解引用未初始化的指针
	int *pt;	//未初始化的指针
	*pt=5;	//严重的错误
	
	第二行的意思是把5储存在pt指向的位置，但是pt未被初始化，其值是一个随机值，所以不知道5将储存在何处；
	创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存；
	因此在使用指针之前，必须先用已分配的地址初始化它。比如：用一个现有变量的初始地址初始化该指针；

	假设：
	int urn[3];
	int *ptr1,*ptr2;
	下面是一些有效和无效语句：
	有效语句			无效语句
	ptr1++;			urn++;
	ptr2=ptr1+2		ptr2=ptr2+ptr1;
	ptr2=urn+1;		ptr2=urn*ptr1;

	指针的第一个用法是在函数间传递信息；如果希望在被调函数中改变主调函数的变量，必须使用指针；
	指针的第二个用法是用在处理数组的函数中；

10.6	保护数组中的数据
	编写一个处理基本类型(如int)的函数时，要选择是传递int类型的值还是传递指向int的指针。
	通常都是直接传递值，只有程序需要在函数中改变数值时，才会传递指针。
	对于数组别无选择，必须传递指针，因为这样效率高。

	如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据，
	拷贝到新的数组中。
	如果把数组的地址传递给函数，让函数直接处理原数组则效率更高。

	传递地址会导致一些问题。C通常都是按值传递数据，因为这样做可以保证数据的完整性；
	如果函数使用的是原始数据的副本，就不会意外修改原始数据。
	但是处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。
	有时这正是我们需要的，例如，下面的函数给数组的每个元素都加上一个相同的值：
	void add_to(double ar[], int n, double val)
	{
		int i;
		for (i = 0; i < n; i++)
			ar[i] += val;
	}
	因此，调用该函数后，数组中的每个元素的值都增加了val的值。
	
	然而其他情况下不需要修改数据，例如下面的函数计算数组中素有元素之和，它不用改变数组的数据；
	但是，由于ar实际上是一个指针，所以编程错误可能会破坏原始数据。
	例如下面示例ar[i]++会导致数组中每个元素的值都加1：
	int sum(int ar[], int n)
	{
		int i;
		int total = 0;
		for (i = 0; i < n; i++)
			total += ar[i]++;//错误递增了每个元素的值
		return total;
	}

	
10.6.1	对形式参数使用const
	针对以上问题，ANSIC提供了一种预防手段。
	如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const
	例如，sum()函数的原型和定义如下：
	int sum(const int ar[],int n);	//函数原型
	int sum(const int ar[],int n)	//函数定义
	{
		int i;
		int total = 0;
		for (i = 0; i < n; i++)
			total += ar[i];
		return total;
	}
	
	以上代码中的const告诉编译器，该函数不能修改ar指向的数组中的内容；
	如果在函数中不小心使用类似ar[i]++的表达式，编译器会捕捉这个错误，并生成一条错误信息；

	这里一定要理解，这样使用const并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改；
	这样使用const可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。
	
	一般而言，如果编写的函数需要修改数组，在声明数组形参时不适用const，反之则使用const；

	下面程序示例，一个函数显示数组的内容，另一个函数给数组每个元素都乘以一个给定值；
	第一个函数不用改变数组，使用const，第二个函数需要修改数组元素的值，所以不使用const。

#include<stdio.h>
#define size 5
void show_array(const double ar[], int n);
void mult_array(double ar[], int n, double mult);
int main(void)
{
	double dip[size] = { 20.0,17.66,8.2,15.3,22.22 };
	printf("The original dip array:\n");
	show_array(dip, size);
	mult_array(dip, size, 2.5);
	printf("The dip array after calling mult_aray():\n");
	show_array(dip, size);
	return 0;
}
void show_array(const double ar[], int n)
{
	int i;
	for (i = 0; i < n; i++)
		printf("%8.3f", ar[i]);
	putchar('\n');
}
void mult_array(double ar[], int n, double mult)
{
	int i;
	for (i = 0; i < n; i++)
		ar[i] *=  mult;
}

	注意该程序中两个函数的返回类型都是void，虽然mult_array()函数更新了dip数组的值，但是未使用return机制


10.6.2	const的其他内容
	
	我们在前面使用const创建过变量：
	const double pi=3.14159;
	
	虽然使用#define指令可以创建类似功能的符号常量，但是const的用法更加灵活。
	可以创建const数组、const指针和指向const的指针；

	①const关键字保护数组：
	#define months 12
	......
	const int days[months]={31,28,31,30,31,30,31,31,30,31,30,31};
	如果程序稍后尝试改变数组元素的值，编译器将生成一个编译错误消息：
	day[9]=44;	//编译错误

	②指向const的指针不能用于改变值；
	double rates[5]={88.99,100.12,59.45,183.11,340.5};
	const double *pd=rates;	//pd指向数组的首元素；
	上一行代码把pd指向的double类型的值声明为const，这表明不能使用pd来更改它所指向的值：
	*pd=28.99;	//不允许
	pd[2]=222.22;	//不允许
	rates[0]=99.99	//允许，因为rates未被const限定

	无论是使用指针表示法还是数组表示法，都不允许使用pd修改它所指向的数据的值；
	但是因为rates并未被声明为const，所以仍然可以通过rates修改元素值，另外可以让pd指向别处：
	pd++;	//让pd指向rates[1]，没问题；	
	指向const的指针通常用于函数形参中，表明该函数不会使用指针改变数据；

	关于指针赋值和conts需要注意一些规则：
	首先，把【const数据】或【非const数据的地址】初始化为【指向const的指针】或【为其赋值】是合法的：
	然而只能把【非const数据的地址】赋值给【普通指针】；

	double rates[5] = { 88.99,100.12,59.45,183.11,340.5 };	//非conts数据
	const double locked[4] = { 0.08,0.075,0.0725,0.07 };	//const数据
	const double *pc = rates;	//有效
	double *pnc = rates;		//有效
	pc = locked;		//有效【conts数据的地址-首元素地址】赋值给【指向conts的指针】
	pnc = locked;		//无效【const数据的地址-首元素地址】赋值给【普通指针】
	pc = &rates[3];		//有效【非conts数据的地址-第四个元素地址】赋值给【指向conts的指针】
	pnc = &rates[3];		//有效【非conts数据的地址-第四个元素地址】赋值给【普通指针】

	应用以上规则的例子，如show_array()函数可以接受普通数组名和const数组名作为参数；
	因为两种参数都可以用来初始化指向conts的指针；
	show_array(rates,5);		//有效
	show_array(locked,4);	//有效
	因为不管被调用的数组是否有const限定，函数show_array()调用都不会改变数组的值，
	因为void show_array(const double ar[], int n)用conts限定了形参double ar[]，不改变数组的原始数据

	因此，对函数的形参使用const不仅能保护数据，还能让函数处理conts数组；

	另外不应该把conts数组名作为实际参数传递给mult_array()这样的函数：
	mult_array(rates,5,1.2);	//有效
	mult_array(locked,5,1.2);	//不要这样调用
	C标准规定，使用非conts标识符修改conts数据导致的结果是未定义的；

	const还有其他用法，例如可以声明并初始化一个不能指向别处的指针，关键是conts的位置：
	double rates[5] = { 88.99,100.12,59.45,183.11,340.5 };
	double *const pc=rates;	//pc指向数组的首元素地址
	pc=&rates[2];		//不允许，因为该指针不能指向别处的地址；
	*pc=92.99;		//没问题，这等于更改了rates[0]的值；但是指向地址仍为&rates[0]

	最后，在创建指针时还可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值
	double rates[5] = { 88.89,100.12,59.45,183.11,340.5 };
	conts double *conts pc = rates;
	pc = &rates[2];	//不允许
	*pc = 92.99;	//不允许
	
10.7	指针和多维数组
	
	在使用多维数组之前，我们先深入的学习指针；
	假设有下面的声明：
	int zippo[4][2];	//内含int整数的数组
	
	然后数组名zippo是该数组首元素的地址，在本例中，zippo的首元素是一个内含两个int值的数组，
	所以zippo是这个内含两个int值的数组的地址，下面我们从指针的 属性进一步分析：
	①因为zippo是数组首元素的地址，所以zippo的值和&zippo[0]的值相同;
	而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素(一个整数)的地址相同
	即&zippo[0][0]；
	简而言之，zippo[0]是一个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地址；
	由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo和zippo[0]的值相同

	②给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo和zippo[0]不同；
	因为zippo指向的对象占用了两个int大小，而zippo[0]指向的对象只占一个int大小
	因此 zippo+1和zippo[0]+1的值不同。

	③解引用一个指针，或在数组后使用带下标的[]运算符，得到引用对象代表的值；
	因为zippo[0]是该数组首元素(zippo[0][0])的地址，所以*(zippo[0])标识储存在zippo[0][0]上的值
	与此类似，*zippo代表该数组首元素zippo[0]的值，但是zippo[0]本身是一个int类型的地址，
	该值的地址是&zippo[0][0],所以*zippo就是&zippo[0][0];
	对两个表达式应用解引用运算符表明，**zippo与*&zippo[0][0]等价，这相当于zippo[0][0],即1个int类型的值
	简而言之，zippo是地址的地址，必须解引用两次才能获得原始值。
	地址的地址或指针的指针就是双重间接的例子。

	显然，增加数组维度会增加指针的复杂度，现在大部分初学者都开始意识到为什么指针是C语言中最难的部分；

	根据上面的内容，来尝试解释下面示例程序，该程序显示了一些地址值和数组的内容：	
#include<stdio.h>
int main(void)
{
	int zippo[4][2] = { {2,4},{6,8}, {1,3}, {5,7} };
	printf("zippo=%p\n", zippo);
	printf("zippo[0]=%p\n", zippo[0]);
	printf("zippo[1]=%p\n", zippo[1]);
	printf("zippo[1]-zippo[0]=%lld\n", zippo[1] - zippo[0]);
	printf("zippo[2]=%p\n", zippo[2]);
	printf("zippo[3]=%p\n", zippo[3]);
	printf("&zippo[0][0]=%p\n", &zippo[0][0]);
	printf("&zippo[0][1]=%p\n", &zippo[0][1]);
	printf("&zippo[1][0]=%p\n", &zippo[1][0]);
	printf("&zippo[1][1]=%p\n", &zippo[1][1]);
	printf("&zippo[2][0]=%p\n", &zippo[2][0]);
	printf("&zippo[2][1]=%p\n", &zippo[2][1]);
	printf("&zippo[3][0]=%p\n", &zippo[3][0]);
	printf("&zippo[3][1]=%p\n", &zippo[3][1]);
	printf("*************************************************************\n");
	printf("   zippo=%p,	   zippo+1=%p\n", zippo, zippo + 1);
	printf("zippo[0]=%p,	zippo[0]+1=%p\n", zippo[0], zippo[0] + 1);
	printf("  *zippo=%p,	  *zippo+1=%p\n", *zippo, *zippo + 1);
	printf("zippo[0][0]=%d\n", zippo[0][0]);
	printf("  *zippo[0]=%d\n", *zippo[0]);
	printf("    **zippo=%d\n", **zippo);
	printf("zippo[2][1]=%d\n", zippo[2][1]);
	printf("*(*(zippo+2)+1)=%d\n", *(*(zippo + 2) + 1));
	return 0;
}


	
	zippo=00000098A6EFFB08
	zippo[0]=00000098A6EFFB08
	zippo[1]=00000098A6EFFB10
	zippo[1]-zippo[0]=2
	zippo[2]=00000098A6EFFB18
	zippo[3]=00000098A6EFFB20
	&zippo[0][0]=00000098A6EFFB08
	&zippo[0][1]=00000098A6EFFB0C
	&zippo[1][0]=00000098A6EFFB10
	&zippo[1][1]=00000098A6EFFB14
	&zippo[2][0]=00000098A6EFFB18
	&zippo[2][1]=00000098A6EFFB1C
	&zippo[3][0]=00000098A6EFFB20
	&zippo[3][1]=00000098A6EFFB24
	***********************************
	   zippo=00000098A6EFFB08,         zippo+1=00000098A6EFFB10	//①
	zippo[0]=00000098A6EFFB08,      zippo[0]+1=00000098A6EFFB0C	//②
	  *zippo=00000098A6EFFB08,        *zippo+1=00000098A6EFFB0C	//③
	zippo[0][0]=2	//④
	  *zippo[0]=2	//⑤
	    **zippo=2	//⑥
	zippo[2][1]=3
	*(*(zippo+2)+1)=3
	
	zippo={zippo[0],zippo[1],zippo[2],zippo[3]};		二维数组名及其元素(一维数组)
	zippo[0]={zippo[0][0],zippo[0][1]};			二维数组元素(一维数组)的元素，也是数组(二维)
	zippo[0][0]		zippo[0][1]		二维数组元素；同时也是一维数组的地址；	
	FB08  FB09  FB0A  FB0B  	FB0C  FB0D  FB0E  FB0F	二维数组地址；同时也是一维数组元素的值；
	2			4			二维数组元素的值；

	如上图所示：
	二维数组zippo的地址和一维数组zippo[0]的地址相同,他们的地址都是各自数组首元素的地址；
	因而与&zippo[0][0]的值也相同；

	尽管如此，它们也有差别；我们的系统中，int字长是4字节，所以：
	zippo[0]首元素地址是zippo[0][0],指向一个4字节的数据对象，zippo[0]+1,其值增加4；②
	zippo首元素地址是zippo[0]，zippo指向一个8字节的数据对象，zippo+1,其值增加8；①

	该程序还演示了zippo[0]和*zippo完全相同；②/③
	对二维数组名解引用两次，得到储存在数组中的值；⑥
	使用两个间接运算符*或使用两对方括号[]都能获得该值④/⑥
	要特别注意，与zippo[2][1]等价的指针表示法是*(*(zippo+2)+1);如下图所解释：
	
	zippo		二维数组首元素的地址(每个元素都内含2个int类型元素的一维数组)
	zippo+2		二维数组的第三个元素(即一维数组)的地址
	*(zippo+2)	二维数组的第三个元素(即一维数组)的首元素地址
	*(zippo+2)+1	二维数组的第三个元素(即一维数组)的第二个元素地址
	*(*(zippo+2)+1)	二维数组的第三个一维数组元素的第二个int类型元素的值

	下图以另一种视图演示了数组地址，数组内容和指针之间的关系：

		↓            zippo		zippo+1		    zippo+2	           zippo+3
		↓          zippo[0]		zippo[1]		    zippo[2]	            zippo[3]
		↓zippo[0][0] zippo[0][1]    zippo[0][0] zippo[0][1]    zippo[0][0] zippo[0][1]     zippo[0][0] zippo[0][1]
	地址：→	FB08	   FB0C	       FB10	        FB14	            FB18          FB1C         	  FB20	   FB24
		↑*zippo     *zippo+1      *zippo+2
		↑zippo			zippo+1

	
	个人理解：因为针对指针多维度阅读理解容易认知障碍，可以用数组省略法来解读：比如：
	zippo	二维数组集	zippo[][]	2组[],指向2个int字节的数据对象;	二维数组；
	zippo[0]	一维数组元素级	zippo[0][]	1组[],指向1个int字长的数据对象;	一维数组首元素，
	zippo[0][0]二维数组元素级；	具体的已经确定的1int字长的数据对象;	二维数组首元素；	
	FB08	具体地址		数据对象的内存地址;			*zippo （一维数组的值）
	2	实际储存的值	地址上检索到的值;			**zippo（二维数组的值）
	
10.7.1	指向多维数组的指针
	
	如何声明一个指针变量pz指向一个二维数组(如zippo)？
	把指针声明为指向int的类型还不够，因为指向int只能与zippo[0]的类型匹配，说明该指针指向一个int类型的值；
	但是zippo是它首元素的地址，该元素是一个内含两个int类型的一维数组；
	因此，pz必须指向一个内含两个int类型值的数组，而不是一个指向int类型值；其声明如下：

	int (*pz)[2];

	以上代码把pz声明为指向一个数组的指针；为什么要用圆括号？因为[]优先级高于*运算符；

	int *pax[2];	//pax是一个内含两个指针元素的数组，每个元素都指向int 的指针；
	由于[]优先级高，先与pax结合，称为一个内含两个元素的数组，然后*表示数组内含两个指针；
	最后，int表示这两个指针都指向int类型的值；

	#include<stdio.h>
	int main(void)
	{
		int zippo[4][2] = { {2,4},{6,8}, {1,3}, {5,7} };
		int(*pz)[2];
		pz = zippo;
		printf("   pz=%p,		  pz+1=%p\n", pz, pz + 1);
		printf(" pz[0]=%p,	 pz[0]+1=%p\n", pz[0], pz[0] + 1);
		printf("  * pz=%p,	  * pz+1=%p\n", *pz, *pz + 1);
		printf(" pz[0][0]=%d\n", pz[0][0]);
		printf("  * pz[0]=%d\n", *pz[0]);
		printf("    ** pz=%d\n", ** pz);
		printf(" pz[2][1]=%d\n", pz[2][1]);
		printf("*(*( pz+2)+1)=%d\n", *(*(pz + 2) + 1));
		return 0;
	}

	虽然pz是一个指针，不是数组名，但是也可以使用pz[2][1]这样的写法。
	可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：
	zippo[m][n]==*(*(zippo+m)+n);
	pz[m][n]==*(*(pz+m)+n);


10.7.2	指针的兼容性
	指针之间的赋值比数值类型之间的赋值要严格。例如不用类型转换就可以把int类型的值赋给double类型的变量
	但是两个类型的指针不能这样做。
	int n=5;
	double x;
	int *pl=&n;
	double *pd=&x;
	x=n;	//隐式类型转换；
	pd=pl;	//编译时错误；

	更复杂的类型也是如此，假设有如下声明：
	int *pt;		//指向1个int类型；
	int (*pa)[3];	//指向3个int类型
	int ar1[2][3];	//内含3个int类型元素的数组
	int ar2[3][2];	//内含2个int类型元素的数组
	int **p2;		//指向指针的指针，指向的指针指向int
	有如下的语句：
	pt=&ar1[0][0];	//都是指向int的指针
	pt=ar1[0];		//都是指向int的指针
	pt=ar1;		//无效
	pa=ar1;		//都是指向内含3个int类型元素数组的指针
	pa=ar2;		//无效
	pa=&pt;		//都是指向int的指针
	*p2=ar2[0];	//都是指向int的指针
	pa=ar2;		//无效；

	注意，以上无效的赋值表达式语句中涉及的两个指针都是指向不同的类型。
	例如，pt指向一个int类型值，而ar1指向一个内含3个int类型元素的数组；
	类似的pa指向一个内含3个int类型元素的数组，所以它与ar1的类型兼容；
	但是ar2指向一个内含2个int类型元素的数组，所以pa与ar2不兼容。

	变量p2是指向指针的指针，它指向的指针指向int，而ar2是指向数组的指针；该数组内含2个int类型的元素；
	所以p2和ar2的类型不同，不能把ar2赋给p2；
	但是*p2是指向int的指针，与ar2[0]兼容，因为ar2[0]是指向该数组首元素ar2[0][0]的指针；
	所以ar2[0]也是指向int的指针。

	一般而言，多重解引用让人费解，例如：
	int x=20;
	const int y=23;
	int *p1=&x;
	const int *p2=&y;
	const int **pp2;

	p1=p2;		//不安全，把const指针赋给非const指针
	p2=p1;		//有效，把非const指针赋给const指针
	pp2=&p1;		//不安全，嵌套指针类型赋值

	前面提到过，把const指针赋给非const指针不安全，但是反过来没问题，前提是只进行一级解引用；
	但是进行两级解引用时，这样赋值也不安全，例如：
	
	const int **pp2;
	int *p1;
	const int n=13;
	
	pp2=&p1;		//允许，但是这导致const限定符失效(根据第一行代码，不能通过*pp2修改它所指向的内容)
	*pp2=&n;		//有效，两者都声明为const，但是这将导致p1指向n
	*p1=10;		//有效，但是这将改变n的值(但根据地三行代码，不能修改n的值)；

	
10.7.3	函数和多维数组
	如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参；
	在函数中，通常使用数组表示法进行相关操作。
	
	下面我们编写一个处理二维数组的函数，一种方法是利用for循环把处理一维数组的函数应用到二维数组的每一行；如：
	
#include<stdio.h>
#define rows 3
#define cols 4
void sum_rows(int ar[][cols], int row);	//函数原型语法1
void sum_cols(int[][cols], int);		//函数原语法2，省略形参名，没问题
int sum2d(int(*ar)[cols], int row);		//函数原型语法3
int main(void)
{
	int junk[rows][cols] = {
		{2,4,6,8},
		{3,5,7,9},
		{12,10,8,6}
	};
	sum_rows(junk, rows);
	sum_cols(junk, rows);
	printf("Sum of all elments = %d\n", sum2d(junk, rows));
	return 0;
}
void sum_rows(int ar[][cols], int row)
{
	int r;
	int c;
	int total;
	for (r = 0; r < row; r++)
	{
		total = 0;
		for (c = 0; c < cols; c++)
			total += ar[r][c];
		printf("row %d:sum=%d\n", r, total);
	}
}
void sum_cols(int ar[][cols], int row)
{
	int r;
	int c;
	int total;
	for (c = 0; c < cols; c++)
	{
		total = 0;
		for (r = 0; r < row; r++)
			total += ar[r][c];
		printf("col %d:sum=%d\n", c, total);
	}
}
int sum2d(int ar[][cols], int row)
{
	int r;
	int c;
	int total = 0;
	for (r = 0; r < rows; r++)
		for (c = 0; c < cols; c++)
			total += ar[r][c];
	return total;
}



	注意，ar和main()中的junk都是用数组表示法；因为ar和junk的类型相同，它们都指向4个int类型值的数组的指针
	所以下面的声明：
	int sum2(int ar[][],int row);	//错误声明
	int sum2(int ar[][4],int row);	//有效声明
	int sum2(int ar[3][4],int row);	//有效声明，但是3将被忽略

	前面介绍过，编译器会把数组表示法转换成指针表示法，例如编译器会把ar[1]转换成ar+1
	编译器对ar+1求值，要知道ar所指向的对象大小。如果第二对方括号是空的，编译器就不知道该如何处理。
	也可以在第一对方括号中写上大小，但是编译器会忽略该值：

	一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值：
	int sum4d(int ar[][12][20][30],int rows);
	因为第一个方括号只用于表明这是一个指针，而其他方括号则用于描述指针所指向数据对象的类型；
	下面的声明与该声明等价：
	int sum4d(int (*ar)[12][20][30],int rows);	//ar是一个指针，指向一个12*20*30的int数组

10.8	变长数组(VLA)
	在处理二维数组的时候，我们只把函数的行数作为参数，而列数却内置在函数体内；如：
	#define cols 4
	int sum2d(int ar[][cols], int row)
	{
		int r;
		int c;
		int total = 0;
		for (r = 0; r < rows; r++)
			for (c = 0; c < cols; c++)
				total += ar[r][c];
		return total;
	}
	假设声明了下列数组：
	int array1[5][4];
	int array1[100][4];
	int array1[2][4];
	可以用sum2d()函数分别计算这些数组的元素之和：
	total=sum2d(array1,5);	//5*4数组元素之和
	total=sum2d(array1,100);	//100*4数组元素之和	
	total=sum2d(array1,2);	//2*4数组元素之和
	
	sum2d()函数之所以能处理这些数组，是因为这些数组的列数固定为4，而行数被传递给形参row，是个变量；
	但是如果要计算6*5的数组就不能使用这个函数，必须要重新创建一个clos为5调函数；
	因为C规定，数组的维数必须是常量，不能用变量来替代
	
	要创建一个能处理任意大小二维数组的函数，比较繁琐；
	(必须把数组作为一维数组传递，然后让函数计算每行的开始处)；

	鉴于此，C99新增了边长数组(VLA)允许使用变量表示数组的维度，如下所示：
	int quarters=4;
	int regions=5;
	double sales[regions][quarters];//一个变长数组VLA
	
	变长数组有一些限制，变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明；
	都不能使用static或extern储存类别说明符，而且不能在声明中初始化它们。

#include<stdio.h>
#define rows 3
#define cols 4
int sum(int， int, int ar[*][*]);	//ar是一个变长数组，函数原型中可省略维度形参名；
int main(void)
{
	int i, j;
	int rs = 3;
	int cs = 10;
	int junk[rows][cols] = {
		{2,4,6,8},
		{3,5,7,9},
		{12,10,8,6}
	};
	int morejunk[rows - 1][cols + 2] = {
		{20,30,40,50,60,70},
		{5,6,7,8,9,10}
	};

	int varr[rs][cs];
	for (i = 0; i < rs; i++)
		for (j = 0; j < cs; j++)
			varr[i][j] = i * j + j;

	printf("3*4 array\n");
	printf("sum of all elements=%d\n", sum(rows, cols, junk));
	printf("2*6 array\n");
	printf("sum of all elements=%d\n", sum(rows - 1, cols - 2, morejunk));
	printf("3*10 vla\n");
	printf("sum of all elements=%d\n", sum(rs, cs, varr));
	return 0;
}
int sum(int row, int col, int ar[row][col])	//ar是一个变长数组(VLA)；row和col在形参列表中必须在声明ar之前声明
{
	int r;
	int c;
	int tot = 0;
	for (r = 0; r < row; r++)
		for (c = 0; c < col; c++)
			tot += ar[r][c];
	return tot;
}
	
	以上代码只能在支持VLA的编译器上运行；
	需要注意的是，在函数定义的形参列表声明中的变长数组并未实际创建数组；
	和传统的语法类似，变长数组名实际上是一个指针。
	这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组；
	下面的代码段指出指针和实际数组是何时声明的：

	int thing[10][6];
	twoset(10,6,thing);
	void twoset(int n,int m,int ar[n][m])//ar是一个指向数组的指针
	{
		int temp[n][m];	//temp是一个n*m的int数组
		temp[0][0]=2;	//设置temp第一个元素为2	
		ar[0][0]=2;		//设置thing[0][0]为2
	}
	
	如上代码所示调用towset()时，ar变成指向thing[0]的指针，temp被创建为6*10的数组；
	因为ar和thing都是指向thing[0]的指针，ar[0][0]与thing[0][0]访问的数据位置相同。

	
10.9 	复合字面量

	假设给带int类型形参的函数传递一个值，要传递int类型的变量，但是也可以传递int类型常量；
	在C99之前，对于带数组形参的函数，情况不同，可以传递数组，但是没有等价的数组常量。
	C99新增了复合字面量，字面量是除符号常量外的常量；
	例如，5是int类型的字面量，81.3是double类型的字面量，‘Y’是char类型的字面量；‘CAT’是字符串字面量；
	对于数组，复合字面量类似于数组初始化列表，前面是用括号括起来的类型名。如：
	int diva[2]={10,20};
	下面的复合字面量创建了一个和diva数组相同的匿名数组，也有两个int类型的值：
	(int [2]){10,20}	//复合字面量
	
	注意，去掉声明中的数组名，留下的int[2]即是复合字面量的类型名。
	
	初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前个数：
	(int []){50,20,90}	//内含3个元素的复合字面量
	
	因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。
	使用指针记录地址就是一种用法，也就是说可以这样用：
	int *pt1;
	pt1=(int [2]){10,20};
	
	注意，该复合字面量的字面常量与上面创建的diva数组的字面常量完全相同，与有数组名的数组类似，
	复合字面量的类型名也代表首元素的地址，所以可以把它赋给指向int的指针，然后便可以使用这个指针；
	如 *pt1是10，pt1[1]是20；
	
	还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：
	int sum(const int ar[],int n);
	……
	int m;
	m=sum((int []){4,4,4,5,5,5},6);
	这里，第一个实参是内含6个int类型值的数组，和数组名类似，这同时也是该数组首元素的地址；
	这种用法的好处是，把信息传入函数前不必先创建数组，这是复合字面量的典型用法。
	
#include<stdio.h>
#define cols 4
int sum2(const int ar[][cols], int rows);
int sum(const int ar[], int n);
int main(void)
{
	int x, y, z;
	int *pt1;
	int(*pt2)[cols];
	pt1 = (int[2]) { 10, 20 };			//使用复合字面量
	pt2 = (int[2][cols]) { {1, 2, 3, -9}, { 4,5,6,-8 } };	//使用复合字面量
	x = sum(pt1, 2);
	y = sum2(pt2, 2);
	z = sum((int[]) { 4, 4, 4, 5, 5, 5 }, 6);		//使用复合字面量
	printf("x=%d\n", x);
	printf("y=%d\n", y);
	printf("z=%d\n", z);
	return 0;
}
int sum(const int ar[], int n)
{
	int i;
	int total = 0;
	for (i = 0; i < n; i++)
		total += ar[i];
	return total;
}
int sum2(const int ar[][cols], int rows)
{
	int r;
	int c;
	int total = 0;
	for (r = 0; r < rows; r++)
		for (c = 0; c < cols; c++)
			total += ar[r][c];
	return total;
}

	
	记住，复合字面量是提供只临时需要值的一种手段，复合字面量具有块作用；
	这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在；
	也就是说，复合字面量的定义在最内层的花括号中。

	
10.10	关键概念
	数组用于储存相同类型的数据；C把数组看作是派生类型，因为数组是建立在其他类型的基础上。
	也就是说，无法简单地声明一个数组，在声明数组时必须说明其元素的类型，比如int类型、float类型等等；
	所谓的其他类型也可以是数组类型，这种情况下创建的是数组的数组(二维数组)//禁止格式套娃
	
	通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题，有助于实现程序的模块化
	在把数组作为实际参数时，传递给函数的不是整个数组，而是数组的地址(因此函数对应的形参时指针)；
	
	为了处理数组，函数必须知道从何处开始读取数据，和要处理多少个数组元素；
	数组地址提供了地址、元素个数可以内置在函数中或作为单独的参数传递。
	
	数组和指针的关系密切，同一个操作可以用数组表示法或指针表示法。
	它们之间的关系允许你在处理数组的函数中使用数组表示法，即使函数的形式参数是一个指针，而不是数组。

	对于传统的C数组，必须用常量表达式指明数组的大小，所以数组大小在编译时就已经确定。

10.11	本章小结
	
	数组是一组数据类型相同的元素。
	数组元素按照顺序储存在内存中，通过下标可以访问各元素；
	数组首元素的下标是0，所以对于内含n个元素的数组，最后一个元素的下标是n-1
	作为程序员，要确保使用有效的数组下标，防止越界；

	type name[size];
	
	这里type是数组元素中每个元素的数据类型，name是数组名，size是数组元素的个数；
	对于传统C数组，要求size是整型常量表达式；(其中变长数组允许使用非常量表达式)

	C把数组名解释为该数组首元素的地址。
	换言之，数组名与指向该数组首元素的指针等价；即ar是一个数组，那么表达式ar[i]和*(ar+i)等价
	int ar[2]={5,8};	
	则：
	 ar[0]=5;
	 ar[1]=8;
	*ar=ar[0];		(=5)
	*(ar+1)=ar[1];	(=8)
	 ar=&ar[0];	(储存整数5的内存地址)
	 ar+1=&ar[1];	(储存整数8的内存地址)
	*ar+1=5+1;	(=6)

	验证代码：
	#include<stdio.h>
	int main(void)
	{
		int ar[2] = { 5,8 };
		printf("ar[0]=%d--%d\n", ar[0], *ar);
		printf("ar[1]=%d--%d\n", ar[1], *(ar + 1));
		printf("&ar[0]=%p--%p\n", &ar[0], ar);
		printf("&ar[1]=%p--%p\n", &ar[1], ar + 1);
		printf("*ar+1=%d\n", *ar + 1);	
		return 0;
	}
	
	
	对于C语言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。
	然后函数可以使用传入的地址操控原始数据。
	如果函数没有修改原始数据的意图，应在声明函数的形式参数时使用关键字const。
	
	在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。
	
	指针加上一个整数或递增指针，指针的值所指向的对象大小为单位改变。
	也就是说，如果pd指向一个数组的8字节double类型，那么pd+1意味着其值加8，以便它指向该数组的下一个元素；
	
	二维数组即是数组的数组；如：
	double sales[5][12]；
	该数组名为sales，有5个元素，每个元素都是一个内含12个double类型值元素的数组。
	第一个一维数组是sales[0]，第二个一维数组是sales[1]……以此类推，每个元素都是内含12个double类型的值的数组；
	使用第二个下标可以访问这些一维数组中的特定元素，
	例如sales[2][5]是sales[2]的第六个元素，而sales[2]是sales的第三个元素；

	C语言传递多维数组的传统方法是把数组名(即数组的地址)传递给类型匹配的指针形参。
	声明这样的指针形参要指定所有的数组维度，除了第一个维度。传递的第一个维度通常作为第二个参数；
	例如要处理前面声明的sales数组，函数原型和函数调用如下：
	void display(double ar[][12],int rows);
	……
	display(sales,5);
	
	上述讨论中使用的是int类型和double类型的数组，其他类型的数组也是如此。然而字符串有一些特殊规则；
	这是由于其末尾的空字符所致，有了这个空字符，不用传递数组的大小；
	函数通过检测字符串的末尾也知道在何处停止，将在11章具体介绍。

	
	
10.12	复习题
	1.下面的程序将打印什么内容？
	#include<stdio.h>
	int main(void)
	{
		int ref[] = { 8,4,0,2 };
		int *ptr;
		int index;
		for (index = 0, ptr = ref; index < 4; index++, ptr++)
			printf("%d %d\n", ref[index], *ptr);
		return 0;
	}
	
	8	8
	4	4
	0	0
	2	2
	
	2.复习题1中，ref有多少个元素？//4
	3.复习题1中，ref的地址是什么？ref+1是什么意思？++ref指向什么？
	//ref地址=&ref[0];ref+1=&ref[1];++ref无效表达式，ref是常量;
	
	4.在下面代码中，*ptr和*(ptr+2)的值分别是什么？
	①
	int *ptr;
	int torf[2][2]={12,14,16};
	ptr=torf[0];
	
	//ptr=torf[0];
	ptr是个int类型的指针，torf[0]指向它的首元素torf[0][0],torf[0]等价于&torf[0][0]
	ptr等价于&torf[0][0];
	*ptr=torf[0][0];
	ptr+2等价于&torf[0][2]
	*(ptr+2)=16
	
	
	
	②
	int *ptr;
	int torf[2][2]={{12},{14,16}};
	ptr=torf[0];

	//*ptr=12
	*(ptr+2)=14

	
	5.在下面的代码中，**ptr和**(ptr+1)的值分别是什么？
	①
	int (*ptr)[2];
	int torf[2][2]={12,14,16};
	ptr=torf;

	//ptr=torf;torf指向其首元素地址torf[0];torf[0]={12,14};torf[1]={16,0};
	**ptr=12;
	**(ptr+1)=16;	
	
	②
	int (*ptr)[2];
	int torf[2][2]={{12},{14,16}};
	ptr=torf;

	//ptr=torf;torf指向其首元素地址torf[0];torf[0]={12,0};torf[1]={14,16};
	**ptr=12;
	**(ptr+1)=14;

	
	6.假设有下面的声明：
	int grid[30][100];

	a.用1种写法表示grid[22][56];

	grid[22][56];	*(*(grid+22)+56)	教材答案：&grid[22][56]	//这是地址不是值；答案存疑；


	b.用2种写法表示grid[22][0];

	grid[22];		*(*(grid+22))	教材答案：grid[22]		//值不对
	grid[22][0];	*(*(grid+22)+0)	教材答案：&grid[22][0]	//这是地址不是值；

	c.用3种写法表示grid[0][0];

	grid;		**grid		教材答案：(int *)grid		//值不对
	grid[0];		*(*grid)		教材答案：grid[0]		//值不对
	grid[0][0];		*(*(grid))		教材答案：&grid[0][0]	//这是地址不是值
	
	验证代码
	#include<stdio.h>
	int main(void)
	{
		int grid[30][100] = { [0][0]=1,[22][0]=3,[22][56] = 5 };
		printf("%d\n%d\n%p\n%p\n\n", grid[22][56],*(*(grid + 22) + 56), &grid[22][56],  *(grid + 22) + 56);
		printf("%d\n%p\n%p\n\n", *(*(grid + 22)), &grid[22], *(grid + 22));
		printf("%d\n%d\n%p\n%p\n\n", grid[22][0], *(*(grid + 22) + 0), &grid[22][0], *(grid + 22) + 0);
		printf("%d\n%p\n%p\n\n", **grid, (int*)grid, *grid);
		printf("%d\n%p\n%p\n\n", *(*grid), &grid[0], *grid);
		printf("%d\n%d\n%p\n%p\n\n", grid[0][0], *(*(grid)), &grid[0][0], *(grid));
		return 0;
	}

	7.正确声明以下各变量
	a.digits是一个内含10各int类型值的数组；
	//int digits[10];
	
	b.rates是一个内含6个float类型值的数组；
	//float rates[6];
	
	c.mat是一个内含3个元素的数组，每个元素都是内含5个整数的数组；
	//int mat[3][5];
	
	d.psa是一个内含20个元素的数组，每个元素都是指向int的指针；
	// int *psa[20];
	
	e.pstr是一个指向数组的指针，该数组内含20个char类型的值
	//char (*pstr)[20];

	8.
	a.声明一个内含6个int类型值的数组，并初始化各元素为1、2、4、8、16、32
	//int a[6]={1,2,4,8,16,32};
	
	b.用数组表示法表示a声明的数组的第三个元素；
	//a[2];
	
	c.声明一个内含100各int类型值的数组，并初始化最后一个元素为-1；
	//int a[100]={[99]=-1};
	
	d.声明一个内含100个int类型值的数组，并初始化下标为5、10、11、12、3的元素为101；
	//int a[100]={[5]=101,[10]=101,101,101,[3]=101};
	
	9.内含10个元素的数组下标范围是什么？//0-9
	
	10.假设有下面的声明：
	float rootbeer[10],things[10][5],*pf,value=2.2;
	int i=3;
	判断以下各项是否有效：
	a.rootbeer[2]=value;		//有效；
	b.scanf("%f",&rootbeer);	//无效；
	c.rootbeer=value;		//无效
	d.printf("%f",rootbeer);	//无效
	e.thing[4][4]=rootbeer[3];	//有效
	f.thing[5]=rootbeer;		//无效
	g.pf=value;		//无效
	h.pf=rootbeer;		//有效

	11.声明一个800*600的int类型数组
	//int a[800][600];
	
	12.下面声明了3个数组：
	double trots[20];
	short clops[10][30];
	long shots[5][10][15];
	
	a.分别以传统方式和变长数组为参数的方式编写处理trots数组的void函数原型和函数调用
	b.分别以传统方式和变长数组为参数的方式编写处理clops数组的void函数原型和函数调用
	c.分别以传统方式和变长数组为参数的方式编写处理shots数组的void函数原型和函数调用
	
	void name(double ar[],int n);
	name(trots,20);//传统方式	
	void name(int n,double ar[n]);
	name(20,trtos);//VLA方式

	void name(short ar[30],int n);
	name(clops,10);
	void name(int n,int m,ar[n][m]);
	name(10,30,clops);
	
	void name(long ar[10][15],int n);
	name(shots,5);
	void name(int n,int m,int k,long ar[n][m][k]);
	name(5,10,15,shots);

	13.下面有两个函数原型：
	void show(const double ar[],int n);	//n是数组元素的个数
	void show2(const double ar2[][3],int n);	//n是二维数组的行数
	
	a.编写一个函数调用，把一个内含8，3，9和2的复合字面量传递给show()函数
	show(int[4]{8,3,9,2},4);
	b.编写一个函数调用，把一个2行3列的复合字面量({8,3,9},{5,4,1})传递给show2()函数
	show(int[][3]{{8,3,9},{5,4,1}},2);


	
10.13	编程练习
	1.修改程序10.7的rain.c程序，用指针进行计算(仍然要声明并初始化数组)。
	
#include<stdio.h>
#define months 12
#define years 5
int main(void)
{
	const float rain[years][months] =
	{
		{4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},
		{8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},
		{9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},
		{7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},
		{7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}
	};
	int year, month;
	float subtot, total;	
	for (year = 0, total = 0; year < years; year++)//每一年，各月的降水量总和
	{
		for (month = 0, subtot = 0; month < months; month++)
			subtot += *(*(rain + year) + month);
		printf("%5d %15.1f\n", 2010 + year, subtot);
		total += subtot;//5年总降水量
	}
	printf("\nThe yearly average is %.1f inches.\n\n", total / years);
	printf("Monthly averages:\n\n");
	printf("Jan	Feb	Mar	Apr	May	Jun	Jul	Aug	Sep	Oct	Nov	Dec\n");
	for (month = 0; month < months; month++)//每个月，5年的降水总量
	{
		for (year = 0, subtot = 0; year < years; year++)
			subtot += *(*(rain + year) + month);
		printf("%4.1f	", subtot / years);
	}
	printf("\n");
	return 0;
}


	2.编写一个程序，初始化一个double类型的数组，然后把该数组的内容拷贝至其他3个数组中
	(在main()中声明这4个数组)
	①使用带数组表示法的函数进行第一份拷贝；
	②使用带指针表示法和指针传递的函数进行第二份拷贝；	
	③把目标数组名、源数组名和待拷贝的元素个数作为前两个函数的参数；
	第三个函数以目标数组名、源数组名和指向源数组最后一个元素后面的元素的指针，也就是说，
	给定以下声明，则函数调用如下所示：
	double source[5]={1.1,2.2,3.3,4.4,5.5};
	double target1[5];
	double target2[5];
	double target3[5];
	copy_arr(target1,source,5);
	copy_ptr(target2,source,5);
	copy_ptrs(target3,source,source+5);

#include<stdio.h>
void copy_arr(double ar[], double cr[], int n);
void copy_ptr(double *ar, double *cr, int n);
void copy_ptrs(double ar[], double cr[], double *cr1);
int main(void)
{
	const double source[5] = { 1.1,2.2,3.3,4.4,5.5 };
	double target1[5];
	double target2[5];
	double target3[5];
	printf("target1[5]=");
	copy_arr(target1, source, 5);	
	printf("target1[2]=%g,", target1[2]);	//检验结果
	printf("\ntarget2[5]=");
	copy_ptr(target2, source, 5);
	printf("target2[2]=%g,", target2[2]);	//检验结果
	printf("\ntarget3[5]=");
	copy_ptrs(target3, source, source + 5);
	printf("target3[2]=%g,", target3[2]);	//检验结果
	return 0;
}
void copy_arr(double ar[], double cr[], int n)
{
	int i;
	for (1 = 0; i < n; i++)
	{
		*(ar + i) = *(cr + i);
		printf("%g, ", *(ar+i));	//查看是否起效
	}
}
void copy_ptr(double *ar, double *cr, int n)
{
	int i;
	for (i = 0; i < n; i++)
	{
		*(ar + i) = *(cr + i);
		printf("%g, ", *(ar + i));	//查看是否起效
	}
}
void copy_ptrs(double ar[], double cr[], double *cr1)
{
	int i;
	for(i=0;i<cr1-cr;i++)
	{
		*(ar+i) = *(cr+i);
		printf("%g, ",*(ar+i));	//查看是否起效	
	}	
}

//第三种拷贝法的简化：
void copy_ptrs(double ar[], double cr[], double *cr1)
{	
	while (cr < cr1)		
		*(ar++) = *(cr++);		
}

	3.编写一个函数，返回储存在int类型数组中的最大值，并在一个简单的程序中测试该值。
	#include<stdio.h>
	int max(int ar[], int n);
	int main(void)
	{
		int ptr[8] = { 1,2,3,4,8,7,6,5 };
		int exp[5][2] = { {1,3},{5,7},{9,0},{8,6},{4,2} };
		int emp[2][3] = { {1,3,5},{2,4,6} };
		printf("%d\n", max(ptr, 8));
		printf("%d\n", max(exp[0], 10));
		printf("%d\n", max(emp[0], 6));
		return 0;
	}
	int max(int ar[], int n)
	{
		int i, temp;
		temp = ar[0];
		for (i = 0; i < n; i++)
		{		
			if (temp < ar[i + 1])
				temp = ar[i+1];		
		}
		return temp;
	}

	4.编写一个函数，返回储存在double类型数组中最大值的下标，并在一个简单的程序中测试该函数；
	#include<stdio.h>
	int maxit(double ar[], int n);
	int main(void)
	{
		double ptr[8] = { 1.0,2.0,3.0,4.0,8.0,7.0,6.0,5.0 };
		double exp[5][2] = { {1.0,3.0},{2.0,4.0},{7.0,5.0},{6.0,8.0},{9.0,0} };
		double emp[2][3] = { {4.0,6.0,3.0},{5.0,2.0,1.0} };
		printf("ptr[%d]\n", maxit(ptr, 8));
		printf("exp[%d][%d]\n", maxit(exp[0], 10)/2, maxit(exp[0], 10) % 2);
		printf("emp[%d][%d]\n", maxit(emp[0], 6)/3, maxit(emp[0], 6) % 3);
		return 0;
	}
	int maxit(double ar[], int n)
	{
		int i,k;
		double temp;
		temp = ar[0];
		k = 0;
		for (i = 0; i < n; i++)
		{		
			if (temp < ar[i + 1])
			{
				temp = ar[i + 1];
				k = i+1;
			}
		}
		return k;
	}
	

	5.编写一个函数，返回储存在double类型数组中最大值和最小值的差值，并在一个简单的程序中测试该函数；
	#include<stdio.h>
	double sub(double ar[], int n);
	int main(void)
	{
		double ptr[8] = { 1.0,2.0,3.0,4.0,8.0,7.0,6.0,5.0 };
		double exp[5][2] = { {1.0,3.0},{2.0,4.0},{7.0,5.0},{6.0,8.0},{9.0,0} };
		double emp[2][3] = { {4.0,6.0,3.0},{5.0,2.0,1.0} };
		printf("%g\n", sub(ptr, 8));
		printf("%g\n", sub(exp[0], 10));
		printf("%g\n", sub(emp[0], 6));
		return 0;
	}
	double sub(double ar[], int n)
	{
		int i,k;
		double max,min;
		max = ar[0];
		min = ar[n - 1];	
		for (i = 0; i < n; i++)			
			if (max < ar[i + 1])		
				max = ar[i + 1];	
		for (k = n - 1; k > 0; k--)
			if (min > ar[k - 1])
				min = ar[k - 1];	
		return max-min;
	}	
		

	6.编写一个函数，把double类型数组中的数据倒序排列，并在一个简单的程序中测试该函数；
	#include<stdio.h>
	void rev(double ar[], int n);
	int main(void)
	{
		double ptr[8] = { 1.0,2.0,3.0,4.0,8.0,7.0,6.0,5.0 };
		double exp[5][2] = { {1.0,3.0},{2.0,4.0},{7.0,5.0},{6.0,8.0},{9.0,0} };
		double emp[2][3] = { {4.0,6.0,3.0},{5.0,2.0,1.0} };
		rev(ptr, 8);
		putchar('\n');
		rev(exp[0], 10);
		putchar('\n');
		rev(emp[0], 6);	
		return 0;
	}
	void rev(double ar[], int n)
	{
		int i;
		for (i = n; i > 0; i--)
			printf("%g, ", ar[i - 1]);
		return;
	}


	7.编写一个程序，初始化一个double类型的二维数组，使用编程练习2中的一个拷贝函数把该数组中的数据
	拷贝到另一个二维数组中。
	(因为二维数组是数组的数组，所以可以使用一维数组的拷贝函数来处理数组中的每个子数组)。
	#include<stdio.h>
	void copy(double ar[], double cr[], int n);
	int main(void)
	{	
		int i,k;
		double exp[5][2] = { {1.0,3.0},{2.0,4.0},{7.0,5.0},{6.0,8.0},{9.0,0} };
		double ptr[5][2];
		copy(ptr[0],exp[0], 10);
		for (i = 0; i < 5; i++)
			for (k = 0; k < 2; k++)
				printf(" ptr[%d][%d]=%g\n",i,k, ptr[i][k]);
		return 0;
	}
	void copy(double ar[], double cr[], int n)
	{
		int i;
		for (i = 0; i < n; i++)
			*(ar+i) = *(cr+i);
	}
	
	8.使用编程练习2中的拷贝函数，把一个内含7个元素的数组中第3-5个元素拷贝至内含3个元素的数组中；
	该函数本身不需要修改，只需要选择合适的实际参数。
	#include<stdio.h>
	void copy(double ar[], double cr[], int n);
	int main(void)
	{	
		double exp[7] = { 1.1,2.2,3.3,4.4,5.5,6.6,7.7 };
		double get[3];
		copy(get,exp+3, 3);
		printf("get[0]=%g\nget[1]=%g\nget[2]=%g\n", get[0], get[1], get[2]);
		return 0;
	}
	void copy(double ar[], double cr[], int n)
	{
		int i;
		for (i = 0; i < n; i++)	
			*(ar + i) = *(cr + i);		
	}

	
	9.编写一个程序，初始化一个double类型的3*5二维数组，使用一个函数将其拷贝到另一个二维数组中；
	还要编写一个函数来显示两个数组的内容。这两个函数应能处理任意N*M数组。

	#include<stdio.h>
	#define fir 3
	#define sec 5
	void copy(double ar[], double cr[], int n);
	void show(double ar[], double cr[], int n);
	int main(void)
	{	
		double exp[fir][sec] = { {1.1,2.1,3.1,4.1,5.1},
				 {1.2,2.2,3.2,4.2,5.2},
				 {1.3,2.3,3.3,4.3,5.3}};
		double ptr[fir][sec];
		copy(ptr[0], exp[0], fir*sec);
		show(ptr[0], exp[0], fir*sec);
		return 0;
	}
	void copy(double ar[], double cr[], int n)
	{
		int i;
		for (i = 0; i < n; i++)	
			*(ar + i) = *(cr + i);		
	}
	void show(double ar[], double cr[], int n)
	{
		int i,k;
		for (i = 0; i < n/sec; i++)
			for (k = 0; k < n / fir; k++)
			{
				printf("exp[%d][%d]=%g\n", i, k, *(cr++));
				printf("ptr[%d][%d]=%g\n\n", i, k, *(ar++));
			}	
	}


	
	10.编写一个函数，把两个数组中相对应的元素相加，然后把结果储存到第三个数组中；
	函数接受3个数组名和一个数组大小，在一个简单的程序中测试该函数。
#include<stdio.h>
#define x 4
#define y 5
#define z 5	//(x>y)?x:y;
void sum(int ar[], int cr1[], int cr2[], int n);
int main(void)
{
	int exp1[x] = { 2,4,5,8 };
	int exp2[y] = { 1,0,4,6,2};
	int ptr[z];
	int i;	
	sum(ptr, exp1, exp2, z);	
	for (i = 0; i < z; i++)
		printf("%d, ", *(ptr+i));	
	return 0;
}
void sum(int ar[], int cr1[], int cr2[], int n)
{
	int i;
	if (x >= y)
	{
		for (i = 0; i < z; i++)
		{
			if(i < y)			
				*(ar + i) = *(cr1 + i) + *(cr2 + i);			
			else		
				*(ar + i) = *(cr1 + i);	
		}
	}
	else
	{
		for (i = 0; i < z; i++)
		{
			if (i < x)			
				*(ar + i) = *(cr1 + i) + *(cr2 + i);			
			else		
				*(ar + i) = *(cr2 + i);	
		}
	}
}
	

	11.编写一个程序，声明一个int类型的3*5二维数组，并用合适的值初始化它；
	该程序打印数组中的值，然后各值翻倍，并显示出各元素的新值。
	编写一个函数显示数组的内容，再编写一个函数把各元素的值翻倍
	这两个函数都以函数名和行数作为参考；

#include<stdio.h>
#define m 5
void show(int ar[][m], int n);
void add(int ar[][m], int n);
int main(void)
{
	int exp[3][m] = { {1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15} };
	show(exp, 3);
	add(exp, 3);
	show(exp, 3);
	return 0;
}
void show(int ar[][m], int n)
{
	int i;	
	for (i = 0; i < n*m; i++)
		printf("%2d, ", *(*ar+i));
	putchar('\n\n');	
}
void add(int ar[][m], int n)
{
	int i;
	for (i = 0; i < n*m; i++)		
			*(*ar+i) *= 2;
}

	12.重新写程序清单10.7的rain.c程序，把main()中的主要任务都改用函数来完成；
	
#include<stdio.h>
#define months 12
#define years 5
void permonth(float ar[][months], int n);
void peryear(float ar[][months], int n);
int main(void)
{
	const float rain[years][months] =
	{
		{4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},
		{8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3},
		{9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},
		{7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},
		{7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}
	};	
	peryear(rain, years);
	permonth(rain, years);
	return 0;
}
void permonth(float ar[][months], int n)
{
	int m,y;
	float total;
	printf("Months:	Averages:\n");
	for (m = 0; m < months; m++)
	{
		for (total=0,y = 0; y < years; y++)
			total += ar[y][m];
		printf("%2d:	%.1f\n", m+1, total/years);
	}
	return;
}
void peryear(float ar[][months], int n)
{
	int m, y;
	float total,all;
	all = 0;
	printf("Years:	Averages:\n");
	for (y = 0; y < years; y++)
	{
		for (total = 0, m = 0; m < months; m++)		
			total += ar[y][m];
		all += total;		
		printf("%4d:	%.1f\n", y + 2010, total);
	}
	printf("\nThe yearly average is %.1f inches.\n\n", all / years);
	return;
}


	13.编写一个程序，提示用户输入3组数，每组包含5个double类型的数据(假设无非法输入)
	程序应完成下列任务：
	①把用户输入的数据储存在3*5的数值中
	②计算每组(5个)数据的平均值
	③计算所有数据的平均值
	④找出这15个数据中的最大值
	⑤打印结果
	每个任务都要使用单独的函数来完成；
	完成任务②，要编写一个计算并返回一维数组平均值的函数；利用循环调用该函数3次；
	对于其他任务，应该把整个数组作为参数；完成②③的函数应该把结果返回主调函数；

#include<stdio.h>
#define q 3	//数组第一个下标
#define m 5	//数组第二个下标
void input(double ar[][m], int a, int b);
double ave1(double ar[][m], int a);
double ave2(double ar[][m], int a,int b);
double max(double ar[][m], int a,int b);
void show(void);
int main(void)
{	
	show();
	return 0;		
}
void input(double ar[][m], int a, int b)
{
	int i, k;	
	for (i = 0; i < a; i++)
		for (k = 0; k < b; k++)
			scanf_s("%lf", &ar[i][k]);			
}
double ave1(double ar[][m], int a)
{
	int i;
	double total;
	for(total=0,i=0;i<m;i++)	
		total += ar[a][i];	
	return total / m;
}
double ave2(double ar[][m], int a, int b)
{
	int i,k;
	double total = 0;
	for(k=0;k<q;k++)
		for ( i = 0; i < m; i++)
			total += ar[k][i];
	return total / (q*m);
}
double max(double ar[][m], int a, int b)
{
	int i, k;
	double max;
	max = ar[0][0];
	for (i = 0; i < a; i++)
		for (k = 0; k < b; k++)		
			if (ar[i][k] >= ar[0][0])
				max = ar[i][k];
	return max;		
}
void show(void)
{
	int i, k;
	double exp[q][m];
	input(exp, q, m);
	for (i = 0; i < q; i++)
	{
		for (k = 0; k < m; k++)
			printf("exp[%d][%d]=%g,	", i, k, exp[i][k]);
		putchar('\n');
	}
	for (i = 0; i < 3; i++)
		printf("row: %d, average:%g\n", i + 1, ave1(exp, i));
	printf("The total average value:%g\n", ave2(exp, q, m));
	printf("The max value is:%g\n", max(exp, q, m));
	return;
}



第十一章	字符串和字符串函数
	gets()\gets_s()\fgets()\puts()\fputs()\strcat()\strncat()\strcmp()\strncmp()\strcpy()\strncpy()\sprintf()\strchr()
	创建并使用字符串
	使用C库中的字符和字符串函数，并创建自定义的字符串函数
	使用命令行参数
	
	字符串是C语言中最有用、最重要的数据类型之一；
	C库提供大量用于读写、拷贝、比较、合并、查找字符串等；
	
	
11.1	表示字符串和字符串I\O
	
	第四章介绍过，字符串是以空字符\0结尾的char类型数组；
	由于字符串十分常用，所以C提供了许多专门用于处理字符串的函数
	本章将讨论字符串的性质、如何声明并初始化字符串，如何输入输出以及如何操控字符串
	
	#include<stdio.h>
	#define MSG "i am a symbolic string constant."
	#define m 81
	int main(void)
	{
		char words[m] = "i am a string in an array.";
		const char *pt1 = "Something is pointing at me.";
		puts("Here are some strings:");
		puts(MSG);
		puts(words);
		puts(pt1);
		words[8] = 'p';
		puts(words);
		return 0;
	}

	和printf()函数一样，puts()函数也属于stdio.h系列的输入\输出函数，但是与printf()不同的是：
	puts()函数只显示字符串，并且在显示末尾自动加上换行符。

	
11.1.1	在程序中定义字符串
	上面示例中使用了多种方法（字符串常量、char类型数组、指向char的指针）定义字符串；
	程序应该确保有足够的空间储存字符串；
	
	1	字符串字面量(字符串常量)
	用双引号括起来的内容称为字符串字面量，也叫做字符串常量；
	双引号中的字符和编译器自动加入末尾的\0字符，都作为字符串储存在内存中；
	
	从ANSIC标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串连起来的字符串常量；如
	char get[50]="hello, and"" how are"" you"" today!";
	等价于下面代码：
	cahr get[50]="hello, and how are you today!";
	
	如果要在字符串内部使用双引号，必须在双引号前面加上反斜杠\
	printf("\"run, stop,run!\" exclaimed Dick.\n");
	输出如下：
	"run, stop,run!" exclaimed Dick.

	字符串常量属于静态储存类别，说明如果在函数中使用字符串常量，该字符串只会被储存一次；
	在整个程序的生命周期内，即使函数被调用多次。
	用双引号括起来的内容被视为指向该字符串储存位置的指针。
	#include<stdio.h>
	int main(void)
	{
		printf("%s,%p,%c", "we", "are", *"space");
		return 0;
	}
	
	printf()根据%s转换说明打印we，根据%p打印一个地址，如果“are”代表一个地址，打印首字符的地址；
	最后，*“space”表示该字符串所指向地址上储存的值，应该是字符串首字符；

	2	字符串数组和初始化
	定义字符串数组时，必须让编译器知道需要多少空间；一种方法是用足够空间的数组储存字符串；如：
	const char ml[40]="nice cat.";
	const表明不会更改这个字符串；
	这种形式的初始化比标准的数组初始化形式简单得多：
	标准数组初始化：
	const char m1[40]={'n','i','c','e',' ','c','a','t','.','\0'};
	注意最后的空字符\0，没有这个空字符，这就不是字符串，而是一个字符数组。
	
	在指定数组大小时，要确保数组的元素个数至少要比字符串长度多1(为了容纳空字符)。
	所有未被使用的元素都被自动初始化为0（这里的0指的是char形式的空字符，不是数字符0）；
	如下所示：
	const char pet[8]="nice.";
	
	n	i	c	e	.	\0	\0	\0
	[0]	[1]	[2]	[3]	[4]	[5]	[6]	[7]
	
	通常，让编译器确定数组的大小很方便，省略初始化声明中的大小，编译器会自动计算数组大小：
	const char m2[]="If you can't think of anything, fake it.";
	
	让编译器确定初始化数组的大小很合理，因为处理字符串的函数通常都不知道数组的大小，
	这些函数通过查找字符串末尾的空字符确定字符串在何处结束。
	
	让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小
	声明数组时，数组大小必须是可求值的整数；在新增变长数组之前，数组的大小必须是整形常量及表达式：
	int n=8;
	char cookies[1];			//有效
	char cakes[2+5];			//有效，数组大小是整型常量表达式
	char pies[2*sizeof(long double)+1];	//有效
	char crumbs[n];			//变长数组
	
	字符数组名和其他数组名一样，是该数组首元素地址；
	char car[10]="Tate";
	那么下面表达式都为真：
	car==&car[0];
	*car=='T';
	*(car+1)==car[1]=='a';

	还可以使用指针表示法创建字符串。例如：
	const char *pt1="something is pointing at me.";
	该声明和下面的声明几乎相同：
	const char ar1[]="something is pointing at me."
	
	以上两个声明表明，pt1和ar1都是该字符串的地址。
	在这两种情况下，带双引号的字符串本身决定了预留给字符串的储存空间。
	尽管如此，这两种形式并不完全相同；

	3	数组和指针
	数组和指针形式有何不同？以上面的声明为例；
	①
	数组形式ar[]在计算机的内存中分配为一个内含29个元素的数组(每个元素对应一个字符，还加上一个末尾的\0)；
	每个元素被初始化为字符串字面量对应的字符；
	通常字符串都作为可执行文件的一部分储存在数据段中，当把程序载入内存时，也载入了程序中的字符串；
	字符串储存在静态存储区中，但是，程序在运行时才会为该数组分配内存，此时，才将字符串拷贝到数组中。
	注意，此时字符串有两个副本，一个是在静态内存中的字符串常量，另一个是储存在ar1数组中的字符串；

	此后，编译器便把数组名ar1识别为该数组首元素地址(&ar1[0])的别名，这里关键要理解，在数组形式中，
	ar1是地址常量，不能更改ar1，如果改变了ar1，则意味着改变了数组的储存位置(即地址)；
	可以进行类似ar1+1这样的操作，标识数组的下一个元素，但是不允许进行++ar1这样的操作；
	递增运算符只能用于变量名前，不能用于常量。

	②
	指针形式(*pt1)也使得编译器为字符串在静态存储区预留29个元素的空间，另外，一旦开始执行程序，
	它会为指针变量pt1留出一个储存位置，并把字符串的地址储存在这个指针变量中；
	该变量最初指向该字符串的首字符，但是它的值可以改变，因此可以使用递增运算符；
	如++pt1将指向第二个字符；
	
	字符串字面量被视为const数据。由于pt1指向这个const数据，所以应该把pt1声明为指向const数据的指针；
	这意味着不能用pt1改变它所指向的数据，但是仍然可以改变pt1的值(即，pt1指向的位置)
	如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const

	总之，初始化数组把静态储存区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针；
	如下面程序示例：
	#include<stdio.h>
	#define MSG "I'm special"
	int main(void)
	{
		char ar[] = MSG;
		const char *pt = MSG;
		printf("address of\"I'm special\":%p\n", "I'm special");
		printf("	address ar:%p\n", ar);
		printf("	address pt:%p\n", pt);
		printf("	address of MSG:%p\n", MSG);
		printf("address of\"I'm special\":%p\n", "I'm special");
		return 0;
	}
	
	运行结果：
	address of"I'm special":       	00007FF6A4469C70
	address ar:                     	000000DE0A9AF9A8
	address pt:                     	00007FF6A4469C70
	address of MSG:                 	00007FF6A4469C70
	address of"I'm special":        	00007FF6A4469C70

	该程序的输出说明了：
	①pt和MSG的地址相同，而ar的地址不同；
	②虽然字符串常量"I'm special"在程序两个printf()函数中出现了两次，但是编译器只使用了一个储存位置，
	而且与MSG的地址相同；
	编译器可以把多次使用的相同字面量储存在一处或多处；另一个编译器可能在不同的位置储存3个"I'm special"
	③静态数据使用的内存与ar使用的动态内存不同，不仅值不同，特定编译器甚至使用不同的位数标识这两种内存

	数组和指针标识字符串的区别通常不太重要，但是这取决于想用程序做什么；
	
	4	数组和指针的区别

	初始化字符数组来储存字符串和初始化指针来指向字符串有何区别？(指向字符串是指向字符串的首字符)
	例如：
	char heart[]="I love Tillie!";
	const char *head="I love Millie";
	两者主要区别是：数组名heart是常量，而指针名head是变量，那么实际使用有什么区别呢?
	①首先两者都可以使用数组表示法：

	for (i = 0; i < 6; i++)
		putchar(heart[i]);
	for (i = 0; i < 6; i++)
		putchar(head[i]);

	②其次，两者都能进行指针加法操作
	
	for (i = 0; i < 6; i++)
		putchar（*(heart+i));
	for (i = 0; i < 6; i++)
		putchar(*(head+i));

	但是，只有指针表示法可以进行递增操作：

	while(*(head)!='\0')
		putchar(*(head++));

	假设想让head和heart统一，可以这样做：
	head=heart；
	这使得head指针指向heart数组的首元素；

	但是不能这样做：
	heart=head；//非法构造

	这类似于x=3；和3=x；的情况，赋值运算的左侧必须是变量(或者说是可修改的左值)，
	顺带一提，head=heart；不会导致head指向的字符串消失，这样做只是改变了储存在head中的地址；
	另外，还可以改变heart数组中元素的信息：
	heart[7]='M';或者*(heart+7)='M';
	
	数组的元素是变量(除非被声明为const)，但是数组名不是变量。
	
	char*word="frame";
	word[1]='l';	//error；
	这样的行为是未定义的，这样的语句会导致内存访问错误；
	原因是编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量；
	因此，建议在把指针初始化为字符串字面量时使用const限定符；
	然而，把非const数组初始化为字符串字面量却不会导致类似的问题；
	因为数组获得的是原始字符串的副本；

	总之，如果不修改字符串，不要用指针指向字符串字面量；

	5	字符串数组
	如果创建一个字符串数组会很方便，可以通过下标访问多个不同的字符串；如下面示例：
	演示程序使用了两种方法：指向字符串的指针数组和char类型数组的数组：

#include<stdio.h>
#define SLEN 40
#define LIM 5
int main(void)
{
	const char *mytalents[LIM] = 
	{
		"Adding numbers swiftly",
		"Multiplying accurately",
		"Stashing data",
		"Following instructions to the letter",
		"Understanding the C language" 
	};
	char yourtalents[LIM][SLEN] = 
	{
		"Walking in a straight line",
		"Sleeping",
		"Watching television",
		"Mailing letters",
		"Reading email" 
	};
	int i;
	puts("Let's compare talents.");
	printf("%-36s	%-25s\n", "My Talents", "Your Talents");
	for (i = 0; i < LIM; i++)
		printf("%-36s	%-25s\n", mytalents[i], yourtalents[i]);
	printf("\nsizeof mytalents:%zd,sizeof yourtalents:%zd\n", 
		sizeof(mytalents), sizeof(yourtalents));

	//printf("%zd\n", sizeof(mytalents));
	//printf("%zd\n", sizeof(*mytalents));
	//printf("%zd\n", sizeof(mytalents[0]));
	//printf("%zd\n", sizeof(mytalents[0][0]));

	//printf("%zd\n", sizeof(yourtalents));
	//printf("%zd\n", sizeof(*yourtalents));
	//printf("%zd\n", sizeof(yourtalents[0]));
	//printf("%zd\n", sizeof(yourtalents[0][0]));
	return 0;
}
	
	运行结果：

	Let's compare talents.
	My Talents                              		Your Talents
	Adding numbers swiftly                  	Walking in a straight line
	Multiplying accurately                  	Sleeping
	Stashing data                           		Watching television
	Following instructions to the letter    	Mailing letters
	Understanding the C language            	Reading email

	sizeof mytalents:40,sizeof yourtalents:200

	从某些方面来看，mytalents和yourtalents非常相似，两者都代表5个字符串，
	使用一个下标时，都分别表示一个字符串，如mytalents[0]和yourtalents[0]；
	
	使用两个下标时都分别表示一个字符，如mytalents[1][2]表示数组第2个指针指向的字符串第3个字符'l',
	yourtalents[1][2]表示数组的第2个字符串第3个字符'e'；而且初始化方式也相同。
	
	但是，他们也有区别。mytalents数组是一个内含5个指针的数组，在我们系统中共占用40字节(每个指针8字节)；
	yourtalents是一个内含5个数组的数组，每个数组内含40个char类型的值，共占用200字节(每个char，1字节)

	所以，虽然mytalents[0]和yourtalents[0]都分别表示一个字符串,(其实是*mytalents 和yourtalents[0]的区别;)
	(再比如mytalents[1]和yourtalents[1]，其实是*(mytalents+1)和yourtalents[1]，分别是他们的第二个元素字符串)
	但是两者的类型并不同；
	mytalents中的指针指向初始化时所用的字符串字面量的位置，这些字符串字面量被储存在静态内存中；
	而yourtalents中的数组则储存着字符字面量的副本，所以每个字符串都被储存了两次；
	此外，为字符串数组分配内存的使用效率较低，
	yourtalents中的每个元素大小必须相同，而且必须是能储存最长字符串的大小；
	
	我们可以把yourtalents想象成矩形二维数据，每行的长度是40字节，总共5行；
	把mytalents想象成不规则的数组，每行的长度不同，总共5行；
	(实际上mytalents数组的指针元素所指向的字符串还不必储存在连续的内存中，指针是根据指向地址来寻址的)
	
	下图解释了矩形数组和不规则数组：
	
	apple\0\0		//5字符+2空字符=7；
	pear\0\0\0	//4字符+3空字符=7；
	orange\0		//6字符+1空字符=7；

	↑char fruit[3][7]={"apple","pear","orange"};

	↓const char *fruit[3]={"apple","pear","orange"};
	apple		//5	
	pear		//4
	orange		//6

	
	综上，如果要用数组表示一系列带显示的字符串，请使用指针数组，因为它比二维字符数组的效率高；
	但是，指针数组也有自身的缺点；
	mytalents中的指针指向的字符串字面量不能更改；
	而yourtalents中的内容可以更改；
	
	所以如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针；


11.1.2	指针和字符串
	
	实际上，字符串的绝大多数操作都是通过指针来完成的；如下程序：
	#include<stdio.h>
	int main(void)
	{
		const char *mesg = "Don't be a fool!";
		const char *copy;
		copy = mesg;
		printf("%s\n", copy);
		printf("mesg=%s;&mesg=%p;value=%p\n", mesg, &mesg, mesg);
		printf("copy=%s;&copy=%p;value=%p\n", copy, &copy, copy);
		return 0;
	}
	
	运行结果：
	Don't be a fool!
	mesg=Don't be a fool!;&mesg=000000EFCE0FFCF8;value=00007FF6F8C09CF0
	 copy=Don't be a fool!;& copy=000000EFCE0FFD18;value=00007FF6F8C09CF0

	你可能认为该程序拷贝了字符串"Don't be a fool!"，程序的输出似乎也验证了这个猜测；
	但，我们来分析最后两个printf()的输出；
	第1项，mesg和copy都以字符串形式输出，两个字符串都是"Don't be a fool!"
	第2项，打印两个指针的地址；如运行结果所示，两个指针mesg和copy分别储存在FCF8和FD18内存中
	第3项，显示两个指针的值，所谓指针的值，就是它储存的地址，这两个值一样，说明它们都指向一个位置。

	因此程序并未拷贝字符串，语句copy=mesg，把mesg的值赋给copy，即让copy也指向mesg指向的字符串

	为什么要这么做？为何不拷贝整个字符串？
	假设数组有50个元素，考虑一下哪种方法更有效率：老贝一个地址还是拷贝整个数组？
	通常，程序需要完成某些操作，只需要知道地址就可以了；
	如果确实需要拷贝整个数组，可以使用strcpy()或strncpy()函数

	
11.2字符串输入

	如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串；
	
11.2.1	分配空间
	要做的第一件事就是分配空间，以储存稍后读入的字符串。
	不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间。计算机不会这样做。
	假如：
	char *name;
	scanf("%s",name);
	在程序在读入name时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止；
	因为scanf()要把信息拷贝到指定的地址上，而此时该参数是个未初始化的指针，name可能会指向任何地方；
	最简单的方法是，在声明时指明数组的大小：
	char name[81];
	现在name是一个已分配块(81字节)的地址。还有一种方法是使用C库函数来分配内存，在12章介绍

	为字符分配内存后，便可以读入字符串。C库提供了许多读取字符串的函数：scanf(),gets(),fgets()
	
11.2.2	不幸的get()函数
	
	在读取字符串时，scanf()和转换说明%s只能读取一个单词。可是程序经常要读取一整行的输入；
	许多年前，gets()函数就用于处理这种情况；
	它读取整行输入直到换行符，然后丢弃换行符，储存其余字符，并在这些字符末尾添加一个空字符，称为字符串
	经常和puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符；示意程序如下：

	#include<stdio.h>
	#define STLEN 81
	int main(void)
	{
		char words[STLEN];
		puts("Enter a string,please.");
		gets(words);
		printf("your string twice:\n");
		printf("%s\n", words);
		puts(words);
		return 0;
	}

	但是在不同的编译器上会显示警告，问题出在gets()唯一的参数是words，它无法检查数组是否装得下输入行；
	上一章介绍过，数组名会被转换成该数组首元素的地址，因此，gets()函数只知道数组的开始处，并不知道有多少个元素
	如果输入的字符串过长，会导致缓冲区溢出，即多余的字符超出了指定的目标空间；
	如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题，如果它们擦写掉了程序中的其他数据，
	最终会导致程序异常中止或其他情况；比如把STLEN改成5，然后输入超出5个字符的输入：程序运行后引发异常；

	该函数的不安全行为造成了隐患，有些人通过编程，利用gets()插入和运行一些破坏系统安全的代码，逐渐被摒弃

11.2.3	gets()的替代品
	过去通常用fgets()来替代gets()，fgets()函数稍微负责些，在处理输入方面与gets()略有不同；
	C11标准新增的fgets_s()函数也可以替代gets()。该函数与gets()更接近，而且可以替换现有代码中的gets()。
	但是它是stdio.h输入输出函数中的可选扩展，所以支持C11的编译器也不一定支持它。
	
	1.fgets()函数(和fputs()函数)
	fgets()函数通过第2个参数限制读入的字符数来解决溢出问题；
	fgets()和gets()的区别如下：
	①fgets()函数的第2个参数指明了读入字符的最大量，如果该参数是n，那么fgets()将读入n-1个字符，或者读到遇到的
	第一个换行符为止；
	②如果fgets()读到一个换行符，会把它储存在字符串中，这点与gets()不同，gets()会丢弃换行符；
	③fgets()的第3个参数指明要读入的文件，如果读入从键盘输入的数据，则以stdin(标准输入)作为参数；
	该标识符定义在stdio.h中；
	
	因为fgets()函数把换行符放在字符串的末尾(假设输入行不溢出)，通常要与fputs()函数配对使用；
	除非该函数不在字符末尾添加换行符；fputs()函数的第2个参数指明它要写入的文件；
	如果要显示在计算机显示器上，应使用stdout(标准输出)作为该参数；示例程序如下：
	
	#include<stdio.h>
	#define STLEN 14
	int main(void)
	{
		char words[STLEN]; 
		puts("Enter a string, please.");
		fgets(words, STLEN, stdin); 
		printf("Your string twice (puts(), then fputs()) :\n"); 
		puts(words);
		fputs(words, stdout);
		puts("Enter another string, please."); 
		fgets(words, STLEN, stdin); 
		printf("Your string twice (puts(), then fputs()) : \n"); 
		puts(words); 
		fputs(words, stdout);
		puts("Done."); 
		return 0;
	}
	
	运行结果：

	Enter a string, please.
	apple pie	//输入
	Your string twice (puts(), then fputs()) :
	apple pie
			//此换行符为puts()所打印；
	apple pie
	Enter another string, please.
	strawberry shortcake	//输入
	Your string twice (puts(), then fputs()) :
	strawberry sh	//puts()打印
	strawberry shDone.	//fputs()打印无换行符

	第1行输入，apple pie,比fgets()读入的整行输入短，因此，apple pie\n\0被储存在数组中;(gets()则会丢弃换行符)
	所以当puts()显示该字符串时又在末尾添加了换行符，而fputs()不在末尾添加换行符，所以打印末尾没有换行符；
	
	第2行输入超过了大小限制，所以fgets()只读入了13个字符，并把strawberry sh\0储存在数组中。

	fputs()函数返回指向char的指针，如果一切顺利，该函数返回地址与传入的第一个参数相同。
	但是如果函数读到文件结尾，它将返回一个特殊的指针：空指针，该指针保证不会指向有效的数据；
	在代码中用数字0来代替，在C语言中用宏NULL来代替更长见。
	#include<stdio.h>
	#define STLEN 10
	int main(void)
	{
		char words[STLEN]; 
		puts("Enter strings(empty line to quit):");
		while (fgets(words, STLEN, stdin) != NULL && words[0] != '\n')
			fputs(words, stdout);
		puts("Done."); 
		return 0;
	}

	运行结果：

	Enter strings(empty line to quit):
	can you hear me?	//输入
	can you hear me?
			//输入回车
	Done.
	
	虽然STLEN被设置为10，但是该程序在处理过长的输入时完全没问题。
	分析：
	程序中的fgets()一次读入STLEN-1个字符(该例中为9个)，所以它第一次读取的是"can you h"
	并储存为can you h\0；接着fputs()打印该字符串，且并未换行；然后while进行下一轮迭代；
	fgets()继续从剩余的输入中读取“ear me?\n”fgets()将其储存为ear me?\n\0,
	fputs()打印该字符，由于\n，光标被移至下一行开始处；
	
	系统使用缓冲的I/O，这意味着用户按下回车键之前，输入都被储存在临时存储区（也就是缓冲区）中
	按下回车后就在输入中增加了一个换行符，并把整行输入发送给fgets()。
	对于输出，fputs()把字符发送给另一个缓冲区，当发送换行符时，缓冲区中的内容被发送至屏幕上。
	fgets()储存换行符有好处也有坏处，坏处是你可能并不想把换行符储存在字符串中，这样换行符会带来一些麻烦；
	好处是对于储存的字符串而言，检查末尾是否有换行符可以判断是否读取了一整行；
	如果不是一整行，要妥善处理一行中剩下的字符；

	首先，如何处理掉换行符？一个方法是在已储存的字符串中查找换行符，并将其替换成空字符：
	while(words[i]!='\n')
		i++
	words[i]='\n';
	
	其次，如果仍有字符串留在输入行怎么办？一个办法是如果目标数组装不下一整行输入，就丢弃多出的字符：
	while(getchar()!='\n')
		continue;

	下面是程序示例：
	#include<stdio.h>
	#define STLEN 10
	int main(void)
	{
		char words[STLEN]; 
		int i;

		puts("Enter strings(empty line to quit):");
		while (fgets(words, STLEN, stdin) != NULL && words[0] != '\n')
		{
			i = 0;
			while (words[i] != '\n'&&words[i] != '\0')
				i++;
			if (words[i] == '\n')
				words[i] = '\0';
			else	//如果word[i]=='\0'则执行这部分代码
				while (getchar() != '\n')
					continue;
			puts(words);
		}	
		puts("Done."); 
		return 0;
	}

	while (words[i] != '\n'&&words[i] != '\0')//遍历字符串，直到遇到换行符或空字符；
	如果先遇到换行符，下面的if语句就将其替换成空字符，如果先遇到空字符，else部分便丢弃掉输入行剩余字符；
	下面是该程序的示例输出：

	Enter strings(empty line to quit):
	This	//输入	
	This
	program seems//输入
	program s
	unwilling to accept long lines//输入
	unwilling
	but it doesn't get stuck on long//输入
	but it do
	lines either.//输入
	lines eit
		//输入
	Done.
	
	
	2.gets_s()函数

	C11新增的gets_s()函数和fgets()类似，用一个参数限制读入的字符数；假设把上面程序fgets()换成gets_s()；
	其他内容不变，那么下面的代码将把一行输入中的前9个字符读入words数组中，假设末尾有换行符：
	gets_s(words,STLEN)；
	gets_s()与fgets()的区别如下：
	①gets_s()只从标准输入中读取数据，所以不需要第三个参数
	②如果gets_s()读取到换行符，会丢弃它二补数储存它
	③如果gets_s()读取到最大字符都没有读到换行符，会执行以下几步：
		a.首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直到读到换行符或文件结尾；
		   然后返回空指针。
		b.接着调用依赖实现的“处理函数”或你选择的其他函数，可能会中止或退出程序；

	第二个特性说明，只要输入行未超出最大字符数，gets_s()和gets()几乎一样；
	第三个特性说明，要使用这个函数还需要进一步学习；

	我们来比较下gets()、fgets()、gets_s()的适用性；
	如果目标存储区装得下输入行，3个函数都没问题；但是fgets()会保留输入末尾的换行符作为字符串的一部分；
	需要写额外的代码将其替换成空字符；
	
	如果输入行太长会怎么样？使用gets()不安全，它会擦写现有数据，存在安全隐患；gets_s()函数很安全，
	但是如果并不希望程序中止或退出，要知道如何编写特殊的“处理函数”；另外，如果打算让程序继续运行，
	gets_s()会丢弃该输入行的其余字符，无论你是否需要；
	由此可见，当输入太长，超过数组可容纳的字符数时，fgets()函数最容易使用，而且可以选择不同的处理方式；
	
	所以当输入与预期不符时，fgets()函数是最佳选择；

	3.s_gets()函数

	上面的示例程序演示了fgets()函数的一种用法：读取整行输入并用空字符代替换行符，读取一部分输入舍弃多余；
	既然没有处理这种情况的标准函数，我们就创建一个，在后面的程序中会用得上；

	下面是函数模板：
	char *s_gets(char *st, int n)
	{
		char*ret_val;
		int i = 0;
		ret_val = fgets(st, n, stdin);
		if (ret_val)//即，ret_val！=NULL
		{
			while (st[i] != '\n'&&st[i] != '\0')
				i++;
			if (st[i] == '\n')
				st[i] = '\0';
			else
				while (getchar() != '\n')
					continue;
		}
		return ret_val;
	}

	如果fgets()返回NULL说明读到文件结尾或出现读取错误，s_gets()函数跳过了这个过程；
	它模仿fgets()程序的处理方法，如果字符串中出现换行符，就用空字符替代，如果字符串中出现空字符，就丢弃多余字符
	然后返回与fgets()相同的值；

	为什么要丢弃过长输入中的余下字符？因为输入行中多出来的字符会被留在缓冲区中，成为下一次读取语句的输入；
	比如下一个读取的可能是double类型的值，这可能会导致程序崩溃；
	丢弃输入行余下的字符保证了读取语句与键盘输入同步；

	我们设计的s_gets()函数并不完美，它最严重的缺陷是遇到不适合的输入时毫无反应，
	它丢弃多余的字符时，既不通知程序也不告知用户，但是用来替换前面程序中的gets()足够了；


11.2.4	scanf()函数
	我们再来研究下scanf()
	scanf()函数与gets()或者fgets()的区别在于它们是如何确定字符串的末尾：scanf()更像是“获取单词”函数，
	而不是"获取字符串"函数：
	如果预留的存储区装得下输入行，gets()或者fgets()会读取第一个换行符之前所有的字符
	scanf()有两种方法确定输入结束，无论哪种方法，都从第一个非空白字符作为字符串的开始；
	如果使用%s转换说明，以下一个空白字符(空行、空格制表符或换行符)作为字符串(不包括空白字符)的结束；
	如果指定了字段宽度，如%10s,那么scanf()将读取10个字符或读到第一个空白字符停止(先满足的条件就是结束条件)
	如图;（()：表示空白字符）
	
	输入的语句	原输入序列	name中的内容	剩余的输入序列
	scanf("%s",name)	Fleebert()Hup	Fleebert		 ()Hup
	scanf("%5s",name)	Fleebert()Hup	Fleeb		 ert()Hup
	scanf("%5s",name)	Ann()Ular		Ann		 ()Ular
	
	前面介绍过，scanf()函数返回一个整数值，该值等于scanf()成功读取的项数或EOF(读到文件结尾时返回)
	
	下面程序演示了scanf()函数中指定字段宽度的用法：
	# include <stdio.h>
	int main(void)
	{
		char name1[11], name2[11]; 
		int count; 
		printf("Please enter 2 names. \n"); 
		count = scanf_s("%5s %10s", name1, 11,name2,11) ;
		printf("I read the %d names %s and %s. \n", count, name1, name2) ;
		return 0;
	}
	
	下面是该程序的3个输出：

	Please enter 2 names.
	jesse jukes	//输入
	I read the 2 names jesse and jukes.

	Please enter 2 names.
	liza applebottham	//输入
	I read the 2 names liza and applebotth.
	
	Please enter 2 names.
	portensia callowit	//输入
	I read the 2 names porte and nsia.

	分析：
	第一个输出示例，两个名字的字符个数都未超过字段宽度；正常显示
	第二个输出示例，只读入了applebottham的前10个字符；
	第三个输出示例，portensia的后4个字符被写入name2中，因为第二次scanf()时，是从上一次调用结束的地方继续读取
	
	根据输入数据的性质，用fgets()读取从键盘输入的数据更合适，例如scanf()无法完整读取书名或歌曲名，除非是单词
	scanf()的典型用法是读取并转换混合数据类型为某种标准形式；
	例如，如果输入行包含一种工具名，库存量和单价，就可以使用scanf()，否则可能要自己拼凑一个函数处理一些输入检查
	如果一次只输入一个单词，用scanf()也没问题

	scanf()和gets()类似，也存在着一些潜在的缺点，如果输入行的内容过长，scanf()也会导致数据溢出；
	不过在%s转换说明中使用字段宽度可以防止溢出。(但是还是没法清理缓存区的多余数据，需要额外处理)；


11.3	字符串输出
	C有3个标准库函数用于打印字符串：put()、fputs()、printf()
	
11.3.1	puts()函数
	
	puts()函数很容易使用，只需要把字符串的地址作为参数传递个它即可；如下：

	# include <stdio.h>
	# define DEE "I am a # defined string."
	int main(void)
	{
		char str1[80] = "An array was initialized to me.";
		const char * str2 = "A pointer was initialized to me.";
		puts("I'm an argument to puts() .");
		puts(DEE);
		puts(str1);
		puts(str2);
		puts(&str1[9]);
		puts(str2 + 10);
		return 0;
	}

	运行结果如下：
	I'm an argument to puts() .
	I am a # defined string.
	An array was initialized to me.
	A pointer was initialized to me.
	was initialized to me.
	was initialized to me.
	
	如上所示，每个字符串独占一行，因为puts()在显示字符串时会自动在末尾添加一个换行符；
	该示例再次说明，双引号括起来的内容是字符串常量，且被视为该字符串的地址；
	另外，储存字符串的数组名也被看作是地址，后两个输出表达是从数组元素位置或指针指向位置起开始输出；

	puts()如何知道在何处停止？该函数在遇到空字符时就停止输出，所以必须保证有空字符，下面是错误示范：
	#include <stdio.h>
	int main(void)
	{ 
		char side_a[] = "Side A";
		char dont[] = { 'W','O','W','!'};
		char side_b[] = "Side B";
		puts(dont);/*dont 不是一个字符串*/
		return 0;
	}

	由于dont缺少一个表示结束的空字符，所以它不是一个字符串，因此puts()不知道在何处停止。它会一直打印dont
	后面内存中的内容，直到发现一个空字符为止。

	
11.3.2	fputs()函数
	fputs()函数是puts()针对文件定制的版本。它们的区别如下:
	①fputs()函数的第二个参数指明要写入数据的文件，如果要打印在显示器上，可以用stdout作为该参数；
	②与puts()不同，fputs()不会在输出的末尾添加换行符。
	注意，gets()丢弃输入中的换行符，但是puts()在输入中添加换行符；
	fputs()保留输入中的换行符，fputs()不在输入中添加换行符；

	
11.3.3	printf()函数
	
	跟puts()一样，printf()也把字符串的地址作为参数，printf()函数用起来没有puts()函数那么方便；
	但它更加多才多艺，因为它可以格式化不同的数据类型。
	与puts()不同的是，printf()不会自动在每个字符串末尾加上一个换行符，因此必须在参数中指明在哪里使用换行符；

	
11.4	自定义输入/输出函数
	不一定非要使用C库中的标准函数，如果无法使用这些函数或者不想使用它们，完全可以在getchar()和putchar()
	的基础上自定义所需要的函数；
	假设你需要一个类似puts()但是不会自动添加换行符的函数：
	#include<stdio.h>
	void put1(const char *string)
	{
		while (*string != '\0')		//等效于while(*string)
			putchar(*string++);
	}

	指向char的指针string最初指向传入参数的首元素。因为该函数不会改变传入的字符串，所以形参使用了canst限定符；
	打印了首元素的内容后，指针递增1，指向下一个元素；
	while循环重复这一过程，直到指针指向包含空字符的元素。记住，++的优先级高于*，
	因此putchar(*string++)打印string指向的值，递增的是string本身，而不是递增它所指向的字符；

	可以把这段程序作为编写字符串处理函数的模型，因为每个字符串都以空字符结尾，所以不用给函数传递字符串大小；
	函数依次处理每个字符，直到遇到空字符；
	用数组表示法编写这个函数为：

	#include<stdio.h>
	void put1(const char *string)
	{
		int i = 0;
		while (string[i] != '\0')	//等效于while(string[i])
			putchar(string[i++]);
	}

	为什么上面的形参是 const char *string ，而不是const char string[]？
	从技术方面看，两者等价且都有效，带方括号的写法是为了提醒用户，该函数处理的是数组；
	然而，如果要处理字符串，实际参数可以是数组名，用双引号括起来的字符串，或者声明为cahr *类型的变量；
	用const char *string可以提醒用户，实际参数不一定是数组。

	假设要设计一个类似puts()的函数，而且该函数还给出待打印字符的个数，添加一个新功能：
	#include <stdio.h>
	int put2(const char*string)
	{
		int count = 0;
		while (*string)	/*常规用法*/
		{
			putchar(*string++);
			count++;
		}
		putchar('\n');	/*不统计换行符*/
		return(count);
	}

	
	下面使用一个简单的驱动程序来测试put1()和put2():
	
# include <stdio.h>
void put1(const char *);
int put2(const char *);
int main(void)
{
	put1("If I'd as much money");
	put1("as I could spend, \n");
	printf("I count %d characters. \n",put2("I never would cry old chairs to mend."));
	return 0;
}
void put1(const char *string)
{
	int i = 0;
	while (string[i] != '\0')	
		putchar(string[i++]);
}
int put2(const char*string)
{
	int count = 0;
	while (*string)	
	{
		putchar(*string++);
		count++;
	}
	putchar('\n');	
	return(count);
}
	
	程序中使用printf()打印put2()的值，但是为了获得put2()的返回值，计算机必须先执行put2()；
	因此在打印字符数之前先打印了传递给该函数的字符串；输出如下：

	If I'd as much moneyas I could spend,
	I never would cry old chairs to mend.
	I count 37 characters.
	
	
11.5	字符串函数
	C库提供了多个处理字符串的函数，这些函数原型放在string.h头文件中；
	最常用的有strlen()、strcat()、strcmp()\strncmp()、strcopy()\strncopy()；
	另外还有sprintf()函数，其原型在stdio.h头文件中；

	
11.5.1	strlen()函数
	strlen()函数函数用于统计字符串的长度；下面的函数可以缩短字符串的长度，其中用到了strlen()：
	
	void fit(char *string, unsigned int size)
	{
		if (strlen(string) > size)
			string[size] = '\0';
	}
	
	该函数要改变字符串，所以函数头在声明string时没有使用const限定符
	下面程序测试了fit()函数；注意代码中使用了C字符串常量的串联特性。
	
	#include<stdio.h>
	#include<string.h>
	void fit(char *, unsigned int);
	int main(void)
	{
		char mesg[] = "Things should be as simple as possible,""but not simpler.";
		puts(mesg);
		fit(mesg, 38);
		puts(mesg);
		puts("Let's look at some more of the string.");
		puts(mesg + 39);
		return 0;
	}
	void fit(char *string, unsigned int size)
	{
		if (strlen(string) > size)
			string[size] = '\0';
	}
	

	运行结果：

	Things should be as simple as possible,but not simpler.
	Things should be as simple as possible
	Let's look at some more of the string.
	(空格) but not simpler.

	fit()函数把第39个元素的逗号换成\0字符，puts()函数在空字符处停止输出，并忽略其余字符；
	然而这些字符还留在缓冲区中；puts(mesg + 39)把这些字符打印了出来；
	mesg+39是mesg[39]的地址，该地址上储存的是空格字符，
	所以put()显示该字符并继续输出直到遇到原来字符串中的空字符。
	
	下面图示演示了这一过程：puts()函数和空字符
	原始字符串：

	hold on to your hats,hackers.\0

	调用fit(mesg,7)之后的字符串：
	
	hold on\0to your hats,hackers.\0
	↑           ↑ ↑                               ↑
	开始  结束 开始		结束
	----------  ----------------------------
	puts(mesg)	puts(mesg+8)

11.5.2	strcat()函数	//拼接字符串

	strcat()函数用于拼接字符串，函数接受两个字符串作为参数，该函数把第二个字符串的备份附加在第一个字符串末尾；
	并把拼接后的新字符串作为第一个字符串，第二个字符串不变。

#include <stdio.h>
#include <string.h>/*strcat()函数的原型在该头文件中*/
#define SIZE 80
char*s_gets(char*st,int n); 
int main(void)
{
	char flower[SIZE];
	char addon[] = "s smell like old shoes.";
	puts("What is your favorite flower?");
	if (s_gets(flower, SIZE))
	{
		strcat_s(flower,80,addon);
		puts(flower);
		puts(addon);
	}
	else
		puts("End of file encountered!");
	puts("bye");
	return 0;
}
char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)//即，ret_val！=NULL
	{
		while (st[i] != '\n'&&st[i] != '\0')
			i++;
		if (st[i] == '\n')
			st[i] = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}

	
11.5.3	strncat()函数
	strcat()函数无法检查第一个数组是否能容纳第二个字符串；如果分配给第一个数组的空间不够大，
	多出来的字符溢出到相邻存储单元时就会出现问题。

	strncat()函数，将第三个参数指定了最大添加的字符数下面是程序示例：

#include <stdio.h>
#include <string.h>
#define SIZE 30
#define BUGSIZE 13
char *s_gets(char *st, int n);
int main(void)
{
	char flower[SIZE];
	char addon[] = "s smell like old shoes.";
	char bug[BUGSIZE];
	int available;

	puts("What is your favorite flower?");
	s_gets(flower, SIZE);
	if ((strlen(addon) + strlen(flower) + 1) <= SIZE)
		strcat_s(flower,SIZE, addon);
	puts(flower);
	puts("What is your favorite bug?");
	s_gets(bug, BUGSIZE);
	available = BUGSIZE - strlen(bug) - 1;
	strncat_s(bug, BUGSIZE,addon, available);
	puts(bug);
	return 0;
}
char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)//即，ret_val！=NULL
	{
		while (st[i] != '\n'&&st[i] != '\0')
			i++;
		if (st[i] == '\n')
			st[i] = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}
	
	运行结果：

	What is your favorite flower?
	Rose//输入
	Roses smell like old shoes.
	What is your favorite bug?
	Aphid//输入
	Aphids smell 

	strncat_s(bug, BUGSIZE,addon, available);available的值为允许拼接的字符数；
	应注意到，strcat()和gets()类似，也会导致缓冲区溢出。但是C11标准没有废弃该函数
	而废弃了gets()，是因为后者无法控制用户操作，而前者是程序员操作，有责任确保使用安全；

11.5.4	strcmp()函数	//比较字符串
	示例：

#include <stdio.h>
#include <string.h>
#define SIZE 40
#define ANSWER "Grant"
char *s_gets(char *st, int n);
int main(void)
{
	char try[SIZE];
	puts("Who is buried n Grant's tomb?");
	s_gets(try, SIZE);
	while (strcmp(try,ANSWER))//两者相同时候返回0，非0时进入循环
	{
		puts("No,that's wrong.try again.");
		s_gets(try, SIZE);
	}
	puts("That's right!");	
	return 0;
}
char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)//即，ret_val！=NULL
	{
		while (st[i] != '\n'&&st[i] != '\0')
			i++;
		if (st[i] == '\n')
			st[i] = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}
	
	strcmp()函数比较的是字符串，不是整个数组，这是非常好的功能，虽然数组try占用了40字节，
	而储存在其中的Grant只占用了6字节(其中一个空字符)；
	strcmp()函数只会比较try中第一个空字符前面的部分，所以它可以比较储存在不同大小数组中的字符串；

	1.	strcmp()的返回值
	如果strcmp()比较的字符串不同，会返回什么值？
	#include<stdio.h>
	#include<string.h>
	int main(void)
	{
		printf("strcmp(\"A\",\"A\")is %d\n", strcmp("A", "A"));
		printf("strcmp(\"A\",\"B\")is %d\n", strcmp("A", "B"));
		printf("strcmp(\"A\",\"C\")is %d\n", strcmp("A", "C"));
		printf("strcmp(\"B\",\"A\")is %d\n", strcmp("B", "A"));
		printf("strcmp(\"C\",\"A\")is %d\n", strcmp("C", "A"));
		printf("strcmp(\"Z\",\"a\")is %d\n", strcmp("Z", "a"));
		printf("strcmp(\"apples\",\"apple\")is %d\n", strcmp("apples", "apple"));
		return 0;
	}

	运行结果：		其它系统可能返沪的值
	strcmp("A","A")is 0		0
	strcmp("A","B")is -1		-1
	strcmp("A","C")is -1		-2
	strcmp("B","A")is 1		1
	strcmp("C","A")is 1		2
	strcmp("Z","a")is -1		-7
	strcmp("apples","apple")is 1	115

	
	ASCII标准规定，在字母表中，如果第1个字符串在第2个字符串前面，返回负数，否则返回正数，相等返回0；
	如果两个字符串开始的几个字符都相同，函数会依次比较每个字符，直到发现第一对不同的字符为止，返回值；
	如apples和apple，只有最后一对字符不同，s和空字符，由于空字符在SACII中排第一，所以返回一个正值；

	最后一个例子表明，strcmp()比较所有的字符，不只是字母，该函数按机器排序序列进行比较；
	即根据字符的数值进行比较(通常用ASCII值)；
	大多数情况下strcmp()返回的具体值并不重要，我们只在意该值是0还是非0(比较两个字符串是否相等)
	或者按字母排序字符串，这种情况下需要知道比较结果是为正、负还是为0；

	strcmp()函数比较的是字符串，不是字符，所以其参数应该是字符串如"apple"、"A",而不是字符'A'
	但是char类型实际上是正数类型，所以可以使用关系运算符来比较字符；
	下面语句都为有效：
	char word[20];
	char ch;
	……
	if(strcmp(word,"quit")==0)	//使用strcmp()比较字符串
		puts("bye.");	
	if(ch=='q')		//使用==比较字符
		puts("bye.");
	
	下面是示例程序，使用strcmp函数检查程序是否要停止读取输入：
	
#include<stdio.h>
#include<string.h>
#define SIZE 80
#define LIM 10
#define STOP "quit"
char *s_gets(char *st, int n);

int main(void)
{
	char input[LIM][SIZE];
	int ct = 0;

	printf("Enter up to %d lines(type quit to quit):\n", LIM);
	while (ct < LIM&&s_gets(input[ct], SIZE) != NULL && strcmp(input[ct], STOP) != 0)
	{
		ct++;
	}
	printf("%d string entered\n", ct);
	return 0;
}
char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)//即，ret_val！=NULL
	{
		while (st[i] != '\n'&&st[i] != '\0')
			i++;
		if (st[i] == '\n')
			st[i] = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}


	该程序在读到EOF(s_gets()返回NULL)、用户输入quit或输入项达到LIM时，自动退出；

	顺带一提，有时候输入空行(即只按下回车键或return键)表示结束输入更方便；此时修改while循环条件为：
	while (ct < LIM&&s_gets(input[ct], SIZE) != NULL && input[ct][0]!= '\0')
	input[ct][0]是输入中其中某一行该字符串的第一个字符，
	如果用户输入空行，s_gets()就会把该行第一个字符（换行符）替换成空字符；

	所以下面的表达式用于检测空行：
	 input[ct][0]!= '\0'

	2.	strncmp()函数
	
	strcmp()函数比较字符串中的字符，直到发现不同的字符为止，这一过程可能会持续到字符串的末尾；
	strncmp()函数在比较两个字符串时，可以比较到字符不同的地方，也可以只比较第三个参数指定的字符数；
	
	例如要查找以astro开头的字符串，可以限定函数只查找这5个字符，下面是程序演示：

#include<stdio.h>
#include<string.h>
#define SIZE 6
int main(void)
{
	const char *list[SIZE] =
	{
		"astronomy",
		"astounding",
		"astrophysics",
		"ostracize",
		"asterism",
		"astrophobia"
	};
	int count = 0;
	int i;
	for(i=0;i<SIZE;i++)
		if (strncmp(list[i], "astro", 5) == 0)
		{
			printf("Found:%s\n", list[i]);
			count++;
		}
	printf("The list contained %d words beginning with astro.\n", count);
	return 0;
}
	
	运行结果：

	Found:astronomy
	Found:astrophysics
	Found:astrophobia
	The list contained 3 words beginning with astro.


11.5.5	strcpy()和strncpy()函数
	
	前面提到过，如果pts1和pts2都是指向字符串的指针，那么下面语句拷贝的是字符串的地址，而不是字符串本身：
	pts2=pts1；
	如果希望拷贝整个字符串，要使用strcpy()函数；
	下面示例程序要求用户输入以q开头的单词，该程序把输入拷贝至一个临时数组中，如果第一个字母是q，
	程序调用strcpy()把整个字符串从临时数组拷贝至目标数组中，strcpy()函数相当于字符串赋值运算符

#include<stdio.h>
#include<string.h>
#define SIZE 40
#define LIM 5
char *s_gets(char *st, int n);
int main(void)
{
	char qwords[LIM][SIZE];
	char temp[SIZE];
	int i = 0;
	printf("Enter %d words beginning with q:\n", LIM);
	while (i < LIM&&s)	
	{	
		gets(temp, SIZE);	
		if (temp[0] != 'q')
			printf("%s doesn't begin with q!\n", temp);
		else
		{
			strcpy_s(*(qwords+i),SIZE, temp);
			i++;
		}
	}
	puts("Here are the words accepted:");
	for (i = 0; i < LIM; i++)
		puts(qwords[i]);
	return 0;
}
char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)//即，ret_val！=NULL
	{
		while (st[i] != '\n'&&st[i] != '\0')
			i++;
		if (st[i] == '\n')
			st[i] = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}
**************************************************************************************************************
#include<stdio.h>
#include<string.h>
#define SIZE 40
#define LIM 5
char *s_gets(char *st, int n);
int main(void)
{
	char qwords[LIM][SIZE] = {""};
	char temp[SIZE];
	int i = 0;
	printf("Enter %d words beginning with q:\n", LIM);
	while (i < LIM&&s_gets(temp, SIZE))
	{		
		if (temp[0] != 'q')
			printf("%s doesn't begin with q!\n", temp);
		else
		{
			strcpy_s(*(qwords+i),SIZE, temp);
			i++;
		}
	}
	puts("Here are the words accepted:");
	for (int j=0; j < i; j++)
		puts(qwords[j]);
	return 0;
}
char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)//即，ret_val！=NULL
	{
		while (st[i] != '\n'&&st[i] != '\0')
			i++;
		if (st[i] == '\n')
			st[i] = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}

*******************************************************************************************************************
	tips:
	 s_gets(temp, SIZE) 这个测试条件如果放入循环，就要求使用者必须输满5个正确单词；
	有时候如果使用者只能输入3个或不满5个，输入EOF就能绕过循环提前进入后续程序；
	但是此时就要对后面要输出的 qwords[LIM][SIZE]预先在声明时赋空值 qwords[LIM][SIZE]={“”}；
	并且在后续输出结果的时候，qwords[j]，j的值不超过计数器i；
	所以这一段是否放入测试条件看实际使用中的需求，
	如果输入可以被绕过，则放入测试条件，如果必须满足设计的要求，则放入循环体内部；
********************************************************************************************************************

	运行结果：

	Enter 5 words beginning with q:
	qa	//输入
	qb	//输入
	qc	//输入
	ac	//输入
	ac doesn't begin with q!
	qd	//输入
	qe	//输入
	Here are the words accepted:
	qa
	qb
	qc
	qd
	qe
	
	注意，只有在输入q开头的单词后才会递增计数器 i，而且该程序通过比较字符进行判断：
	if (temp[0] != 'q')
	这行代码意思是：如果temp中的第1个字符不为q；当然也可以通过比较字符串进行判断：
	if(strncmp(temp,"q",1)!=0)
	这行代码意思是：如果temp中第一个字符跟'q'比较不相同；

	注意，拷贝出来的字符串被称为目标字符串，最初的字符串被称为源字符串；
	参考赋值表达式语句，很容易记住strcpy()参数的顺序，即第1个是目标字符串，第2个是源字符串：

	char txt[20];
	int x;		
	x=50;		//数字赋值
	strcpy(txt,"hello");	//字符串赋值
	txt="hello";	//语法错误

	程序员有责任确保目标数组有足够空间容纳源字符串的副本；下面代码有问题：
	char *str;
	strcpy(str,"hello");//有问题
	
	strcpy()把“hello”拷贝至str所指向的地址上，但是str未被初始化；所以该字符串可能被拷贝至任意地方！

	↓strcpy(ptr1,ptr2)
	总之，strcpy()接受两个字符串作为参数，可以把指向源字符串的第二个指针(ptr2)声明为指针、数组名或字符串常量；
	而指向源字符串副本的第一个指针(ptr1)应指向一个数据对象(如数组)，且该对象有足够的空间储存元字符串副本；
	记住，声明数组将分配储存数据的空间，而声明指针只分配储存一个地址的空间；
	
	1.	strcpy()的其他属性
	①strcpy()的返回类型是char *，该函数返回的是第1个参数的值，即一个字符的地址；
	②第1个参数不必指向数组的开始，这个属性可以用于拷贝数组的一部分：
	示例程序：
	#include<stdio.h>
	#include<string.h>
	#define SIZE 40
	#define WORDS "beast"
	#pragma warning(disable:4996)		//VS下屏蔽strcpy()不安全警告
	int main(void)
	{
		const char *orig = WORDS;
		char copy[SIZE] = "Be the best that you can be.";
		char *ps;
		puts(orig);
		puts(copy);
		ps = strcpy(copy + 7,orig);//strcpy_s属性没有①的功能，它返回的是个整数；
		puts(copy);
		puts(ps);
		return 0;
	}

	注意，strcpy()把源字符串中的空字符也拷贝在内；
	在该例中，空格字符覆盖了copy数字中taht的第一个t字符，注意，由于第一个参数是copy+7；
	所以ps指向copy中的第8个元素(下标为7)，因此puts(ps)从该处开始打印字符串；
	下面是图示：
	Be the best that you can be.\0
	           ↑copy+7

	beast\0
	↑orig
	
	Be the beast\0hat you can be.\0
	
	strcpy(copy+7,orig);意思是从orig中拷贝字符串到这里

	2.	更谨慎的选择：strncpy()
	strcpy()和strcat()都有同样的问题，它们都不能检查目标空间是否能容纳源字符串的副本；
	拷贝字符串用strncpy()更安全；该函数的第三个参数指明可拷贝的最大字符数;
	示例程序：

#include<stdio.h>
#include<string.h>
#define SIZE 40
#define TARGSIZE 7
#define LIM 5
char * s_gets(char *st, int n);
int main(void)
{
	char qwords[LIM][TARGSIZE] = {""};
	char temp[SIZE];
	int i = 0;
	printf("Enter %d words beginning with q:\n", LIM);
	while (i < LIM&&s_gets(temp, SIZE))
	{		
		if (temp[0] != 'q')
			printf("%s doesn't begin with q!\n", temp);
		else
		{
			strncpy_s(qwords[i], sizeof(qwords[LIM]), temp, TARGSIZE - 1);
			qwords[i][TARGSIZE - 1] = '\0';
			i++;
		}
	}
	puts("Here are the words accepted:");
	for (int k = 0; k < i; k++)
		puts(qwords[k]);
	return 0;
}
char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)
	{
		while (st[i] != '\n'&&st[i] != '\0')
			i++;
		if (st[i] == '\n')
			st[i] = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}
	
	strncpy(ptr1,ptr2,n);把pyr2中的n个字符或空字符之前的字符拷贝至ptr1中，
	因此，如果ptr2中的字符数小于n，则拷贝整个字符串，包括空字符；
	但是strncpy()拷贝字符串的长度不会超过n；如果拷贝到第n个字符时还未拷贝完整个源字符串，就不会拷贝空字符；
	所以，拷贝的副本中不一定有空字符，鉴于此，该程序把n设置为比目标数组大小少1，然后把数组最后一个元素设为\0
		strncpy(qwords[i], temp, TARGSIZE - 1);
		qwords[i][TARGSIZE - 1] = '\0';
	这样做确保储存的是一个字符串；简而言之：
	如果目标空间能容纳源字符串的副本，那么从源字符串拷贝的空字符就是改副本的结尾；
	如果目标空间装不下副本，则把副本最后一个元素设置为空字符；

11.5.6	sprintf()函数	//把数据写入字符串
	sprintf()函数声明在stdio.h中，该函数和printf()类似，但是它是把数据写入字符串，而不是打印在显示器上；
	因此该函数可以把多个元素组合成一个字符串；
	该函数的第1个参数是目标字符串地址，其余参数和printf()相同，即格式字符串和待写入项的列表；
	sprintf()函数获取输入，并将其格式化为标准形式，然后将格式化后的字符串储存在目标字符串中；
	示例程序：
#include<stdio.h>
#define MAX 20
char * s_gets(char *st, int n);
int main(void)
{
	char first[MAX];
	char last[MAX];
	char formal[2 * MAX + 10];
	double prize;
	puts("Enter your first name:");
	s_gets(first, MAX);
	puts("Enter your last name:");
	s_gets(last, MAX);
	puts("Enter your prize money:");
	scanf_s("%lf", &prize);
	sprintf_s(formal,sizeof(formal), "%s,%-19s:$%6.2f\n", last, first, prize);
	puts(formal);
	return 0;
}
char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)
	{
		while (st[i] != '\n'&&st[i] != '\0')
			i++;
		if (st[i] == '\n')
			st[i] = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}


11.5.7	其它字符串函数
	ANSIC库有20多个用于处理字符串的函数，下面总结了一些常用的函数：
	
	①char *strcpy(char *restrict s1,const char *restrict s2);
	strcpy：该函数把s2指向的字符串(包括空字符)拷贝至s1指向的位置，返回值是s1
	
	②char *strncpy(char *restrict s1,const char *restrict s2,size_t n);
	strncpy：该函数把s2指向的字符串拷贝至s1所指向的位置，拷贝的字符数不超过n，返回值是s1；
	遇到空字符就停止拷贝，若源字符串字符少于n，拷贝空字符，否则就不拷贝空字符，手动补最后一个元素为\0
	
	③char *strcat(char *restrict s1,const char *restrict s2);
	strcat：该函数把s2指向的字符串拷贝至s1指向的字符串末尾；s2字符串的第1个字符将覆盖s1字符串末尾的空字符；
	该函数返回s1；

	④char *strncat(char *restrict s1,const char *restrict s2,size_t n);
	strncat：该函数把s2指向的字符串中的n个字符拷贝至s1指向的字符串末尾；
	s2字符串的第1个字符将覆盖s1字符串末尾的空字符；不会拷贝s2字符串中空字符和其后的字符，并在末尾加\0；
	该函数返回s1；

	⑤int strcmp(const char *s1,const char *s2);
	strcmp：如果s1字符串在机器排序序列中位于s2的后面，返回正数，否则返回负数，相等返回0；

	 ⑥int strncmp(const char *s1,const char *s2，size_t n);
	strcnmp：该函数与strcmp类似，在比较n个字符后或遇到第一个空字符时停止比较；

	⑦char *strchr(const char *s,int c);
	strchr：如果s字符串包含c字符，该函数返回指向s字符串中第1个c字符位置的指针，
	如果在s中未找到c字符，该函数返回空指针；

	⑧char *strpbrk(const char *s1,const char *s2);
	strpbrk：如果s1字符串中包含s2字符串中的任意字符，返回指向s1字符串中第1次出现任意相同字符位置的指针；
	如果在s1字符串中未找到s2字符串中的任意字符，则返回空字符；
	
	⑨char *strrchr(const char *s,int c);
	strrchr：与strchr相同，区别是返回最后一次出现c字符的位置的指针；

	⑩char *strstr(const char *s1,const char *s2);
	strstr：该函数返回指向s1字符串中s2字符串第一次出现的位置，如果没有出现s2，返回空指针；

	size_t strlen(const char *s);
	strlen：该函数返回s字符串中的字符数，不包含空字符；

	请注意，那些使用const关键字的函数原型表明，函数不会更改字符串；关键字restrict在12章介绍
	
	第五章中，size_t类型是sizeof运算符返回的类型，C规定sizeof运算符返回一个整数类型，但是未指定是哪种；
	在某系统可能是unsigned int，在另一个系统中可能又是unsigned long；
	string.h头文件针对特定系统定义了size_t；所以它有更好的跨平台性；

	在我们自定义的s_gets()函数中：

	char *s_gets(char *st, int n)
	{
		char*ret_val;
		int i = 0;
		ret_val = fgets(st, n, stdin);
		if (ret_val)
		{
			while (st[i] != '\n'&&st[i] != '\0')	//通过while循环检测换行符/空字符；
				i++;			//若都不是，计数器递增；
			if (st[i] == '\n')			//如果是换行符；替换成空字符；
				st[i] = '\0';
			else				//如果是空字符，舍弃多余输入；
				while (getchar() != '\n')
					continue;
		}
		return ret_val;
	}

	其实这里可以用strchr()代替s_gets()；
	首先使用strchr()查找换行符，如果有的话返回改换行符的地址，然后用空字符替换；
	例：
	char line[80];
	char *find;
	
	fgets(line,80,stdin);
	find=strchr(line,'\n');
	if(find)
		*find='\0';

	如果strchr()未找到换行符，fgets()在达到行末尾之前就达到了它能读取的最大字符数，给if添加一个else处理该情况；

	
11.6	字符串示例：字符串排序

	程序主要用strcmp函数来确定两个字符串的顺序；
	一般做法是读取字符串函数，排序字符串打印出来；程序如下:
	
#include<stdio.h>
#include<string.h>
#define SIZE 81	//限制字符串长度，包括\0
#define LIM 20	//可读入的最多行数
#define HALT ""	//空字符串停止输入
void stsrt(char *strings[], int num);//字符串排序函数
char *s_gets(char *st, int n);
int main(void)
{
	char input[LIM][SIZE];	//储存输入的数组
	char *ptstr[LIM];		//内含指针变量的数组
	int ct = 0;				//输入计数器
	int k;					//输出计数器

	printf("Input up to %d lines,and i will sort them.\n", LIM);
	printf("To stop,press the Enter key at a line's start.\n");
	while (ct < LIM&&s_gets(input[ct], SIZE) != NULL && input[ct][0] != '\0')
	{
		ptstr[ct] = input[ct];	//设置指针指向字符串
		ct++;
	}
	stsrt(ptstr, ct);			//字符串排序
	puts("\nHere's the sorted list:\n");
	for (k = 0; k < ct; k++)
		puts(ptstr[k]);			//排序后的指针
	return 0;
}
void stsrt(char *strings[], int num)
{
	char *temp;
	int top, seek;
	for(top=0;top<num-1;top++)
		for(seek=top+1;seek<num;seek++)
			if (strcmp(strings[top], strings[seek]) > 0)
			{
				temp = strings[top];
				strings[top] = strings[seek];
				strings[seek] = temp;
			}
}
char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)
	{
		while (st[i] != '\n'&&st[i] != '\0')	
			i++;			
		if (st[i] == '\n')			
			st[i] = '\0';
		else				
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}

	运行结果：

	Input up to 20 lines,and i will sort them.
	To stop,press the Enter key at a line's start.
	Oh,that i was where i would be,	//输入①
	Then would i be where i am not;	//输入②
	But where i am i must be,		//输入③
	And where i would be i can not.	//输入④
					//输入⑤回车
					
	Here's the sorted list:
					//输出①
	And where i would be i can not.	//输出②
	But where i am i must be,		//输出③
	Oh,that i was where i would be,	//输出④
	Then would i be where i am not;	//输出⑤
		
	
11.6.1	排序指针而非字符串
	该程序巧妙之处在于排序的是指向字符串的指针，而不是字符串本身；我们来分析以下怎么做：
	①最初，ptrst[0]被设置为input[0],ptrst[1]被设置程input[1]，以此类推，ptrst[ct]=input[ct];
	这意味着指针ptrst[i]指向数组input[i]的首字符，每个input[i]都是一个内含81个元素的数组；
	每个ptrst[i]都是一个单独的变量；
	②排序过程把ptrst重新排列，并未改变input；
	例如按字母顺序，input[1]在input[0]前面，程序便交换指向它们的指针
	(即：ptrst[0]指向input[1]的首字符地址，ptrst[1]指向input[0]的首字符地址)；
	这样做比strcpy()交换两个input字符串的内容简单得多，而且还保留了input数组中的原始顺序；
	
	
11.6.2	选择排序算法
	我们采用的是选择排序算法来排序指针，具体做法是，利用for循环依次把每个元素与首元素比较；
	如果待比较的元素在当前元素的前面，则两者交换；循环结束时，首元素包含的指针指向机器排序序列最靠前的字符串；
	然后外层for循环重复这一过程，这次从input的第二个元素开始；
	当内层循环执行完毕时，ptrst中的第2个元素指向排在第2的字符串，这一过程持续到所有元素都已排序完毕；
	伪代码
	for n=首元素至n=倒数第2个元素，
		找出剩余元素中的最大值，并将其放在第n个元素中
	for n的后一个元素至最后一个元素
		比较第n个元素与后1个元素，如果第n个元素更大，交换这两个元素的值

	外层循环指明正在处理数组的哪一个元素，内层循环找出应储存在该元素的值；两者结合就是该排序算法；
	C库中有一个更高级的排序函数：qsort()，该函数使用一个指向函数的指针进行排序比较，16章介绍；

	
11.7	ctype.h字符函数和字符串
	ctype.h系列函数虽然不能处理字符串，但是可以处理字符串中的字符；如下面示例程序：
	用toupper()函数将字符串转换成大写，用ispunct()统计标点符号，strchr()处理fgets()读入字符串的换行符；


#include<stdio.h>
#include<string.h>
#include<ctype.h>
#define LIMIT 81
void to_upper(char *);
int punctcount(const char *);
int main(void)
{
	char line[LIMIT];
	char *find;
	
	puts("Please enter a line:");
	fgets(line, LIMIT, stdin);
	find = strchr(line, '\n');
	if (find)
		*find = '\0';
	to_upper(line);
	puts(line);
	printf("That line has %d punctuation characters.\n", punctcount(line));
	return 0;
}
void to_upper(char *str)
{
	while (*str)
	{
		*str = toupper(*str);
		str++;
	}
}
int punctcount(const char *str)
{
	int ct = 0;
	while (*str)
	{
		if (ispunct(*str))
			ct++;
		str++;
	}
	return ct;
}

	运行结果：
	Please enter a line:
	can you hear me? tell me,please.	//输入
	CAN YOU HEAR ME? TELL ME,PLEASE.
	That line has 3 punctuation characters.

	***********************************************************
	分析：	
	while (*str)循环处理str指向的字符串中的每一个字符，直到遇到空字符；此时*str的值为0，循环条件为假，结束循环；
	to_upper()函数利用toupper()处理字符串中的每一个字符；
	根据ANSIC中的定义，tuupper()函数只改变小写字符，但是一些很旧的C实现不自动检查大小写，所以可以这样写：
	if(islower(*str))
		*str=toupper(*str);
	顺带一提，ctype.h中的函数通常作为宏来处理，这些C预处理宏的作用很像函数，但是两者有区别，16章介绍；
	该程序使用fgets()和strchr()组合，读取一行输入并把换行符替换成空字符；
	这种方法与s_gets()的区别是，后者会处理剩余的字符(如果有的话)，为下一次输入做好准备；
	而本例只有一条输入语句；就没必要进行多余步骤；

	
11.8	命令行参数
	在图形界面普及之前都使用命令行界面，命令行是在命令行环境中，用户为运行程序输入命令的行；
	假设有一个文件中有一个名为fuss的程序，在UNIX环境中运行该程序的命令行是
	$ fuss
	或者在Windows命令提示模式下是：
	c>fuss
	命令行参数是同一行的附加项，如：
	c>fuss -r Ginger
	一个C程序可以读取并使用这些附加项；如下示例：该程序通过main()的参数读取这些附加项
	
	#include<stdio.h>
	int main(int argc, char *argv[])
	{
		int count;
		printf("The command line has %d argumants:\n", argc - 1);
		for (count = 1; count < argc; count++)
			printf("%d:%s\n", count, argv[count]);
		printf("\n");
		return 0;
	}

	运行结果：
	C:\>repeat good game. have fun.	//C:\> 程序repeat.exe文件存放位置
	The command line has 4 argumants:
	1:good
	2:game.
	3:have
	4:fun.
	
	下面我们解释下它的运行原理：
	C编译器允许main()没有参数或者有2个参数(一些实现允许main()有更多参数，属于对标准的扩展)；
	main()有两个参数时，第一个参数是命令行中的字符串数量；
	过去，这个int类型的参数被称为argc(表示参数计数argument count)；
	系统用空格表示一个字符串的结束和下一个字符串的开始；
	因此 上面的repeat示例中包括命令名共有5个字符串，其中后4个供repeat使用；
	该程序把命令行字符串储存在内存中，并把每个字符串的地址储存在指针数组中；
	而该数组的地址则被储存在main()的第二个参数中；
	
	按照惯例，这个指向指针的指针名为argv(argument value)；
	如果系统允许(一些操作系统不允许)，就把程序本身的名称赋给argv[0],然后把随后的第一个字符串赋给argv[1]
	以此类推：
	argv[0]指向repeat(对大部分系统而言)
	argv[1]指向good
	argv[2]指向game.
	argv[3]指向have
	argv[4]指向fun.

	程序通过一个for循环打印每个字符串，printf()中的%s转换说明表明，要提供一个字符串的地址作为参数
	而指针数组中的每个元素(argv[0]、argv[1]等)都是这样的地址
	
	main()中的形参形式与其他带形参的函数相同，许多程序员用不同的形式声明argv:
	int main(int argc,char **argv)
	char **argv与char *argv[]等价。
	也就是说，argv是一个指向指针的指针，它所指向的指针指向char；
	
	因此，即使在原始定义中，argv也是指向指针的指针，两种形式都可以用，第一种更行出地表明argv表示一系列字符串
	顺带一提，许多环境(UNIX DOS)都允许用双引号把多个单词括起来形成一个参数，例如：
	repeat "i am hungray" now
	这行命令把字符串"i am hungray"赋给argv[1],把“now”赋给argv[2]

	
11.8.1	集成环境中的命令行参数
	Windows集成环境（如Xcode、Microsoft Visual C++、Embarcadero C++ Builder）都不用命令行运行程序；
	有些环境中有项目对话框，为特定项目指定命令行参数；
	其他环境中，可以在IDE中编译程序，然后打开MS-DOS窗口命令行模式中运行程序；
	但是，如果你的系统有一个运行命令行的编译器(如GCC)会更简单；

11.8.2	Macintosh中的命令行
	如果使用Xcode 4.6（或类似的版本），可以在Product菜单中选择Scheme选项来提供命令行参数，
	编辑Scheme，运行。然后选择Argument标签，在Launch的Arguments Pass中输入参数。
	或者进入Mac的Terminal模式和UNIX的命令行环境。然后，可以找到程序可执行代码的目录（UNIX的文件夹），
	或者下载命令行工具，使用gcc或clang编译程序。

	
11.9	把字符串转换为数字
	
	数字既能以字符串形式储存，也能以数值形式储存，把数字储存为字符串就是储存数字字符；
	例如，数字213以'2'、'1'、'3'、'\0'的形式被储存在字符串数组中，以数字形式储存213，储存的是int类型的值

	C要求用数字形式进行数值运算(如加法和比较)，但是在屏幕上显示数字则要求字符串形式；
	因为屏幕显示的是字符；
	printf()和sprintf()函数，通过%d和其他转换说明，把数字从数值形式转换为字符串形式，
	scanf()可以把输入字符串转换为数值形式，C还有一些函数专门用于把字符串形式转换为数值形式；

	假设你编写的程序需要使用数值命令形参，但是命令形参数被读取为字符串。
	因此，要使用数值必须先把字符串转换为数字。
	如果需要整数，可以使用atoi（）函数（用于把字母数字转换成整数），
	该函数接受一个字符串作为参数，返回相应的整数值。演示如下：
	
#include<stdio.h>
#include<stdlib.h>
int main(int argc, char *argv[])
{
	int i,times;
	if (argc < 2 || (times = atoi(argv[1])) < 1)
		printf("Usage:%s positive-number\n", argv[0]);
	else
		for (i = 0; i < times; i++)
			puts("Hello,good looking!");
	return 0;
}
	运行结果：

	C:\>call.exe 3
	Hello,good looking!
	Hello,good looking!
	Hello,good looking!
	
	
	ANSIC还提供一套更智能的函数：
	strtol()把字符串转换成long类型的值；
	strtoul()把字符串转换成unsigned long 类型的值;
	strtod()把字符串转换成double类型；
	这些函数的智能之处在于识别和报告字符串中的首字符是否是数字，而且strtol和strtoul还可以指定数字的进制；
	
	下面是strtol()函数示例；函数原型如下：
	long strtol(const char *restrict nptr, char **restrict endptr,int base);
	这里，nptr是指向待转换字符的指针，endptr是一个指针的地址，该指针被设置为标识输入数字结束字符的地址；
	base表示以什么进制写入数字；

#include<stdio.h>
#include<stdlib.h>
#define LIM 30
char * s_gets(char * st, int n);
int main(void)
{
	char number[LIM];
	char * end;
	long value;

	puts("Enter a number (empty line to quit):");
	while (s_gets(number, LIM) && number[0] != '\0')
	{
		value = strtol(number, &end, 10);
		printf("base 10 input,base 10 output:%ld,stopped at %s(%d)\n", value, end, *end);
		value = strtol(number, &end, 16);
		printf("base 16 input,base 10 output:%ld,stopped at %s(%d)\n", value, end, *end);
		puts("Next number");
	}
	puts("Bye\n");
}

char *s_gets(char *st, int n)
{
	char*ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if (ret_val)
	{
		while (st[i] != '\n'&&st[i] != '\0')
			i++;
		if (st[i] == '\n')
			st[i] = '\0';
		else
			while (getchar() != '\n')
				continue;
	}
	return ret_val;
}

	
	运行结果：
	
	Enter a number (empty line to quit):
	10	//输入①
	base 10 input,base 10 output:10,stopped at (0)
	base 16 input,base 10 output:16,stopped at (0)
	Next number
	10atom	//输入②
	base 10 input,base 10 output:10,stopped at atom(97)
	base 16 input,base 10 output:266,stopped at tom(116)
	Next number
		//输入③
	Bye

	①当base分别为10和16时，字符串10分别被转换成数字10和16；
	如果end指向一个字符，*end就是一个字符；因此第一次转换在读到空字符时结束，此时end指向空字符；
	打印end会显示一个空字符串，用%d输出*end显示的是空字符的ASCII码(0);
	
	②对于此输入字符串，当base为10时，end的值是'a'字符的地址，所以打印end显示的是字符串atom；
	打印*end显示的是'a'字符的ASCII码，然而当base为16时，'a'被识别为一个有效的十六进制数；
	strtol()函数把十六进制数10a转换成十进制266；
	
	strtol()函数最多可以转换三十六进制，'a'~'z'字符都可以用作数字；
	strtoul()与该函数类似，但是它把字符串转换成无符号值，strtod()函数只以十进制转换，因此它只需要两个参数；

	许多实现使用itoa()和ftoa()函数分别把正数和浮点数转换成字符串，但是这两个函数并不是C标准库成员，
	可以用sprintf()函数替代他们，因为sprintf()的兼容性更好；

11.10	关键概念

	字符串，无论是由字符数组、指针还是字符串常量标识，都储存为包含字符编码的一系列字节，并以空字符结尾；
	尤其需要牢记，使用strcmp()来代替关系运算符，
	比较字符串时，应使用strcpy()或strncpy()代替赋值运算把字符串赋给字符数组；

11.12	复习题
	1.下面字符串的声明有什么问题？

	int main(void)
	{
		char name[]={'F','e','s','s'};	//缺少字符串结尾'\0'或变成【字符数组】下标来分配储存空间,
					//赋值动作：'a'是字符，不是字符串，“a”赋值是字符串；
		......
	}
	
	2.下面的程序将会输出什么？
	
	#include<stdio.h>
	int main(void)
	{
		char note[] = "See you at the snack bar.";
		char *ptr;
	
		ptr = note;
		puts(ptr);			//See you at the snack bar.
		puts(++ptr);		//ee you at the snack bar.
		note[7] = '\0';		
		puts(note);		//See you 
		puts(++ptr);		//e you 
		return 0;
	}

	
	3.下面的程序会输出什么？

	#include<stdio.h>
	#include<string.h>
	int main(void)
	{
		char food[] = "Yummy";
		char *ptr;
		ptr = food + strlen(food);
		while (--ptr >= food)
			puts(ptr);
		return 0;
	}
	
	Y	u	m	m	y	\0
	↑food					↑ptr=food+strlen(food)	//指针位置

	输出：
	y
	my
	mmy
	ummy
	Yummy

	4.下面程序将输出什么
	
	#include<stdio.h>
	#include<string.h>
	int main(void)
	{
		char goldwyn[40] = "art of it all ";
		char samuel[40] = "I read p";
		const char * quote = "the way through.";
		strcat_s(goldwyn,40, quote);		//art of it all the way through.
		strcat_s(samuel,40, goldwyn);		//I read part of it all the way through.
		puts(samuel);			//I read part of it all the way through.
		return 0;
	}

	5.下面的练习涉及字符串、循环、指针和递增指针，首先假设定义了下面的函数：
	#include<stdio.h>
	char *pr(char *str)
	{
		char *pc;
		pc = str;
		while (*pc)		//等效于*pc!=0，也就是pc指针指向'\0'时退出循环
			putchar(*pc++);	//递增指针；输出指针指向的字符；直到指向\0;
		do { putcahr(*--pc); } 	//do先输出（先递减指针然后解引用输出指针指向的字符）
		while (pc - str);		//等效于(pc-str)!=0当递增后的指针递减直到回到初始位置前，一直输出；
		return (pc);		//返回pc指针
	}
	
	考虑下面的函数调用：
	x=pr("Ho Ho Ho!");
	
	①将输出什么？	//Ho Ho Ho!!oH oH oH
	②x是什么类型？	//x是指向char类型的指针
	③x的值是什么？	//值是指向字符串常量H的地址；
	④表达式*--pc是什么意思，与--*pc有何不同？	//递减指针位置；后者为指针的值递减
	⑤如果将*--pc替换--*pc，会打印什么？		//打印一样，因为char字长为一字节
	⑥两个while循环用来测试什么？			
	⑦如果pr()函数的参数是空字符串，会怎样？		x指向NULL;
	⑧必须在主调函数中做什么，才能让pr()函数正常运行？	//声明x类型；char *x;声明pr的函数原型；

	H	o	(spcace)	H	o	(space)	H	o	!	\0
	↑pc//传入str的指针初始位置；							pc+9


	6.假设有如下声明
	char sign='$';
	sign占多少字节的内存？'$'占多数字节内存？"$"占多数字节内存？

	char类型字长为1字节，sign占用1字节，'$'占用1字节,"$"是字符串，等效于"$\0",占用2字节

	7.下面的程序会打印出什么？
	#include<stdio.h>
#include<string.h>
#define M1 "How are ya,sweetie?"
char M2[40] = "Beat the clock.";
char *M3 = "chat";
int main(void)
{
	char words[80];
	printf(M1);					//How are ya,sweetie?\0
	puts(M1);						//How are ya,sweetie?\0\n
	puts(M2);						//Beat the clock.\0\n
	puts(M2 + 1);					//eat the clock.\0\n
	strcpy_s(words,80, M2);				//words="Beat the clock.\0"
	strcat_s(words,80, " Win a toy.");			//words="Beat the clock. Win a toy.\0"
	puts(words);					//Beat the clock. Win a toy.\0\n
	words[4] = '\0';					//words="Beat\0"
	puts(words);					//Beat\0\n
	while (*M3)					
		puts(M3++);				//chat\0\nhat\0\nat\0\nt\0\n
	puts(--M3);					//t\0\n
	puts(--M3);					//at\0\n
	M3 = M1;						
	puts(M3);						//How are ya,sweetie?\0\n
	return 0;
}

	8.下面的程序会打印出什么？
	#include<stdio.h>
	int main(void)
	{
		char str1[] = "gawasie";
		char str2[] = "bletonism";
		char *ps;
		int i = 0;
		for (ps = str1; *ps != '\0'; ps++)
		{
			if (*ps == 'a' || *ps == 'e')
				putchar(*ps);
			else
				(*ps)--;
			putchar(*ps);			//faavaarhee\0
		}
		putchar('\n');				
		while (str2[i] != '\0')
		{
			printf("%c", i % 3 ? str2[i] : '*');		//*le*on*sm\0
			++i;
		}
		return 0;
	}


	9.本章定义的s_gets()函数，用指针表示法代替数组表示法可以减少一个变量i，改写该函数

	char *s_gets(char *st, int n)
	{
		char*ret_val;		
		ret_val = fgets(st, n, stdin);
		if (ret_val)
		{
			while (*st != '\n'&&*st != '\0')
				st++;
			if (*st == '\n')
				*st = '\0';
			else
				while (getchar() != '\n')
					continue;
		}
		return ret_val;
	}



	10.strlen()函数接受一个指向字符串的指针作为参数，并返回该字符串的长度，请编写一个这样的函数。

	#include<stdio.h>
	#include<string.h>
	long rstrlen(char *st) 
	{
		long count=0;
		while (*st++)			
			count++;		
		return count;
	}	
	int main(void)
	{
		char *exp = { "hello,world!" };
		printf("%d", rstrlen(exp));
		return 0;	
	}
	
	
	11.本章定义的s_gets()函数，可以用strchr()函数替代其中的while循环来查找换行符，请改写函数；

	char *s_gets(char *st, int n)
	{
		char*ret_val;
		char *find;
		ret_val = fgets(st, n, stdin);
		if (ret_val)
		{
			find=strchr(st,'\n');		//查找换行符
			if(find)			//如果地址不是NULL；
				*find='\0';		//在此处放置一个空字符
			else
				while (getchar() != '\n')
					continue;
		}
		return ret_val;
	}


	
	12.设计一个函数，接受一个指向字符串的指针，返回指向该字符串第1个空格字符的指针，若未找到返回空指针；

	char * rstrchr(const char *str)
	{
		char *exp;
		exp = strchr(str, ' ');
		return exp;
	}
	*********************************************************
	char *rstrchr(const char *str)
	{
		while(*str!=' '&&*str!='\0')
			str++;
		if(*str=='\0')
			return NULL;
		else
			return str;
	}

	

	13.重写程序清单11.21，使用ctype.h头文件中的函数，以便无论用户选择大写还是小写，程序都能正确识别；
	
#include <stdio.h>
#include <string.h>
#include<ctype.h>
#define SIZE 40
#define ANSWER "GRANT"
char *s_gets(char *st, int n);
void to_upper(char *str);
int main(void)
{	
	char try[SIZE];		
	puts("Who is buried n Grant's tomb?");
	s_gets(try, SIZE);	
	to_upper(try);
	while (strcmp(try, ANSWER))
	{
		puts("No,that's wrong.try again.");
		s_gets(try, SIZE);	
		to_upper(try);
	}
	puts("That's right!");
	return 0;
}
void to_upper(char *str)
{
	while (*str)
	{
		*str = toupper(*str);
		str++;
	}
}
char *s_gets(char *st, int n)
	{
		char*ret_val;
		char *find;
		ret_val = fgets(st, n, stdin);
		if (ret_val)
		{
			find=strchr(st,'\n');		//查找换行符
			if(find)			//如果地址不是NULL；
				*find='\0';		//在此处放置一个空字符
			else
				while (getchar() != '\n')
					continue;
		}
		return ret_val;
	}


11.13	编程练习
	
	1.设计并测试一个函数，从输入中获取下n个字符(包括空白、制表符、换行符)，把结果储存在一个数组里；
	它的地址被传递作为一个参数；
	#include<stdio.h>
	#define LIM 20
	char * getn(char ar[], int n);
	int main(void)
	{
		char exp[LIM*2];
		getn(exp, LIM);
		puts(exp);
		return 0;
	}
	char * getn(char ar[], int n)
	{
		for (int i = 0; i < n; i++)
			ar[i] = getchar();
		ar[n] = '\0';
		while (getchar()!='\n')
			continue;
		return ar;
	}


	2.修改并编程练习1的函数，在n个字符后停止，或在读到第1个空白、制表符或换行符时停止；
	哪个先遇到哪个停止，不能只使用scanf();
	
#include<stdio.h>
#define LIM 20
char * getn1(char ar[], int n);
int main(void)
{	
	char exp[LIM*2];	
	getn1(exp, LIM);
	puts(exp);
	return 0;
}
char * getn1(char ar[], int n)
{
	int i;
	for (i = 0; i < n; i++)
	{
		ar[i] = getchar();
		if (ar[i] == ' ' || ar[i] == '\t' || ar[i] == '\n')
		{
			ar[i] = '\0';
			while (getchar() != '\n')
				continue;
			return ar;
		}
	}
	ar[n] = '\0';
	while (getchar() != '\n')
		continue;
	return ar;
}

	3.设计并测试一个函数，从一行输入中把一个单词读入一个数组中，并丢弃输入行中的其余字符；
	该函数应该跳过第1个非空白字符前面的所有空白。将一个单词定义为没有空白、制表符或换行符的字符序列；
	
#include<stdio.h>
#define LIM 20
char *character(char s[],int n);
int main(void)
{	
	char exp[LIM];
	char emp[LIM];
	character(exp,LIM);
	puts(exp);
	printf("*************\n");
	character(emp, LIM);
	puts(emp);
	return 0;
}
char *character(char s[], int n)
{
	int i=0;		
	while (1) 
	{
		s[i] = getchar();
		if (s[i] != ' ' && s[i] != '\t' && s[i] != '\n')		
			break;		
	}
	for(i=1;i<n;i++)
	{			
		s[i] = getchar();
		if (s[i] == ' ' || s[i] == '\t' || s[i] == '\n')
		{
			s[i] = '\0';
			while (getchar() != '\n')
				continue;
			return s;
		}		
	}	
	s[n-1] = '\0';
	while (getchar() != '\n')
		continue;
	return s;
}	

	4.设计并测试一个函数，它类似编程练习3的描述，只不过它接受第二个参数指明可读取的最大字符数；同上

	5.设计并测试一个函数，搜索第1个函数形参指定的字符串，在其中查找第2个函数形参指定的字符首次出现的位置；
	如果成功，该函数返回指向该字符的指针，如果未找到，返回NULL；//等于写一个strchr()功能函数；
	在一个完整的程序中测试该函数；使用一个循环给函数提供输入值；
	
	#include<stdio.h>	
	char * lookup(char *str, int c);
	int main(void)
	{
		char *ar = "hello can you see";	
		char c = 'l';	
		printf("%s",(lookup(ar, c)));
		return 0;
	}
	char * lookup(char *str, int c)
	{		
		char *ps;
		ps = str;	
		while (*ps)
		{			
			if (*ps == c)
				return ps;		
			else
				ps++;
		}	
		return NULL;
	}


	
	6.编写一个名为is_within()的函数，接受一个字符和一个指向字符串的指针作为两个函数形参；
	如果指定字符在字符串中，该函数返回一个非零值，否则返回0；在一个完整的程序中测试该函数；
	
	#include<stdio.h>
	int is_within(int c,char * str);
	int main(void)
	{
		char *ar = "hello can you see";
		char c = 'h';
		printf("%d", (is_within(c, ar)));
		return 0;
	}
	int is_within(int c,char * str)
	{
		char *ps;
		ps = str;
		while (*ps)
		{
			if (*ps == c)
				return 1;
			else
				ps++;
		}
		return 0;
	}
	
	
	7.strncpy(s1,s2,n)函数把s2中的n个字符拷贝至s1中，截断s2；或者有必要的话在末尾添加空字符；
	如果s2的长度是n或多于n，目标字符串不能以空字符结尾，该函数返回s1；
	自己编写一个这样的函数，名为mystrncpy()，并在一个完整的程序中测试该函数；

#include<stdio.h>
#define LIM 20
char * mystrncpy(char *s1, char *s2, int n);
int main(void)
{
	char *exp2 = "can you?";
	char exp1[2*LIM];
	mystrncpy(exp1, exp2, LIM);
	puts(exp1);
	return 0;
}
char * mystrncpy(char *s1, char *s2, int n)
{
	int i;
	for (i = 0; i < n; i++)
	{
		*(s1 + i) = *(s2 + i);
		if (*(s1 + i) == '\0')
			return s1;
		else
			*(s1 + n) = '\0';
	}
	return s1;
}
	

	8.编写一个名为string_in()函数，接受两个指向字符串的指针作为参数。如果第2个字符串中包含第1个字符串，
	该函数将返回第1个字符串开始的地址；例如string_in("hats","at")将返回hats中a的地址，否则返回空指针；
	在一个完整的程序中测试该函数；
	
#include<stdio.h>
char *string_in(char *s2, char *s1);
int main(void)
{
	char *exp;
	exp=string_in("hats", "at");
	printf("%s",exp);
	return 0;
}
char *string_in(char *s2, char *s1)
{
	int i=0,k=0,flag=0;
	while (*(s1+k))//s1指针偏移k，直到'\0'结束循环①			
	{				
		while (*(s2+i))//s2+i;s2指针偏移i，直到\0结束循环②	
		{
			if (*(s2 + i) == *(s1 + k))//查找第一个相同字符
			{
				flag = i-k;//返回点标记
				i++;	//递增i查询s2下一个字符							
				k++;	//递增K查询s1下一个字符					
				break;
			}
			else
				i++;	
		}	
		while(*(s2+i)==0)
		return NULL;
	}
	return s2+flag;
}
	
	

	9.编写一个函数，把字符串中的内容用其反序字符串代替，在一个完整的程序中测试该函数；

#include<stdio.h>
#include<string.h>
char *backch(char *s);
int main(void)
{
	char exp[20] = "hello world";		
	backch(exp);
	puts(exp);
	return 0;
}
char * backch(char *s)
{
	int i,m,k;		
	char *ptr;
	char temp;	
	k = strlen(s);
	ptr = s;
	for (i = 0; i < k/2; i++)
	{
		m = k - i-1;
		temp = *(ptr + i);
		*(ptr + i) = *(ptr + m);
		*(ptr + m) = temp;		
	}	
	return ptr;
}
	
	

	10.编写一个函数，接受一个字符串作为参数，并删除字符串中的空格，在一个程序中测试该函数，循环读取输入；
	直到用户输入一行空行；该程序应该应用该函数读取每个输入的字符串，并显示处理后的字符串；
	
#include<stdio.h>
#define LIM 40
void nospace(char *str);
int main(void)
{
	int i;
	char exp[LIM];
	for (i = 0; i < LIM; i++)
	{
		exp[i] = getchar();
		if (exp[i] == '\n')
		{
			exp[i] = '\0';
			break;
		}		
	}		
	nospace(exp);	
	puts(exp);
	return 0;
}
void nospace(char *str)
{
	int i,k;
	char *ptr;
	ptr = str;
	for (i = 0, k = 0; k < LIM; i++,k++)
	{
		if (*(str + i) == ' ')
		{
			k--;
			continue;
		}
		else 
		{
			if (*str)
				*(ptr + k) = *(str + i);
			else
				break;
		}
	}	
	return;
}


	11.编写一个函数，读入10个字符串或者读到EOF时停止。该程序为用户提供一个有5个选项的菜单：
	打印源字符串列表、以ASCII中的顺序打印字符串、按长度递增顺序打印字符串、
	按字符串中第一个单词的长度打印字符串、退出；
	菜单可以循环显示，除非用户选择退出选项；当然该程序要能真正完成菜单中个选项的功能；

#include<stdio.h>
#include<string.h>
#define LIM 10
#define SIZE 100
void menu(void);
int choice(void);
void put2(char ar[][SIZE], int n);
void put3(char ar[][SIZE], int n);
void put4(char ar[][SIZE], int n);
int main(void)
{
	int i, k, flag;	//计数器
	int num;		//选择项
	char ar[LIM][SIZE] = { "" };
	printf("Enter %d strings(less than %d letters):\n", LIM, SIZE);
	printf("or with EOF to end enterd : \n");
	for (i = 0; i < LIM; i++)			//字符串数量
	{
		for (k = 0; k < SIZE; k++)		//每个字符串字符数量
		{
			ar[i][k] = getchar();		//读取字符

			if (ar[i][k] == '\n')		//字符串输入结束标记
			{
				ar[i][k] = '\0';
				break;
			}
			if (ar[i][k] == EOF)		//读到EOF处理
			{
				flag = i;
				goto loop;
			}
		}
		while (ar[i][SIZE - 1])			//输入溢出处理
		{
			ar[i][SIZE - 1] = '\0';
			while (getchar() != '\n')
				continue;
		}
		flag = i;
	}
loop:menu();
	while ((num = choice()) != 5)
	{
		switch (num)
		{
		case 1: {for (i = 0; i < flag; i++)printf("%s\n", ar[i]); menu(); getchar(); continue; }
		case 2: {put2(ar, flag); menu(); getchar(); continue; }
		case 3: {put3(ar, flag); menu(); getchar(); continue; }
		case 4: {put4(ar, flag); menu(); getchar(); continue; }
		default: {printf("Please enter right number.\n"); menu();
			while (getchar() != '\n')
				continue; }
		}
	}
	printf("Bye.\n");
	return 0;
}
void menu(void)
{
	printf("************************************\n");
	printf("1.print the strings as you enterd.\n");
	printf("2.print the strings as ASCII order.\n");
	printf("3.print incrementally by string length.\n");
	printf("4.print the strings as first string length.\n");
	printf("5.quit.\n");
	printf("************************************\n");
	return;
}
int choice(void)
{
	int n;
	scanf_s("%d", &n);
	return n;
}
void put2(char ar[][SIZE], int n)
{
	int i, top, seek;
	char *exp[LIM];
	char *temp;
	for (i = 0; i < LIM; i++)
		exp[i] = ar[i];
	for (top = 0; top < LIM - 1; top++)
		for (seek = top + 1; seek < LIM; seek++)
			if (strcmp(exp[top], exp[seek]) > 0)
			{
				temp = exp[top];
				exp[top] = exp[seek];
				exp[seek] = temp;
			}
	for (i = LIM - n - 1; i < LIM; i++)
	{
		if (exp[i] != 0)
		{
			printf("%s", exp[i]);
			printf("\n");
		}
	}
}
void put3(char ar[][SIZE], int n)
{
	int i, top, seek;
	char *exp[LIM];
	char *temp;
	for (i = 0; i < LIM; i++)
		exp[i] = ar[i];
	for (top = 0; top < LIM - 1; top++)
		for (seek = top + 1; seek < LIM; seek++)
			if (strlen(exp[top]) > strlen(exp[seek]))
			{
				temp = exp[top];
				exp[top] = exp[seek];
				exp[seek] = temp;
			}
	for (i = LIM - n - 1; i < LIM; i++)
	{
		if (exp[i] != 0)
		{
			printf("%s", exp[i]);
			printf("\n");
		}
	}
}
void put4(char ar[][SIZE], int n)
{
	int i, k,top, seek,p;	
	char *exp[LIM];
	char *temp;
	int lenthl[LIM];
	for (i = 0; i < LIM; i++)//复制数组
		exp[i] = ar[i];
	for (i = 0; i < LIM; i++)
	{
		p = 0;
		for (k = 0; k < SIZE; k++)
		{			
			if (exp[i][k] != ' '&&exp[i][k] != '\t'&&exp[i][k] != '\0')
				p++;
			else
				break;
		}
		lenthl[i] = p;			
	}
	for (top = 0; top < LIM - 1; top++)//排序
		for (seek = top + 1; seek < LIM; seek++)
			if (lenthl[top] >= lenthl[seek])
			{
				temp = exp[top];
				exp[top] = exp[seek];
				exp[seek] = temp;
			}
	for (i = 0; i < LIM; i++)
	{		
		printf("%s", exp[i]);
		printf("\n");		
	}
}



	12.编写一个程序，读取输入，直至读到EOF，报告读入的单词数、大写字母数、小写字母数、
	标点符号数和数字字符数，使用type.h头文件中的函数；	
	
#include<stdio.h>
#include<ctype.h>
int main(void)
{
	char ch;
	int words, up, low, mark, num,temp;	
	words = 0;
	up = 0;
	low = 0;
	mark = 0;
	num = 0;
	temp = 1;
	while ((ch = getchar()) != EOF)
	{			
		if (ch == ' ' || ch == '\t' || ch == '\n')
		{
			temp = 0;
			continue;
		}
		else
		{
			if (temp == 0)
			{
				words++;
				temp = 1;
			}
			if (isupper(ch))
				up++;
			if (islower(ch))
				low++;
			if (ispunct(ch))
				mark++;
			if (isdigit(ch))
				num++;
		}
	}
	printf("Here is the report:\n");
	printf("The number of words:%d\n", words);
	printf("The number of uppercase letters:%d\n", up);
	printf("The number of lowercase letters:%d\n", low);
	printf("The number of punctuation marks:%d\n", mark);
	printf("The number of numeric characters:%d\n", num);
	return 0;
}
	



	13.编写一个程序，反序显示命令行参数的单词，例如命令行参数是see you later,
	程序应该打印later you see.
	
	非命令行模式：
	***********************************************************************************
	#include<stdio.h>
	#define LIM 10
	#define SIZE 20
	int main(void)
	{
		int i, k;
		i = 0;
		k = 0;
		char ar[LIM][SIZE] = {""};
		while((ar[i][k] = getchar())!='\n')	//当输入不是回车
		{		
			if (ar[i][k] != ' ')		//若输入不是空格	
				k++;		//递增字符
			else
			{			//若输入空格			
				ar[i][k+1] = '\0';	//空格替换成字符串结尾				
				i++;		//递增字符串
				k = 0;		//字符计数器重置
			}
		}
		if (ar[i][k] == '\n')			//读取回车处理
		{
			ar[i][k] = ' ';		//回车符替换成字符串结尾
			ar[i][k + 1] = '\0';			
		}
		for (i = k+2; i >= 0; i--)		//输出数组字符串内容
			printf("%s", ar[i]);
		return 0;
	}
	*****************************************************************************************
	命令行模式：
	#include<stdio.h>
	int main(int argc,char *argv[])
	{
		int k;
		for (k = 1;k < argc; k++)	
			printf("%s ",argv[argc-k]);
		printf("\n");	
		return 0;
	}


	14.编写一个通过命令行运行的程序计算幂，第一个命令行参数是double类型的数，作为幂的底数；
	第二个参数是正数，作为幂的指数。
	
	#include<stdio.h>
	#include<stdlib.h>
	int main(int argc, char *argv[])
	{	
		int i,n;
		double m=1.0,k;
		k = atof(argv[1]);
		n = atoi(argv[2]);
		for (i = 0; i <n ; i++)
			m = m*k;
		printf("%.2f", m);
		return 0;
	}


	15.使用字符分类函数实现atoi()函数，如果输入的字符串不是纯数字，该函数返回0；
	
#include<stdio.h>
#include<ctype.h>
#define LIM 10
int strtoint(char *str);
int intmi(int a, int b);
int main(void)
{
	int k;
	char ar[LIM];
	scanf_s("%s", ar, LIM);
	k=strtoint(ar);
	printf("%d", k);
	return 0;
}
int intmi(int a, int b)
{
	int i;
	int sum=1;
	for (i = 0; i < b; i++)
		sum = sum * a;
	return sum;
}
int strtoint(char *str)
{
	int i, k,sum;
	sum = 0;
	i = 0;
	while (*(str + i))
	{		
		if (isdigit(*(str + i)))
			i++;
		else
			return 0;
	}
	printf("i=%d\n", i);
	for (k = 0; k < i; k++)
	{
		sum += intmi(10,i-k-1)*(*(str + k)-48);
		printf("k=%d,sum=%d,str+k=%d\n",k, sum,*(str+k)-48);
	}
	return sum;	
}


	16.编写一个程序读取输入，直到文件结尾，然后把字符串打印出来，该程序识别和实现下面的命令行参数：
	-p	按原样打印
	-u	把输入全部转换成大写
	-l	把输入全部转换成小写
	如果没有命令行参数，则让程序像是使用了-p参数那样运行。

	
#include<stdio.h>
#include<ctype.h>
#include<string.h>
int main(int argc, char **argv)
{	
	char ch;
	while ((ch = getchar()) != EOF)
	{
		if (argc <= 1)
			putchar(ch);
		else
		{
			if (strcmp(argv[1], "-p") == 0)
				putchar(ch);
			else if (strcmp(argv[1], "-u") == 0)
			{
				ch=toupper(ch);
				putchar(ch);
			}
			else if (strcmp(argv[1], "-l") == 0)
			{
				ch=tolower(ch);
				putchar(ch);
			}
		}
	}
	return 0;	
}




第十二章	存储类别、链接和内存管理
	
	关键字：auto、extern、static、register、const、volatile、restricted、_Thread_local、_Atomic
	函数：rand()、srand()、time()、malloc()、calloc()、free()
	如何确定变量的作用域(可见范围)和生命周期(它存在多长时间)
	设计更复杂的程序

	
12.1	存储类别
	C提供了多种不同的模型或存储类别在内存中储存数据。

	从硬件上看，被储存的每一个值都占用一定的物理内存，C把这块内存称为对象；
	对象可以储存一个或多个值，一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小
	(面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言)
	
	从软件上看，程序需要一种方法访问对象，这可以通过声明变量来完成:
	int entity=3;
	该声明创建了一个名为entity的标识符，标识符是一个名称，可以用来指定特定对象的内容；
	标识符遵循变量的命名规则；该例中，标识符即是软件指定硬件内存中的对象的方式；该声明还提供了储存在对象中的值
	
	变量名不是指定对象的唯一途径；比如：
	int *pt=&entity;
	int ranks[10]；
	在上面声明中，pt是一个标识符，它指定了一个储存地址的对象，但是*pt不是标识符，因为它不是一个名称；
	然而它确实指定了一个对象，在这种情况下，它与entity指定的对象相同；
	一般而言，那些指定对象的表达式被称为左值；所以entity既是标识符也是左值；*pt即是表达式也是左值；
	按照这个思路，rank+2*entity即不是标识符(不是名称),也不是左值(他不指定内存位置上的内容)；
	但是，表达式*(rank+2*entity)是一个左值，因为它的确指定了特定内存位置的值，即ranks的第7个元素；
	ranks的声明创建了一个可容纳10个int类型元素的对象，该数组的每个元素也是一个对象；

	所有这些示例中，如果可以使用左值改变对象中的值，该左值就是一个可修改的左值；
	考虑下面的声明:
	const char *pc="Behold a string literal!";
	程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符串的数组就是一个对象；
	由于数组中的每个字符都能被单独访问，所以每个字符也是一个对象。
	该声明还创建了一个标识符为pc的对象，储存着字符串的地址；
	由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的左值；
	const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指向别的字符串；
	由于*pc指定了储存'B'字符的数据对象，所以*pc是一个左值，但不是一个可修改的左值，
	与此类似，因为字符串字面量本身指定了储存字符串的对象，所以也是一个左值，但不是可修改的左值；

	可以用储存期描述对象，储存期是指对象在内存中保留了多长时间；
	标识符用于访问对象，可以用作用域和链接描述标识符，标识符的作用域和链接表明了程序的哪些部分可以使用它；
	不同的储存类别具有不同的储存期、作用域和链接；

	标识符可以在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函数中使用，
	甚至只在函数中的某部分使用；
	对象可存在于程序的执行期，也可以仅存在于它所在的函数的执行期；
	对于并发编程，对象可以在特定线程的执行期存在，可以通过函数调用的方式显示分配和释放内存；
	
12.1.1	作用域
	
	作用域描述程序中可访问标识符的区域。一个C变量的作用域可以是块\函数\函数原型\文件 作用域。
	到目前为止，本书程序示例中使用的变量几乎都具有块作用域。
	块是用一对花括号括起来的代码区域；
	例如整个函数体是一个块，函数中的任意复合语句也是一个块。
	定义在块中的变量具有块作用域；块作用域变量的可见范围是从定义处到包含该定义的块的末尾；
	
	另外，虽然函数的形参声明在函数的花括号之前，但是它们也具有块作用域，
	因此下面代码中变量cleo和patrick都有块作用域
	double blocky(double cleo)
	{
		double patrick=0.0;
		......
		return patrick;
	}

	声明在内层块中的变量，其作用域仅局限于该声明所在的块：

	double blocky(double cleo)
	{
		double patrick=0.0;
		int i;
		for(i=0;i<10;i++)
		{
			double q=cleo*i	//q的作用域开始
			......
			patrick*=q;
		}			//q的作用域结束
		......
		return patrick;
	}

	在该例中，q的作用域仅限于内层块，只有内层块中的代码才能访问q；

	以前，具有块作用域的变量都必须声明在块的开头，C99放宽了这限制，允许在块中的任意位置声明变量；
	因此对于for的循环头可以这样写：

	for(int i=0;i<10;i++)
		printf("i=%d",i);

	C99把块的概念扩展到for循环、while循环、do while循环和 if语句所控制的代码，
	即使这些代码没有花括号括起来，也算是块的一部分，
	所以上面for循环中的变量i视为for循环块的一部分，它的作用域仅限于for循环，离开for循环无法访问i；
	
	函数作用域仅用于goto语句的标签。
	这意味着即使一个标签首次出现在函数的内层块中，它的作用域也延申至整个函数；	
	如果在两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发生。//哪里防止了？？？

	函数原型作用域，用于函数原型中的形参名(变量名)，如下所示：
	int mighty(int mouse,double large);
	
	函数原型作用域范围是从形参定义处到原型声明结束；
	这意味着，编译器在处理函数原型中的形参时只关心它的类型，而形参名(如果有的话)通常无关紧要；
	而且即使有形参名，也不必与函数定义中的形参名相匹配。只有变长数组中，形参名才有用；

		

	
	
	









	
	



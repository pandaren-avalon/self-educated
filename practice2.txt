【C primer Plus自学】

【第一章】初识

C语言历史和特性；
程序编写步骤；
编译器和链接器；
C标准；

1.4 	计算机能做什么
	计算机组成：
	①中央处理单元 CPU；
	②随机存储内存RAM；
	③永久内存存储 硬盘；
	④支持设备、外设等；

	CPU：	从内存获取并执行一条指令；然后再下一条；
		CPU有自己的小工作区；若干个寄存器；寄存器可存储一个数字；
		一个寄存器存储下一条指令的内存地址（寄存器a）；
		CPU用该地址来获取和更新下一条指令；
		CPU在获取指令后，在另一个寄存器（寄存器b）存储该指令；并更新寄存器a的下一个地址；
	CPU能理解的指令有限（指令集）多数用于将一个数从一个位置移动到另一个位置；
	存储在计算机内的所有内容都是数字；
	计算机程序最终都必须以数字指令码来表示；
	
	计算机工作原理：
	如果希望计算机做某些事：
	1.必须为其提供特殊的指令列表（程序）；确切的告诉它要做的事以及如何做；
	2.必须用计算机直接明白的语言（机器语言）创建程序；
	例如：两数相加；
		①从内存位置2000上，把一个数字拷贝到寄存器1；
		②从内存位置2004上，把一个数字拷贝到寄存器2；
		③把寄存器2和寄存器1中的内容相加，将结果存在寄存器1中；
		④将寄存器1中的内容拷贝到内存位置2008；

1.5 	高级计算机语言和编译器
	高级编程语言在计算机看来是一堆无法理解的无用数据；
	编译器：将高级程序语言翻译成机器语言指令集；

1.6 	C语言标准：C89/C90  C99  C11

1.7 	使用C语言的7个步骤
	1.定义程序目标：用一般术语表达；比如：
		程序需要那些信息（输入）；
		程序需要进行哪些计算和控制（运行）；
		程序应该报告什么信息（输出）；
	2.设计程序：比如：用户界面？组织程序？目标用户？如何表达数据？数据处理方法？
	3.编写代码：用文本编辑器创建源代码；
	4.编译：
		①将源代码转换成可执行代码（机器语言）；
		②将源代码和库代码合并成最终程序（链接器），生成可执行文件；
	5.运行程序：
		①常规环境（Windows带命令提示符、UNIX、LinUX）输入可执行文件名；
		②集成开发环境（IDE）菜单选项或者特殊键（单双击）执行；
	6.测试、调试程序：查找并修复程序错误（debug）;
	7.维护和修改代码；
	*程序越庞大越复杂，事先定义和程序设计环节工作量越大；

1.8 	编程机制
	源代码――编译器――目标代码――链接器――可执行代码
	(.c文件)		(.obj文件)	   库代码       (.exe文件)	
	  code		 目标文件	   启动代码    应用程序文件

【第二章】概述
运算符：=
函数main()、printf()
编写一个简单C程序；
创建整型变量，为其赋值并打印；
换行字符；
注释；多个函数程序；
关键字；


	

2.1
	#include<stdio.h>		//包含另一个文件；
	int main(void)		//主函数名；
	{			//表面函数开始；
		int a;		//声明变量a；
		a=1;		//赋值表达式；
		printf("%d",a);	//调用一个函数printf();	
		return 0;		//返回值；
	}			//函数结束；
2.2
	1. #include指令和头文件
	#include<stdio.h>相当于将stdio.h文件中的所有内容输入该行；实质为复制粘贴；方便共享许多程序共有信息；
	#include是一条C语言预处理信息；#表明C预处理器在编译器接手前处理这条指令；
	通常在C程序顶部信息集合，称为头文件；
	特定C实现的文档中应包含对C库函数的说明，确定了使用哪些函数需要用到哪些头文件；

	2. main()函数
	C程序一定从main()函数开始执行，除了main()函数可以任意命名其他函数名；
	int是main()函数的返回类型，返回整数给操作系统；
	int main(void)：	()内包含了一些传入函数的信息，若不需要传递任何信息，()内用单词void；

	3. 注释  // 注释到本行结尾   /*……*/ 注释掉中间部分内容；
	
	4. 花括号{}标记函数开始与终结；

	5. 声明
	int a;	这行代码完成两件事；①声明函数中有个变量a；②int表明变量a是个整数；
		int是一种数据类型，编译器以此为变量a在内存中分配存储空间；
		a  是一种标识符，是一个变量、函数或者其他实体的名称；
		C语言中所有变量都必须声明后才能使用；
	命名：尽量使用有意义的变量名；编译器能识别前63字符，可以用大小写数字下划线命名，第一位不能用数字；

	6. 赋值：
	a=1；	在执行声明时，编译器在内存中为变量a预留了空间，赋值时将值存储在预留位置；
		赋值表达式为从右侧将值赋到左侧；
		C语言是通过赋值运算而不是赋值语句完成操作；
	
	7. printf()函数
		printf()括号中的内容为main()函数传递给printf()函数的信息；()内信息为函数实际参数；
		①实际参数：传递给函数的特定值；
		②形式参数：函数中用于储存变量的值；
	
	8. return语句
		int main(void)函数中的int表明main()函数应返回一个整数；有返回值的函数需要有return语句；
		return语句是一种跳转语句；

【练习题1.】
	编写一个程序，把你的姓名打印在一行，输出如下：

	Gustav Mahler	//第1次打印的内容
	Gustav 		//第2次打印的内容
	Mahler		//仍是第2次打印的内容
	Gustav Mahler	//第3、4此打印的内容

	#include<stdio.h>
	int main(void)
	{
		printf("Gustav Mahler\n");
		printf("Gustav\nMahler\n");
		printf("Gustav ");
		printf("Mahler\n");
		getchar();
		return 0;
	}

【练习题2.】
	编写一个程序，打印你的姓名和地址。

	#include<stdio.h>
	int main(void)
	{
		printf("Name:***\nAddress:Room***, unit***, building**,***Road,***District,***City,***Province\n");
		getchar();
		return 0;
	}

【练习题3.】
	编写一个程序，把你的年龄转换成天数，并显示这两个值，不考虑闰年问题。

	#include<stdio.h>
	int main(void)
	{
		int age, day;
		age = 18;
		day = age * 365;
		printf("Your age:%d\nConvert age to days:%d\n", age, day);
		getchar();
		return 0;
	}

【练习题4.】
	编写一个程序，生成以下输出;除了main()函数以外，自定义两个函数；
	hello world
	hello world
	hello world
	i'm good

	#include<stdio.h>
	void hello(void){printf("hello world\n");}
	void good(void){ printf("i'm good\n"); }
	int main(void) 
	{
		hello(); 
		hello();
		hello();
		good();
		getchar();
		return 0;
	}

【练习题5.】
	编写一个程序，生成以下输出；除了main()函数外，自定义两个函数br()和ic()分别为“Brazil,Russia”;和“India,China”;
	各依次调用并打印一次，其余内容在main()函数中完成。

	Brazil,Russia,India,China
	India,China，
	Brazil,Russia

	#include<stdio.h>
	void br(void) { printf("Brazil,Russia"); }
	void ic(void) { printf("India,China"); }
	int main(void) 
	{
		br();
		printf(",");
		ic();
		printf("\n");
		printf("India,China,\n");
		printf("Brazil,Russia");
		getchar();
		return 0;
	}

【练习题6.】
	编写一个程序，创建一个整型变量toes，并将toes设置为10.程序中还要计算toes的两倍和平方并打印和描述；

	#include<stdio.h>
	int main(void) 
	{
		int toes;
		toes = 10;
		printf("toes=%d\n2*toes=%d\ntoes*toes=%d\n", toes, 2 * toes, toes*toes);
		getchar();
		return 0;
	}

【练习题7.】
	编写一个程序，生成以下格式输出；自定义一个函数，调用一次打印一次“smile!”
	smile!smile!smile!
	smile!smile!
	smile!
	
	#include<stdio.h>
	void smile(void) { printf("smile!"); }
	int main(void) 
	{
		smile(); 
		smile();
		smile();
		printf("\n");
		smile();
		smile();
		printf("\n");
		smile();
		printf("\n");
		getchar();
		return 0;
	}

【练习题8.】
	编写一个函数，调用one()的函数打印“one”调用two()函数打印“two”，要求输出如下：
	starting now:
	one
	tow
	three
	done!


	#include<stdio.h>
	void one(void) { printf("one"); }
	void two(void) { printf("two"); }
	int main(void) 
	{
		printf("starting now\n");
		one();
		printf("\n");
		two();
		printf("\n");
		printf("three\n");
		printf("done!\n");
		getchar();
		return 0;
	}

【第三章】数据和C

关键字int、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary
运算符 sizeof()
函数 scanf()
整数类型和浮点数类型的区别；


3.1	
	#include<stdio.h>
	int main(void)
	{
		float weight;	//浮点数变量
		float value;
		float prince;
		prince=1700.0;
		printf("please enter your weight in pounds: ");
		scanf_s("%f",&weight);	//scanf_s()读取键盘输入；%f浮点数占位符
		value=prince*weight*14.5833;	//变量与常量；
		printf("your weight in platinum is worth $%.2f.\n",value);	//%.2f .2控制精度
		printf("if platinum princes drop,eat more maintain your value.\n");
		getchar();
		getchar();
		return 0;
	}

3.3
	【数据类型关键字】

            【K&C】		【C90】		【C99】

	int		signed		_Bool
	long		void		_Complex
	short				_Imaginary
	unsigned
	char
	float
	double

	【位、字节和字】

	最小的存储单元是位(bit)，可以存储0或1；
	字(byte)节是常用的计算机存储单位;
	1字节=8位 1byte=8bit;
	既然1位可以表示0或者1，8位字节就有256种可能组合(2的8次方)；
	通过二进制编码，便可表示0-255的整数或一组字符；
	字(word)、计算机进行数据处理时，一次存取、加工和传送的数据长度称为字(word)；
	字长越大，数据转移越快；允许访问的内存也更多；

	【整数和浮点数】
	整数：2进制存储；最高位设置为符号位，1代表负数(负数补码=负数反码)，0代表正数(正数原码=反码=补码)；
	浮点数：与整数存储方案不同；采用小数部分+指数部分来表示；

3.4
	【int类型】（有符号整型）
		
	int类型的值必须是整数，可以是正整数、负整数或0，取值范围随系统，ISO C规定最小16位(-32768~32767)；
	
	1.声明int变量	
	int a;
	int b;
	int a,b;

	给变量提供值的方法：

	①赋值：
		int a;
		a=1;
	②函数获取：
		int a;
		scanf_s("%d",&a);
	

	2.初始化变量：C语言中可以直接在声明中给变量赋一个初始值
		int a=1;
	
	声明其实已经位变量创建和标记了存储空间，若初始化在声明里，则为其直接指定初始值；

	3.int类型常量
	C语言把不含小数点和指数的数作为整数，如22和-44是整型常量，但22.0和2.2E1则不是；
	C语言把大多数整型常量视为int类型，但是非常大的整数除外（long常量）；
	
	4.打印 int 值
	可以使用printf()函数；%d称为"转换说明”,它指定了printf()函数应使用什么格式来显示一个值；
	使用printf()函数时，要确保转换说明数量%d与待打印值的变量数相等，若无指定，将读取内存中任意值

	5.八进制和十六进制
	计算机如何10000是十进制十六进制还是二进制？C语言中用特定的前缀表示；
	0x或者0X前缀表示十六进制  	例如十进制16等于十六进制0x10
	0前缀表示八进制；		例如十进制16等于八进制020
	
	6.显示八进制和十六进制；
	%d――十进制
	%o――八进制
	%x――十六进制
	另外若要显示后两种进制数的前缀0、0x或0X，分别使用%#o、 %#x、 %#X，例如打印十进制的100：

	#include<stdio.h>
	int main(void)
	{
		int a = 100;
		printf("dec=%d,	octal=%o,	hex=%x\n", a, a, a);//十进制、八进制、十六进制
		printf("dec=%d,	octal=%#o,	hex=%#x,	hex=%#X\n", a,a,a,a);
		getchar();
		return 0;
	}

	【其他整数类型】：

	short int 类型(或简写为short)用于较小数值的场合以节省空间，是有符号类型；
	long  int 类型(或简写为 long)用于较大数值的场合，也是有符号类型；
	long long int (或简写为 long long)占用64位以上的更大数值场合，也是有符号类型；
	unsigned int  (或简写为unsigned)只用于非负数值的场合，
		例如16位取值范围为0~65535，而非-32768~32767，是用符号位拿来存二进制位；
	在任何有符号类型前面添加关键字signed，可强调使用有符号类型的意图。

	1.声明其他整数类型：与int相同；

	2.int long short 只规定了占位大小关系，因为对16位机或者32位机甚至64位机对应的取值范围不同；
	   通常个人PC最常见设置 long long占64位，long占32位，short占16位，int占16或32位(依计算机字长)；
	  ① 当取值范围在int内，尽量不用long，，使用long类型会减慢运算速度；其他关键字类推；
	  ②若需要从32位机移植程序到16位机的情况，若有当需要用到32位数字时，用long，其他关键字类推；

	3.long 和long long
	通常程序中使用的数字会被存储为int类型；
	若超出范围，编译器依次视其为long----unsigned long----long long-nusigned long long
	特定情形下需要用long存储一个小数字，可以加个后缀l或者L 大写字母易区分1与l；如7L；9LL；
	
	整数溢出
	#include<stdio.h>
	int main(void)
	{
		int a=2147483647;
		unsigned int b=4294967295;
		printf("%d %d %d\n",a,a+1,a+2);
		printf("%u %u %u\n",b,b+1,b+2);
		getchar();
		return 0;
	}

	观察结果，溢出后数字从定义类型范围的最小始开始
	最小看取值范围int、 unsigned int
	本例中int为32位（+标识符加31位数字，二进制下为+2147483647）范围(-2147483648~2147483647)
	所以unsigned范围为（0~4294967295）例题中a+1和b+1数字溢出后从最小处重新开始取值；

	4.打印short、long、long long和unsigned
	short		――%hd；（%hx；%ho）	//十进制、十六进制、八进制；
	long		――%ld；（%lx；%lo）	//常量后缀在转换说明里只能用小写；
	long long		――%lld；（%lldx;%lldo）
	
	unsigned		――%u；

	nusigned short	――%hu;
	unsigned long	――%lu；
	nusigned long long	――%llu；
	
	#include<stdio.h>
	int main(void)
	{
		unsigned a = 3000000000;	//int为32位下系统；
		short b = 200;
		long c = 65537;
		long long d = 12345678908642;

		printf("a=%u not %d \n", a, a);
		printf("b=%hd and %d \n", b, b);
		printf("c=%ld not %hd \n", c, c);
		printf("d=%lld not %ld", d, d);

		getchar();
		return 0;
	}
	
	①第一行输出：%d和%u的区别在于signed和unsigned的区别，两个输出不同的值在内存中的二进制排列相同；
	   但是在signed读取的时候，最高位的数字被读取成符号位；unsigned则直接为数字一部分；
	   在两个数集的交集部分，则两者输出结果相同；
	②第二行输出：输出结果相同，C编译器把short类型的值自动转换成int类型的值；int类型参数传递快效率高；
	③第三行输出：使用h修饰符可以显示较大整数被截断成short类型值的情况；
	   65537在32位里二进制是0000 0000 0000 0001 0000 0000 0000 0001 %hd只会查看后16位，所以显示为1；
	④同上；

	综上，不管是unsigned、整数溢出或者转换说明的出错，其实质都是定义数集合的范围不一样导致的；
	存储在内存中的二进制数，对不同的定义和转换说明，读取到的排列序，即在这个定义集合里的值都不一样；
	计算机能存储的状态就是0和1的有限组合，同样的组合能根据用户的定义给出更多的不同值的表达；

	【char类型】

	char类型用于存储字符，但从技术层面看，char是整数类型，char实际上存储的是整数而不是字符。

	ASCII编码――字符的本质：

	#include<stdio.h>	
	int main(void)
	{
		int i;
		for (i = 0; i <= 127; i++) 	//0-127或者0-255ASCII拓展表
			printf("%d %c\n", i, i); 
		getchar();
		return 0;
	}
	C语言把1字节定义为char类型占用的位数(bit)，因此16位或者32位系统都可以使用char类型

	1.声明char类型变量
	char a;
	char a,b;
	
	2.字符常量和初始化
	char a;
	char a='A';	//正确赋值字符初始化常量，A是字符；
	char a=A;		//错误，此时A是一个变量；
	char a="A"	//错误，此时"A"是一个字符串；
	char a=65; 	//前提是系统使用ASCII码，不推荐；

	*C语言将字符常量视为int类型而非char类型；
	例如int为32位，char为8位，可以将4个独立的ASCII编码储存在32位存储单元中;
	试运行下列代码：

	#include<stdio.h>
	int main(void)
	{
		char a='FATE';
		printf("%c\n", a);
		getchar();
		return 0;
	}
	实际这样的字符常量赋给char类型，只有最后8位有效，所以显示的是字母E；

	再试试下面的代码:

	#include<stdio.h>
	#include<windows.h>
	int main(void)
	{
		char a;
		scanf_s("%c", &a);
		printf("%c\n", a);
		Sleep(2000);
		return 0;
	}
	尝试输入多个字母，显示的仍为第一个输入的字母；

	3.非打印字符/控制字符
	如何表达这些字符
	①用ASCII码	char beep=7;
	②转义序列使用转义字符表达	char nerf='\n';
	\a	警报
	\b	退格
	\f	换页
	\n	换行
	\r	回车
	\t	水平制表符
	\v	垂直制表符
	\\	反斜杠\
	\'	单引号
	\"	双引号
	\?	问好
	\0oo	八进制值(oo八进制数，即每个o可表示0~7中的一个数)
	\xhh	十六进制值(hh十六进制数，即每个h可表示0~f中的一个数)
	
	4.打印字符

	#include<stdio.h>	
	int main(void)
	{
		char ch = 'C';
		printf("%c is %d", ch, ch);
		getchar();
		return 0;
	}


	printf()函数用%c打印字符，printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式:
	
	存储方式：  ch: 0100 0011（ASCII码中字符C）
	读取方式	%c――输出图形字符 C
		%d――输出十进制值 67
	
	5.有符号还是无符号
	根据C90标准，C语言允许在关键字char前面使用signed(-128-127)或unsigned(0-255);
	这在用char类型处理小整数时很有用，如果只用处理char处理字符，则无需任何修饰符；

	【_Bool类型】

	C99标准添加表示布尔值，即逻辑true和false；C语言用1和0表示，原则上它仅占用1位存储空间

	【可移植类型：stdint.h和inttypes.h】

	C语言提供了许多整数类型，但是某些型名在不同系统中功能不一样；
	C99新增的两个头文件；以却把C语言的类型在各个系统中的功能相同；
	stdint.h头文件：
	精确宽度整数类型，如int32_t表示整数类型的宽度正好是32位；
	最小宽度类型，如int_least8_t表示可容纳8位有符号整数值的类型中宽度最小的类型的一个别名；
	最快最小宽度类型，如int_fast8_t定义为系统中对8位有符号值而言运算最快的整数类型的别名；
	最大整数类型，如intmax_t,可存储任何有效的有符号的整数，unitmax_t表示最大无符号整数类型；
	
	C99和C11不仅提供可移植的类型名，还提供相应的输入和输出；
	比如printf()打印特定类型时，要求对应的转换说明匹配，int32_t类型的值，有%d、%ld的区分使用；
	C标准针对这情况，提供了一些字符串宏来显示可移植类型，如inttypes.h头文件中定义了PRId32字符串宏；
	范例：

	#include<stdio.h>	
	#include<inttypes.h>//支持可移植类型
	int main(void)
	{
		int32_t m32;	//声明m32为一个32位有符号整型变量;
		m32 = 45933945;
		printf("m32=%d\n", m32);
		printf("m32=%"PRId32"\n",m32);
		getchar();
		return 0;
	}
	 
	在最后一行printf()中，参数PRId32被定义在inttypes.h中的“d”替换，所以输出相等；

	【float、double 和 long double】

	浮点数的表示类似于科学记数法――指数记数法(科学记数法在计算机中的写法)；例：
	
	数字		科学记数法	指数记数法
	1000000000	1.0*10^9		1.0e9
	123000		1.23*10^5		1.23e5
	322.56		3.2256*10^2	3.2256e2
	0.00056		5.6*10^-5		5.6e-5
	
	C标准规定，float类型必须至少能表示6位有效数字，取值范围10e-37~10e37
	一般系统储存一个浮点占用32位，其中8位表示指数的值和符号，24位表示非指数部分(尾数/有效数)及其符号；
	C语言提供的另一种浮点类型是double(双精度)，至少能表示10位有效数字，一般占用64位；

	1.声明浮点型变量 与整型变量相同；

	2.浮点型常量：
	有符号的数字(包括小数点)后面跟e或者E最后是一个有符号数表示10的指数，如：
	-1.56E+12;
	2.87e-3;
	正号可以省略；不要在浮点型常量中间加空格；
	可以没有小数点如2E5或没有指数部分如19.28；但不能同时省略两者；
	可以省略小数部分如3.E16或整数部分如.45E-6,但是不能同时省略两者；
	常量示例：
	3.14159
	.2
	4e16
	.8e-5
	100.
	
	默认情况下，编译器假定浮点型常量是double类型的精度，比如
	float some;
	some=4.0*2.0;
	通常4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘机截断成float宽度；
	这样计算精度更高，但会减慢程序运行速度，所以在浮点数后面加上f或者F可以覆盖默认设置；
	使用l或L后缀可以使数字称为long double类型；没有后缀的浮点型常量是double类型；
	
	C99添加了一种新的浮点常量格式，用十六进制表示浮点型常量
	在十六进制数前加上十六进制前缀(0x或0X)，用p或者P分别代替e和E，用2的幂代替10的幂（P记数法）
	如 0xa.1fp10
	十六进制下,a等于十进制10，.1f是1/16加上15/256(f等于10进制15)，p10是2^10即1024；
	0xa.1fp10表示的十进制值为（10+1/16+15/256）*1024=10364.0

	3.打印浮点值
	printf()函数使用%f转换说明打印float和double类型浮点数；
	用%e打印指数记数法的浮点数；如果系统支持十六进制格式的浮点数，可用a或A分别代替e和E；
	打印long double使用 %Lf、%Le或者%La转换说明；
	给那些未在原型中显式说明参数类型的函数传递参数时，C编译器会把float类型的值自动换成double类型；
	例：两种方式显示float类型的值
	
	#include<stdio.h>	
	int main(void)
	{
		float a = 32000.0;
		double b = 2.14e9;
		long double c = 5.32e-5;
		printf("a=%f = %e\n",a, a);		//a=32000.000000=3.200000e+04
		printf("hexadecimal:\na = %a\n\n",a);	//a=0x1.f400000000000p+14
		printf("b=%f = %e\n", b, b);		//b=2140000000.000000=2.140000e+09
		printf("c=%Lf = %Le\n", c, c);		//c=0.000053=5.320000e-05
		getchar();
		return 0;
	}
	
	4.浮点值的上溢和下溢；

	①上溢范例：
	#include<stdio.h>	
	int main(void)
	{	
		float big = 3.4e38*100.0f;
		printf("%e\n", big);		//输出结果：inf或者infinity无穷大，上溢；
		getchar();
		return 0;
	}
	
	C语言规定当计算导致数字过大，超过当前类型能表达的范围时，给变量赋一个表示无穷大的值；
	
	②下溢范例：
	#include<stdio.h>	
	int main(void)
	{	
		float big = 0.1e-44/2;
		printf("%e\n", big);		//输出结果0.000000e+00
		getchar();
		return 0;
	}
	
	C语言把损失了类型全精度的浮点数称为‘低于正常的浮点值’
	
	还有另一个特殊的浮点值NaN(not a number);
	例如给asin()函数传递一个值，该函数返回一个角度，该角度的正弦就是传入的函数的值；
	但正弦值不能大于1，因此如果传入的参数大于1，该函数的行为是未定义的，函数返回NaN；

	演示舍入错误：

	#include<stdio.h>	
	int main(void)
	{	
		float a, b;
		a = 2.0e20 + 1.0;
		b = a - 2.0e20;
		printf("%f", b);	//输出：4008175468544.000000
		getchar();
		return 0;
	}
	
	原因为计算机缺少足够的小数位来完成正确运算；
	2.0e20 是2后面有20个0；如果把该数加1，那么发生变化的是第21位，要正确计算，程序至少要存储21位数字；
	而float类型的数字通常只能存储按指数比例缩小或放大的6或7位有效数字；

	显示精度问题

	#include <stdio.h>	
	int main()
	{
	float a;
	double b;
	a=3.1415926535897932;
	b=3.1415926535897932;	
	printf("%.15f",a);		//输出结果a=3.141592741012573;".15"表示保留小数点后15位
	printf("%.15lf",b);		//输出结果a=3.141592653589793
	getchar();			
	return 0;
	}

	【复数和虚数类型】

	3种复数类型，float_Complex、double_Complex、long double_Complex
	3种虚数类型，float_Imaginary、double_Imaginary、long double_Imaginary
	
	【其他类型】
	
	数组、指针、结构和联合等

	指针――指向变量或其他数据对象位置，如scanf()函数里用到的前缀&，告诉函数把数据放在何处；
		
	【类型大小】
	如何知道当前系统的指定类型大小是多少？%zd 或者%u %lu;

	#include<stdio.h>
	int main(void)
	{
		printf("int size =%zd bytes\n", sizeof(int));
		printf("short size =%zd bytes\n", sizeof(short));
		printf("long size =%zd bytes\n", sizeof(long));
		printf("long long size =%zd bytes\n", sizeof(long long));
		printf("unsigned size =%zd bytes\n", sizeof(unsigned));
		printf("char size =%zd bytes\n", sizeof(char));
		printf("float size =%zd bytes\n", sizeof(float));
		printf("double size =%zd bytes\n", sizeof(double));
		printf("long double size =%lu bytes\n", sizeof(long double));
		getchar();
		return 0;
	}
	
3.5
	【合理选用变量类型】

	int a=3			//正确
	int b=3.0			//不推荐；
	int c=12.99		//取值C为12，int截断小数部分，精度丢失严重
	float d=3.1415926536	//损失精度；float只保证前6位精度，编译器警告；
	
3.6	【参数与陷阱】

	printf() 和 scanf()与一般函数不同，他们的参数个数是可变的；
	第一个字符串的转换说明与后面的参数需一一对应；
	程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹配；
	错误示例：
	#include<stdio.h>
	int main(void)
	{
		int m = 4;
		int n = 5;
		float f = 7.0f;
		float g = 8.0f;
		printf("%d\n", n, m);		//参数太多
		printf("%d %d %d\n", n);	//参数太少
		printf("%d %d\n", f, g);	//转换说明类型不匹配
		getchar();
		return 0;
	}
		
3.7	【转义序列】
	
	#include<stdio.h>
	int main(void)
	{
		float salary;
		printf("\aEnter your salary:");	
		printf(" $________\b\b\b\b\b\b\b");
		scanf_s("%f",&salary);
		printf("\n\t$%.2f a month is $%.2f a year.",salary,salary*12.0);
		printf("\rGee!\n");
		getchar();
		getchar();
	}

	
	最初，printf()语句把输出发送到一个叫做缓冲区的中间存储区域，然后再发送到屏幕上；
	当缓冲区满、遇到换行字符或者需要输入的时候，刷新缓冲区；
	(从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区；)
	旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示任何内容，等待用户输入；
	在这种情况下，可以在示例中第一行输出末尾加入换行字符\n刷新缓冲区。

3.8	计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大差别；
	即使两个32位存储单元存储的位组合完全相同，但一个解释为float类型，另一个解释为long类型；
	这两个相同的位组合表示的值也完全不同；举例：
	假设一个位组合表示float类型的数256.0，如果将其解释为long类型，则值是113246208；
	#include<stdio.h>
	int main(void)
	{
		float a;
		a = 256.0;
		printf("%.1f = %lld",a,a);	//VS2017输出为long long类型4643211215818981376
		getchar();
		getchar();
	}

【练习题1.】
	通过试验(编程验证)观察系统如何处理整数上溢、浮点数上溢和下溢的情况；

	#include<stdio.h>
	int main(void)
	{
		int a;
		float b,c;
		a=1000000000000000;
		b=3.5e+60;
		c=1/b;
		printf("%d\n",a);
		printf("%f\n",b);
		printf("%f\n",c);
		getchar();
		return 0;
	}

【练习题2.】
	编写一个程序，要求提示输入一个ASCII码值(如，66)，然后打印输入的字符；

	#include<stdio.h>
	int main(void)
	{
		int ASCII;
		printf("输入一个ASCII可打印码值(33-127): ");
		scanf_s("%d",&ASCII);
		printf("%c",ASCII);
		getchar();
		getchar();
		return 0;
	}

【练习题3.】
	编写一个程序，发出一声警报，然后输出下面文本：“what was that!”
	
	#include<stdio.h>
	int main(void)
	{
		printf("\awhat was that!\n");
		getchar();
		return 0;
	}

【练习题4.】
	编写一个程序，读取一个浮点数，先打印成小数点形式，再打印成指数形式，如果系统支持，再打成P记数法；
	按以下格式输出：

	Enter a floating-point value: 64.25
	fixed-point notation: 64.250000
	exponential notation: 6.425000e+01
	p notation: 0x1.01p+6

	#include<stdio.h>
	int main(void)
	{
		float pr;
		printf("Enter a floating-point value: ");
		scanf_s("%f", &pr);
		printf("fixed-point notation: %lf\n", pr);
		printf("exponential notation: %e\n", pr);
		printf("p notation: %a\n", pr);
		getchar();
		getchar();
		return 0;
	}

【练习题5.】
	一年大约有3.156*10^7秒。编写一个程序，提示用户输入年龄，然后显示该年龄对应的秒数；

	#include<stdio.h>
	int main(void)
	{
		double sec;
		float age;	
		printf("Enter your age: ");
		scanf_s("%f", &age);
		sec = age * 3.156e+7;
		printf("your ages change to sec = %e", sec);
		getchar();
		getchar();
		return 0;
	}

【练习题6.】
	1个水分子的质量约为3.0*10^-23克，1夸脱水大约是950克，输入水的夸脱数，求水分子数量；

	#include<stdio.h>
	int main(void)
	{
		double qty;	//水分子数量
		double m;
		m = 3.0*10e-32;	//每个水分子的质量；
		float quarts;	//输入的水的夸脱数；
		printf("Enter the number of quarts for water ");
		scanf_s("%f",&quarts);
		qty = quarts * 950 / m;
		printf("there are %e of water molecules", qty);
		getchar();
		getchar();
		return 0;
	}

【练习题7.】
	1英寸相当于2.54厘米。编写一个程序，输入身高(英寸)，然后显示厘米单位身高。

	#include<stdio.h>
	int main(void)
	{
		float height;	//身高cm
		float inch;		//身高in
		printf("Enter your height by inch: ");
		scanf_s("%f", &inch);
		height = inch * 2.54;
		printf("your height is %.1f cm", height);
		getchar();
		getchar();
	}

【练习题8.】
	编写一个程序，用户输入杯数，以其他单位容量显示等价容量；
	1品脱=2杯；1杯=8盎司；1盎司=2汤勺；1汤勺=3茶勺；
	
	#include<stdio.h>
	int main(void)
	{
		float pint, cup, oz, tbsp, tsp;
		printf("Enter the number of cup: ");
		scanf_s("%f", &cup);
		pint = 0.5*cup;
		oz = 8 * cup;
		tbsp = 2*oz;
		tsp = 3*tbsp;
		printf("%.2f cup=%.2f pint\n", cup,pint);
		printf("%.2f cup=%.2f oz\n",cup,oz);
		printf("%.2f cup=%.2f tbsp\n",cup,tbsp);
		printf("%.2f cup=%.2f tsp\n",cup,tsp);
		getchar();
		getchar();
		return 0;
	}
	
【总结】

数据与转换说明：
	关键字		声明/初始化		十进制	八进制		十六进制	
整型	int		int a=1;			%d;	%o;(%#o);		%x;%#x 或%#X;
	unsigned		unsigned a=1;		%u;

	short		short a=1;			%hd;	%ho;		%hx
	unsigned short	unsigned short a=1;		%hu
	long		long a=1L;		%ld;	%lo;		%lx
	unsigned long	unsigned long a=1uL;	%lu
	long long 		long long a=1LL;		%lld
	unsigned long long  unsigned long long a=1ull;	%llu

	关键字		声明/初始化		十进制	指数记数法	
浮点型	float		float a=3.14f		%f	%e	
	double		double=3.14		%f	%e
	long double	long double=3.14L		%f	%e

	关于本机C语言整型数字取值范围：
	8位(bit)	256个数	【char】占用1字节长度；1字节的整型 unsigned (0~255)  signed数字轴左移一半
	16位	256^2个	本机 【short】占用2字节长度；unsigned(0~65535)signed数字轴左移一半
	32位	256^4个	本机【int】【long】占用4字节长度；unsigned(0~4294967295)signed数字轴左移一半
	64位	256^8个	本机【long long】占用8字节长度；unsigned(0~18446744073709551615)signed数字轴左移一半

代码验证如下：
	#include<stdio.h>
	int main(void)
	{
		int a = 2147483647;
		unsigned b = 4294967295;
		short c = 32767;
		unsigned short d = 65535;
		long e = 2147483647;
		unsigned long f = 4294967295;
		long long g = 9223372036854775807;
		unsigned long long h = 18446744073709551615;
		char ch = 'T';
		float j = 3.14159265358979323846;
		double k = 3.14159265358979323846;
		long double l= 3.14159265358979323846;
		float flp = 3.1415926e38;
		float flm = 3.1415926e-45;
		double dp = 3.1415926e307;
		double dm = 3.1415926e-324;
		long double ldp= 3.1415926e307;
		long double ldm = 3.1415926e-324;
		printf("a = %d	a+1=%d		sizeof int = %zd \n", a, a + 1, sizeof(a));
		printf("b = %u	b+1=%u		sizeof unsigned = %zd \n", b, b + 1, sizeof(b));
		printf("c = %hd	c+1=%hd		sizeof short = %zd \n", c, c + 1, sizeof(c));
		printf("d = %hu	d+1=%hu		sizeof unsigned short = %zd \n", d, d + 1, sizeof(d));
		printf("e = %ld	e+1=%ld		sizeof long = %zd \n", e, e + 1, sizeof(e));
		printf("f = %lu	f+1=%lu		sizeof unsigned long = %zd \n", f, f + 1, sizeof(f));
		printf("g = %lld	g+1=%lld		sizeof long long = %zd \n", g, g + 1, sizeof(g));
		printf("h = %llu	h+1=%llu		sizeof unsigned long long = %zd \n", h, h + 1, sizeof(h));	
		printf("ch=%c	ASCII NO.=%d	sizeof char=%zd\n",ch,ch,sizeof(ch));
		printf("j=%.20f	j*10=%e		sizeof float=%zd\n", j, j*10, sizeof(j));
		printf("k=%.20f	k*10=%e		sizeof double=%zd\n", k, k * 10, sizeof(k));
		printf("l=%.20f	k*10=%e		sizeof long double=%zd\n", l, l * 10, sizeof(l));
		printf("flp=%e	flp*10=%e\n", flp,flp*10);
		printf("flm=%e	flm/10=%e\n", flm, flm / 10);
		printf("dp=%e	dp*10=%e\n", dp, dp * 10);
		printf("dm=%e	dm/10=%e\n", dm, dm / 10);
		printf("ldp=%e	ldp*10=%e\n", ldp, ldp * 10);
		printf("ldm=%e	ldm/10=%e\n", ldm, ldm / 10);
		getchar();
		return 0;
	}

【第四章】字符串和格式化输入/输出

4.1
	#include<stdio.h>
	#include<string.h>
	#define DENSITY 62.4//预处理：define 宏定义；
	int main(void)
	{
		float weight,volume;
		int size, letters;
		char name[40];//name是一个可容纳39字符的数组;
		printf("what's your first name?\n");
		gets(name);
		printf("what's your weight in pounds?\n");
		scanf_s("%f", &weight);
		size = sizeof name;
		letters = strlen(name);//strlen()函数获取字串长度；
		volume = weight / DENSITY;
		printf("%s,your volume is %.2f cubic feet.\n", name, volume);//%s 字符串转换说明；
		printf("also,your first name has %d letters.\n", letters);
		printf("we have %d bytes to store it.\n", size);
		getchar();
		getchar();
		return 0;
	}

	【字符串和字符】	
	字符串常量"X"和字符常量'X'不同
	区别1：'X'是基本类型char；“X”是派生类型(char 数组)
	区别2："X"实际上由两个字符组成'X'和空字符 \0	//空字符作为字符串的结束；

	#include<stdio.h>
	#include<string.h>
	#define PRAISE "You are an extraordinary being."
	int main(void)
	{
		char name[40];
		printf("what's your name?\n");
		gets(name);
		printf("hello,%s.%s\n", name, PRAISE);
		printf("your name of %zd letters occupies %zd memory cells.\n", strlen(name), sizeof name);
		printf("the phrase of parise has %zd letters,", strlen(PRAISE));
		printf("and occupies %zd memory cells.\n", sizeof PRAISE);
		getchar();
		getchar();
		return 0;
	}
	例输入'peter'；
	sizeof 运算符报告，name数组有40个存储单元，但是只有前5个单元用来存储peter，所以strlen()函数得出的结果是5；
	name数组的第6个单元存储空字符\0；strlen()并未将其计入；
	对于预定义的PRAISE 用strlen()得出字符串中的字符数为31(含空格、标点)，
	而sizeof运算符给出的数字为32，因为它把字符串末尾不可见的空字符也计算在内。
	该程序并未明确告诉计算机要给PRAISE字符串预留多少空间，所以它必须计算双引号内的字符数；
	
	关于sizeof后面是否带圆括号取决于运算对象是类型还是特定量；
	运算对象是类型时，圆括号必不可少，但对于特定量，可有可无。但是建议都加圆括号；
	
4.3	【常量和C预处理器 #define】
	circumference=3.14159*diameter；	//常量3.14159代表圆周率pi(π)
	circumference=pi*diameter；		//使用符号常量能更方便、表达更多信息；
	假设程序中多出使用一个常量，有时需要变更它的值，比如经常浮动的税率。
	如果程序使用符号常量，则只需更改符号常量定义，而不用在程序中查找使用常量的地方逐一修改；
	如何创建符号常量？

	方法1：声明一个变量，然后将该变量设置为所需的常量；如
	float taxrate；
	taxrate=0.015；
	这样做就给0.015这个常量提供了一个符号名，但是taxrate是一个变量，程序可能会无意间改变它的值；
	所以C语言提供了一个更好的方案――C预处理器。
	方法2：用预处理器来定义一个常量；如
	#define TAXRATE 0.015	//格式 #define NAME value
	编译程序时，程序中所有TAXRATE都会被替换成0.015；这过程被称为“编译时替换”，这样定义的常量也称明示常量；
	符号常量名一般建议用大写名；程序中看到大写名可以立刻明白这是个符号常量，而非变量；提高可读性；
	
	#include<stdio.h>
	#define PI 3.14159
	int main(void)
	{
		float area, circum, radius;
		printf("what's the radius of your pizza?\n");
		scanf_s("%f", &radius);
		area = PI * radius*radius;
		circum = 2.0*PI*radius;
		printf("your basic pizza parameters are as follow:\n");
		printf("circumference=%.2f,area=%.2f\n", circum, area);
		getchar();
		getchar();
		return 0;
	}

	#define指令还可以定义字符和字符串常量，前者使用单引号，后者使用双引号；如
	#define BEEP '\a'
	#define TEE 'T'
	#define ESC '\033'
	#define OOPS "Now you have done it!"
	
	const限定符，用于限定一个关键量为只读。声明如下
	const int MONTHS=12；	//MONTHS在程序中不可更改，值为12

	C头文件limits.h 和 float.h 分别提供了整数类型和浮点类型大小限制相关的详细信息；
	每个头文件都定义了一系列供实现使用的符号常量；例如limits.h头文件包含以下类似代码：
	#define INT_MAX +32767
	#define INT_MIX -32768
	这些明示常量代表int类型可以表示的最大值和最小值。如果系统使用32位的int，该头文件会为这些明示常量提供不同的值。
	如果在程序中包含limits.h头文件，就可以编写下面代码：
	#include<stdio.h>
	#include<limits.h>
	int main(void)
	{
		printf("Maxmum int value on this system=%d\n", INT_MAX);
		getchar();
		return 0;
	}
	类似的float.h也定义了一些明示常量；演示如下：

	#include<stdio.h>
	#include<limits.h>//整型限制
	#include<float.h>//浮点型限制
	int main(void)
	{
		printf("some number limits for this system:\n");
		printf("Biggist int =%d\n", INT_MAX);
		printf("Smallest long long =%lld\n",LLONG_MIN);
		printf("One byte=%d bits\n",CHAR_BIT);
		printf("Largest double=%e\n",DBL_MAX);
		printf("Smallest normal float=%e\n",FLT_MIN);
		printf("float precision =%d digits\n",FLT_DIG);
		printf("float epsilon=%e\n",FLT_EPSILON);
		getchar();
		return 0;
	}


4.4.2	【printf()】

	#include<stdio.h>
	#define PI 3.141593
	int main(void)
	{
		int num = 7;
		float pies = 12.75;
		int cost = 7800;
		printf("the %d contestants are %.2f berry pies.\n",num,pies);
		printf("the value of PI is %f.\n",PI);
		printf("farewell! thou art too dear for my possessing,\n");
		printf("%c%d.\n",'$',2*cost);	//printf()函数使用的是值，无论是变量、常量还是表达式的值			
		getchar();
		return 0;
	}

	printf()函数格式
	printf(“格式字符串”，待打印项1，待打印项2……)；
	格式字符串包含两种形式：1.需要实际打印的字符；2.转换说明，数量跟待打印项相对应
	
4.4.3	printf()的转换说明修饰符

	①标记
		(-、+、空格、#和0)，可以不使用标记或者使用多个标记；示例：“%-10d”左对齐10个格位；
		-：待打印项目左对齐
		+：显示值的正负符号；值为正，在值前面显示+；若为负显示-；
		空格：若值为正，占用一空格，若值为负，显示-号；
		#：把结果转换成另一种格式；%o格式则以0开始；%x则以0x开始；
		     对于所有的浮点格式，#保证即使后面没有任何数字，也打印一个小数点字符；
		     对%g格式，#防止结果后面的0被删除；

	②数字 
		显示字段宽度，如果该字段不能容纳待打印的数字或者字符串，系统会使用更宽的字段；示例："%4d"

	③.数字
		标明精度；
		对于%e、%E和%f转换，表示小数点右边数字的位数；示例“%.2f”保留小数点后两位；
		对于%g、%G转换，表示有效数字最大位数；
		对于%s转换，表示待打印字符的最大数量；
		对于整型转换，表示待打印数字的最小位数；
		如有必要，使用前导0来达到这个位数
		只使用.表示其后跟随一个0，所以%.f和%.0f相同
	④字符：
		h：和整型转换说明一起使用，表示short int或unsigned short int类型的值；
		hh：signed char或unsigned char；
		j：intmax_t或uintmax_t；
		l：long int或 unsigned long int；
		ll：long long  或unsigned long long；
		L：long double；
		t：ptrdiff_t；
		z：size_t；

	类型可移植性：sizeof运算符以字节为单位返回类型或值的大小；系统只规定了该值为unsigned整数；
		      如果移植要查找返回值类型选择用u-int、u-long甚至u-long long
	float参数的转换：有double和long double类型的转换，printf()函数中float类型函数自动转换成double类型；	

	#include<stdio.h>
	#define PAGES 959
	int main(void)
	{
		printf("*%d*\n",PAGES);	//*959*	//不带任何修饰符，默认输出结果；
		printf("*%2d*\n", PAGES);	//*959*	//修饰符要求2字段宽度，但待打印整数有3位数字，字段扩大字段宽度；
		printf("*%10d*\n", PAGES);	//*       959*//输出10个字段宽度，7空格+3数字；
		printf("*%-10d*\n", PAGES);	//*959       *//输出10个字段宽度，7空格+3数字；-修饰符，数字左靠齐；
		getchar();
		return 0;
	}

	#include<stdio.h>
	int main(void)
	{
		const double RENT = 3852.99;	//const限定变量只读；
		printf("*%f*\n", RENT);	//*3852.990000*	//字段宽度和小数点后面的位数均为默认
		printf("*%e*\n", RENT);	//*3.852990e+03*	//指数写法；小数点左侧1位，右侧6位；
		printf("*%4.2f*\n", RENT);	//*3852.99*	//4字段宽度被扩大，小数点后两位；
		printf("*%3.1f*\n", RENT);	//*3853.0*		//3字段宽度也失效，小数点后保留1位，四舍五入；
		printf("*%10.3f*\n", RENT);	//*  3852.990*	//10字段宽度指定生效，小数点后三位；
		printf("*%10.3E*\n", RENT);	//* 3.853E+03*	//10字段宽度生效；小数点后保留三位，指数写法；
		printf("*%+4.2f*\n", RENT);	//*+3852.99*	//显示正负号；指定字段宽度失效；保留2位小数；
		printf("*%010.2f*\n", RENT);	//*0003852.99*	//指定10字段宽度，空位用0填充，小数点后保留2位；
		getchar();
		return 0;
	}
	
	#include<stdio.h>
	int main(void)
	{
		printf("%x %X %#x\n",31,31,31);		//1f 1F 0x1f
		printf("**%d**% d**% d**\n",42,42,-42);		//**42** 42**-42**
		printf("**%5d**%5.3d**%05d**%05.3d**\n",6,6,6,6);	//**    6**  006**00006**  006**
		getchar();
		return 0;
	}

	字符串输出：
	
	#include<stdio.h>
	#define BLURB "Authentic imitation!"
	int main(void)
	{
		printf("[%2s]\n", BLURB);	//指定2字段宽度，但是被扩大为可容纳所有字符字段；
		printf("[%24s]\n", BLURB);	//输出24字段宽度字符串，多余部分会显示出左边空位；
		printf("[%24.5s]\n", BLURB);	//.5精度限制输出待打印字符的个数，只输出5个字符；
		printf("[%-24.5s]\n", BLURB);	//-标记使得文本左对齐输出；
		getchar();
		return 0;
	}


4.4.4	【转换说明】
	转换说明把以二进制格式存储在计算机中的值转换成一系列字符(字符串)以便于显示；
	转换不是原始值被替换成转换后的值，而是一种翻译说明；%d的意思是把给定的值翻译成十进制整数输出；

	1.转换不匹配问题：

	①整型转换不匹配示例：
	
	#include<stdio.h>
	#define PAGES 336
	#define WORDS 65618
	int main(void)
	{
		short num=PAGES;
		short mnum=-PAGES;
		printf("num as short and unsigned short:%hd %hu\n",num,num);		//336 336
		printf("-num as short and unsigned short:%hd %hu\n",mnum,mnum);		//-336 65200
		printf("num as int and char:%d %c\n",num,num);				//336 P
		printf("WORDS as int,short,and char:%d %hd %c",WORDS,WORDS,WORDS);	//65618 82 R
		getchar();
		return 0;
	}

	第三行演示了把一个大于255的值转换成字符会发生的情况，short int是2字节；char是1字节；
	当printf()用%c打印336时候，它只查看336数字2字节中的后1字节；这种被称为截断：
	P在ASCII表中为80；   80在二进制中为 01010000；
		而336的二进制为 00000001 01010000；
	该数字被解释成“以256为摸”(modulo256),即该数字除以256后取其余数。

	②整型与浮点型混淆示例：
	
	#include<stdio.h>
	int main(void)
	{
		float n1=3.0;
		double n2=3.0;
		long n3=2000000000;
		long n4=1234567890;
		printf("%.1le %.1le %.1le %.1le\n",n1,n2,n3,n4);	//3.0e+00 3.0e+00 3.1e+46 7.1e-305
		printf("%ld %ld\n",n3,n4);			//2000000000 1234567890
		printf("%ld %ld %ld %ld\n",n1,n2,n3,n4);		//0 1074266112 0 1074266112
		getchar();
		return 0;
	}

	最后一行输出n3,n4也出错了；结果显示如果printf()语句有其他不匹配的地方，即使用对了转换说明也会出错
	问题出在C如何把信息传递给函数，即参数传递机制；

	函数调用 printf("%ld %ld %ld %ld\n",n1,n2,n3,n4);
	该调用告诉计算机把n1,n2,n3,n4的值传递给程序；这是一种常见的参数传递方式：
	程序把传入的值放入被称为“栈”(stack)的内存区域；

	计算机根据变量类型(而不是根据转换说明) 把这些值放入栈中；
		因此，n1被存储在栈中，占8字节(float类型被转换成double类型)；n2也占8字节；
		而n3和n4在栈中分别占4字节；

	然后控制转到printf()函数，
	该函数根据转换说明(而不是根据变量类型)从栈中读取值：
		%ld表明printf()应该读取4字节，所以只读取了n1的前半部分；并被解释成一个long类型整数；
		根据下一个%ld，printf()再读取4字节，读取了n1的后半部分；被解释成第二个long类型整数；
		类似的根据第三个和第四个%ld，分别读取了n2的前、后两部分，并被解释成n3，n4;

	2.printf()的返回值
	
	#include<stdio.h>
	int main(void)
	{
	int rep;
	rep=printf("hello world\n");		//输出printf()，并将这个printf()的返回值赋给rep
	printf("rep have %d characters",rep);	//输出rep返回值，hello+空格+world+\n=5+1+5+1=12字符数；
	getchar();
	return 0;
	}

	
4.4.5	【scanf()】
	printf()函数使用变量、常量和表达式；scanf()函数使用指向变量的指针；
	1.如果用scanf()读取基本变量类型的值，在变量名前加上一个&；
	2.如果用scanf()把字符串读入字符数组中，不要使用&；

	#include<stdio.h>
	#pragma warning(disable:4996)；
	int main(void)
	{
		int age;
		float assets;
		char pet[30];
		printf("Enter your age,assets,and favorite pet.\n");
		scanf("%d %f", &age, &assets);
		scanf("%s", pet);
		printf("your age : %d,\nand your assets: $%.2f,\nand your favorite pet:%s.\n", age, assets, pet);
		getchar();
		getchar();
		return 0;
	}

	【scanf_s解决办法】
	#include<stdio.h>
	int main(void)
	{
		int age;
		float assets;
		char pet[30];
		printf("Enter your age,assets,and favorite pet.\n");
		scanf_s("%d %f", &age, &assets);
		scanf_s("%s", pet,30);				/*scanf_s(,,)第三个参数的数字是限制读取边界*/
		printf("your age : %d,\nand your assets: $%.2f,\nand your favorite pet:%s.\n", age, assets, pet);
		getchar();
		getchar();
		return 0;
	}



	
	示例里面的输入三个参数，可以用回车键、tab键或者空格键来隔开；所以可以将输入在一行或者多行进行；
	其中%c是例外，scanf()会读取每个字符，包括空白。

	scanf()转换说明
	
	%c		把输入解释成字符；
	%d		把输入解释成有符号十进制整数；
	%e、%f、%g、%a	把输入解释成浮点数； 
	%E、%F、%G、%A	把输入解释成浮点数；
	%i		把输入解释成有符号十进制整数；
	%o		把输入解释成有符号八进制整数；
	%p		把输入解释成指针(地址)；
	%s		把输入解释成字符串，到下一个空白字符之前；
	%u		把输入解释成无符号十进制整数；
	%x、%X		把输入解释成有符号十六进制整数；

	scanf()如何读取输入：	
	①假设scanf()根据一个%d转化说明读取一个整数：
	scanf()函数每次读取一个字符，跳过所有空白字符，直到遇到第一个非空白字符开始读取；
	因为要读取整数，所以scanf()开始寻找一个数字字符或者一个符号(+或-)，
	如果找到一个数字或符号，便保存该字符，并读取下一个字符，如果下一个字符是数字，保存并读取下一个字符；
	scanf()不断地读取和保存字符，直到遇到非数字字符，便认为读到了整数的末尾；
	scanf()将非数字字符放回输入，这意味着下一次读取输入时，首先读到的就是这个被放回的非数字字符；
	最后scanf()计算已经读取的字符(可能还有符号)对应的数值，并将计算后的值放入指定变量中。
	
	上例中，如果第一个非空白字符是A而不是数字，scanf()将停在那里，并把A放回输入中，而不会把值赋给变量；
	如果使用字段宽度，scanf()会在字段结尾或者第一个空白字符处停止读取(满足其中之一就停止读取)

	②其他数值匹配的转换说明跟%d情况大致相同，区别在于scanf()会把更多字符识别成数字的一部分，比如十六进制A~F；
	③浮点转换说明还要求scanf()识别小数点、e记数法和新增的p计数法；
	④使用%s转换说明时，scanf()会读取除空白外所有字符；scanf()跳过空白开始读取第一个非空白字符并保存，直到下一个空白；
	⑤除了%c，其他转换说明都会自动跳过待输入值前所有空白；

	scanf()返回值
	scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0；
	当scanf()检测到"文件结尾"时，会返回EOF(EOF是stdio.h中定义的特殊值，通常#define指令把EOF定义为-1)

4.4.6	printf()和scanf()的*修饰符
	
	printf()的*修饰符：如果转换说明是%*d。那么参数列表中应包含*和d对应的值；同时也可用于浮点值指定精度和字段宽度；
	范例：
	#include<stdio.h>
	int main(void) 
	{
		unsigned width, precision;	//width:字段宽度;precision:精度;
		int number = 256;		//演示1输出项；
		double weight = 242.5;	//演示2输出项；

		printf("Enter a field width:\n");			//指定字段宽度；
		scanf_s("%d", &width);			//给字段宽度赋值；
		printf("The number is :%*d:\n",width,number);	//输出1 number；*按照指定输出字段宽度；

		printf("Now enter a width and a precision:\n");	//指定字段宽度和显示精度；
		scanf_s("%d %d",&width,&precision);		//读取宽度和精度设定；
		printf("Weight=%*.*f\n",width,precision,weight);	//输出2 weight；*.*前者字段宽度后者小数点后显示精度
		printf("Done!\n");

		getchar();
		getchar();
		return 0;
	}


	scanf()的*修饰符：把*放在%和转换字符之间，会让scanf()跳过对应的输出项；在程序需要读取文件中特定列的内容时可用上；
	范例：

	#include<stdio.h>
	int main(void)
	{
		int a,b,c;

		printf("Please enter three integers:\n");
		scanf_s("%*d %*d %d", &a,&b,&c);
		printf("The last integer was %d\n",a);

		getchar();
		getchar();
		return 0;
	}

4.4.7	printf()的用法提示
	①使用足够大的固定字段宽度让输出整齐美观；
	比如要输出三次：printf("%d %d %d\n",a,b,c,);，若用户输入不同变量，则输出可能是
	22 234 3222
	345 8 66	
	6789 224 37
	
	修改后：printf("%4d %4d %4d\n",a,b,c,);
	    22       234   3222
	  345           8      66	
	6789        224      37

	②如果要在文字中嵌入一个数字，通常指定一个小于或等于该数字宽度的字段会比较方便；
	如嵌入一个10.22
	printf("Count Jack ran %.2f miles in 3 hours.\n",distance);
	Count Jack ran 10.22 miles in 3 hours.
	若转换说明为printf("Count Jack ran %8.2f miles in 3 hours.\n",distance);
	Count Jack ran         10.22 miles in 3 hours.

4.7 	练习
	1.编写一个程序，提示用户输入名和姓，然后以“名，姓”的格式打印出来
	#include<stdio.h>
	int main(void)
	{
		char name1[40], name2[40];
		printf("Please enter your first name.\n");
		scanf_s("%s", name1, 40);
		printf("please enter your family name.\n");
		scanf_s("%s", name2, 40);
		printf("so your neme is %s,%s.", name1, name2);
		getchar();
		getchar();
		return 0;
	}
	
	2.编写一个程序，提示用户输入名和姓，并执行以下操作：
	a,打印名和姓，包括双引号；
	b.在宽度为20的字段右端打印名和姓，包括双引号；c.换字段左端；
	d.在比姓名宽度宽3的字段中打印名和姓。

	#include<stdio.h>
	int main(void)
	{
		char name1[40], name2[40];
		int a, b,c;

		printf("Please enter your first name.\n");
		scanf_s("%s", name1, 40);
		printf("please enter your family name.\n");
		scanf_s("%s", name2, 40);
		a = strlen(name2);
		a = 20 - a - 1;
		b = strlen(name1);
		b = -(20 - b - 1);
		c = strlen(name1)+ 3;

		printf("so your neme is \"%s.%s\"\n", name1, name2);
		printf("so your neme is \"%*s.%s\"\n", a, name1, name2);
		printf("so your neme is \"%s.%*s\"\n", name1, b, name2);
		printf("so your neme is \"%*s.%s\"\n", c,name1,name2);
		getchar();
		getchar();
		return 0;
	}

	3.编写一个程序，读取一个浮点数，首先以小数点记数法打印，然后以指数记数法打印。
	用下面的格式进行输出：
	a. 输入21.3或者2.1e+001；
	b.输入21.290或2.129E+001;
	#include<stdio.h>
	int main(void) 
	{
		float a;
		scanf_s("%f", &a);
		printf("%f\n", a);
		printf("%e", a);
		getchar();
		getchar();
		return 0;
	}

	4.编写一个程序，提示用户输入身高和姓名，然后以下面的格式显示用户输入信息：

	Dabney, you are 6.208 feet tall
	使用float类型，并用/作为除号，要求用户以mm为单位输入身高以米输出

	#include<stdio.h>
	#include<Windows.h>
	int main(void) 
	{
		float height;
		float feettall;	
		char firstname[40];
		char familyname[40];	

		printf("Pleast enter your height in feet\n");
		scanf_s("%f", &feettall);
		printf("Pleast enter your height in mm\n");
		scanf_s("%f", &height);
	
		printf("Pleast enter your first name\n");
		scanf_s("%s", firstname,40);
		printf("Pleast enter your family name\n");
		scanf_s("%s", familyname,40);	
	
		system("cls");
		printf("%s.%s, you are %.3f feet tall\n",firstname,familyname,feettall);
		printf("you are %.3f meters tall.", height/1000);

		getchar();
		getchar();
		return 0;
	}

	5.编写一个程序，提示用户输入以兆位每秒(Mb/s)为单位的下载速度和以兆字节(MB)为单位的文件大小；
	程序中应计算文件的下载时间，1字节等于8位，使用float，并用/作除号；
	要以下面格式打印三个变量的值，显示小数点后面两位数字：
	At 18.12 megabits per second,a file of 2.20 megabytes downloads in 0.97 seconds.

	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		float speed, file;

		printf("Please enter your download speed by Mb/s\n");
		scanf_s("%f", &speed);
		printf("Please enter your download file megabntes\n");
		scanf_s("%f", &file);
	
		system("cls");
		printf("At %.2f megabits per second,a file of %.2f megabytes downloads in %.2f seconds.", speed, file,file*8/speed);
		getchar();
		getchar();
		return 0;
	}
	
	6.编写一个程序，先提示用户输入名，然后输入姓。在一行打印输入的名和姓，再下一行分别打印名和姓的字母数；
	字母数要和相对应的名和姓结尾对齐，如下所示：
	Melissa Honeybee
	         7               8
	换字母开头对齐：
	Melissa Honeybee
	7           8
	
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		char firstname[40],familyname[40];
		int a, b;

		printf("Please enter your first name.\n");
		scanf_s("%s", firstname, 40);
		a = strlen(firstname);
		printf("Please enter your family name.\n");
		scanf_s("%s", familyname, 40);
		b = strlen(familyname);
	
		system("cls");
		printf("%s %s\n%*d %*d\n", firstname, familyname,a,a,b,b);
		printf("%s %s\n%-*d %-*d\n", firstname, familyname, a, a, b, b);
		getchar();
		getchar();
		return 0;
	}

	//关于输入姓名超出给定范围或者格式，如何删除冗余输入不影响后续的暂行办法，如下如果name[4]就没法解决超出3字节问题；
	#include<stdio.h>
	#pragma   warning(disable:4996)
	int main(void)
	{
		char name[40];
		int age,a,i;
		printf("please enter your name.\n");
		scanf_s("%s", name, 40);

		//for (a = 0; a < 4; a++) { name[a] = getchar(); }
		//fflush(stdin);
		setbuf(stdin, NULL);
		//while ((name[4] = getchar()) != EOF && name[4] != '\n');
		i = strlen(name);
		printf("your name have %d byte\n\n", i);

		printf("please enter your age.\n");
		scanf_s("%d", &age);

		printf("\nwell,%s,you are %d years old.\n", name, age);

		getchar();
		getchar();
		return 0;
	}

	7.编写一个程序，将一个double类型的变量设置为1.0/3.0，将一个float类型的变量设置为1.0/3.0；
	分别显示两次计算的结果各3次：
	一次显示小数点后面6位数字；一次显示小数点后12位数字；一次显示小数点后16位数字；
	程序中要包含float头文件，并显示FLT_DIG和DBL_DIG的值；
	1.0/3.0的值与这些值一致吗？
	
	#include<stdio.h>
	#include<float.h>
	int main(void) 
	{
		double a;
		float b;
		a = 1.0 / 3.0;
		b = 1.0 / 3.0;
		printf("%.6f\n%.12f\n%.16f\n", a, a, a);
		printf("%.6f\n%.12f\n%.16f\n", b, b, b);
		printf("%d\n%d", FLT_DIG, DBL_DIG);
		getchar();
		return 0;
	}


	8.编写一个程序，提示用户输入旅行的里程和消耗的汽油量，然后计算并显示消耗每加仑汽油行驶的英里数，保留一位小数；
	1加仑约3.785升；1英里约1.609千米；将单位是英里/加仑的值转换为升/100公里并显示结果，保留一位小数点；
	注：美国采用的方案测量消耗单位燃料的里程值，而欧洲采用单位距离消耗的燃料测量方案；
	使用#define创建符号常量或使用const限定符创建变量来表示两个转换系数；
	
	#include<stdio.h>
	#define c 100*3.785/1.609
	int main(void)
	{
		float a, b;
	
		printf("Please enter your mileage:\n");
		scanf_s("%f", &a);
		printf("Please enter your fuel consumed in gallon:\n");
		scanf_s("%f", &b);
	
		printf("your comprehensive oil consumption is:\n");
		printf("MPG:%.1f \n", a/b);
		printf("%.1f L/100KM", c*b/a );
		getchar(); 
		getchar();
		return 0;
	}


【第五章】运算符、表达式和语句

	
5.1 	循环

	数据对象：用于储存值的数据存储区域；
	左值：用于标明特定数据对象的名称或表达式；对象定位值；
	右值：能赋值给可修改左值的量，且本身不是左值；
	运算符：基本运算符=+-*/
	
5.2.1 	赋值运算符=
	
	#include<stdio.h>
	int main(void)
	 {
		int jane, tarzan, cheeta;
		cheeta = tarzan = jane = 68; //三重赋值；
		printf("cheeta    tarzan    jane\n");
		printf("%4d %8d %8d\n", cheeta, tarzan, jane);
		getchar();
		return 0;
	}	

	赋值顺序从右往左，首先把86赋值给jane,然后再赋值给tarzan；最后赋值给cheeta；

5.2.2	加法运算符+
	printf("%d",4+20);打印的是24而不是表达式4+20；
	相加的对象可以是变量也可以是常量；
	
5.2.3	减法运算符-
	takehome=224-24;
	+和-运算都被成为二元运算符，即这些运算符需要两个运算对象才能完成操作；

5.2.4	符号运算符-和+
	减号还可以用于标明或改变一个值的代数符号如
	rocky=-12；
	smokey=-rocky；
	smokey最后的值为12；
	
	二元：36-12 值为24
	一元：-16	   值为-16
	二者兼有：-（12-20） 值为8

5.2.5	乘法运算符*
	例：C没有平方函数，如果需要打印一个平方表，则：
	/*squares.c――计算1-20的平方*/
	#include<stdio.h>
	int main(void)
	{
		int num;
		num = 1;
		while (num < 21) 
		{
			printf("%d*%d=%d\n", num, num, num*num);
			num = num + 1;
		}
		getchar();
		return 0;
	}
	
	1.指数增长：
	棋盘上的米粒：第一格放1粒，第二格放2粒，第三格放4粒，第四格放8粒；
	以此类推，放满64个格子数；
	/*指数增长，让程序计算出每个格子放多少，并计算总数*/
	#include<stdio.h>
	int main(void)
	{
		int a;
		double b,c;
		a = 1;	//格子数
		b = 1.0;	//格子上米粒数
		c = 1.0;	//总米粒数
		printf("格子数	米粒数		总数\n");
		while(a<65)
		{				
			printf("%d:	%.2e	%.2e\n",a, b,c);	
			b = 2 * b;		
			a = a + 1;		
			c = c + b;		
		}
		getchar();
		return 0;
	}

	改进：制作一个指数函数查看表1；
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		int count,num;
		double result;
		count = 1;	
		result = 1.0;
		printf("please enter the number as the powerof 2\n");
		scanf_s("%d", &num);
		while (count < num+1)
		{
			count = count + 1;		
			result = 2 * result;
		}
		system("cls");
		printf("the %d power of 2 is %.2e\n", num, result);	
		getchar();
		getchar();
		return 0;
	}
	
	改进：制作一个指数函数查看表2；
	#include<stdio.h>
	int main(void)
	{
		int count,n,num;
		double result;
		count = 1;	
		n = 0;
		result = 1.0;
		printf("please enter the number as the powerof 2\n");
		scanf_s("%d", &num);

		printf("n.	result\n");
		while (count < num+2)
		{		
			printf("%d	%.2e\n", n, result);
			count = count + 1;		
			result = 2 * result;
			n = count - 1;		
		}	
		getchar();
		getchar();
		return 0;
	}
	
5.2.6	除法运算符/
	整数除法和浮点数除法不同，浮点数除法的结果是浮点数，而整数除法的结果是整数，没有小数部分；
	所以整数除法使得5/3这样的情况，实际结果有小数部分，但是被丢弃，这过程称为截断；
	#include<stdio.h>
	int main(void)
	{
		printf("int division: 5/4 is %d\n", 5 / 4);		//1
		printf("int division: 8/4 is %d\n", 8 / 4);		//2
		printf("int division: 7/4 is %d\n", 7 / 4);		//1，截断为丢弃整个小数部分，不会四舍五入；
		printf("float division: 7.0/4.0 is %.2f\n", 7.0 / 4.0);	//1.75
		printf("mixed division: 7.0/4 is %.2f\n", 7.0 / 4);	//1.75，尽量避免此类；4会被先转化成4.0
		getchar();
		return 0;
	}

5.2.7	运算符优先级：

	（）	从左往右
	+ -(一元)	从右往左(正负)
	* /	从左往右
	+ -(二元)	从左往右(加减)
	=	从右往左

5.3	其他运算符：
	
5.3.1	sizeof运算符和size_t类型
	#include<stdio.h>
	int main(void)
	{
		int n = 0;
		size_t intsize;	
		intsize = sizeof(int);	
		printf("n=%d,n has %u bytes;all ints have %u bytes.\n", n, sizeof n, intsize);
		getchar();
		return 0;
	}

5.3.2	求模运算符%
	用于整数运算，给出左侧整数除以右侧整数后的余数；
	13%5的结果为3；

	#include<stdio.h>
	#define SEC_PER_MIN 60
	int main(void)
	{
		int sec, min, left;

		printf("Convert seconds to minutes and secods!\n");
		printf("Enter the number of seconds(<=0 to quit):\n");
		scanf_s("%d", &sec);
		while(sec>0)
		{
			min = sec / SEC_PER_MIN;//截断分钟数；
			left = sec % SEC_PER_MIN;//剩下的秒数；
			printf("%d seconds is %d minutes, %d seconds.\n", sec, min, left);
			printf("Enter next value(<=0 to quit):\n");
			scanf_s("%d", &sec);
		}
		printf("Done!\n");
		getchar();
		getchar();
		return 0;
	}
	
	关于负数求模；
	11/5 得2	11%5得1
	11/-5得-2	11%-2得1
	-11/-5得2	-11%-5得-1
	-11/5得-2	-11%-2得-1
	综上：
	如果第一个运算对象是负数，那么结果就为负数；
	如果第一个运算对象为正数，那么求模结果也是正数；	

	实际上，只要a和b是整数，便可通过 a-(a/b)*b来计算；

	例如：-11%5：
	  -11-（-11/5）*5
	=-11-（-2）*5
	=-11-（-10）
	=-1


5.3.3	递增运算符++
	执行简单的任务，将其运算对象递增1；分为：
	1.前缀模式		 a++
	2.后缀模式		 ++a
	
	【前后缀相似之处】

	#include<stdio.h>
	int main(void) 
	{
		int ultra = 0, super = 0;
		while (super < 5)
		{
			super++;
			++ultra;
			printf("super=%d, ultra=%d\n", super, ultra);
		}
		getchar();
		return 0;
	}

	程序输出：
	super=1, ultra=1
	super=2, ultra=2
	super=3, ultra=3
	super=4, ultra=4
	super=5, ultra=5

	#include<stdio.h>
	int main(void) 
	{
		int ultra = 0, super = 0;
		while (super++ < 5)//super=0<5,super+1=0+1=1;执行循环,
		{
			++ultra;//ultra=1；使用ultra之前先递增ultra;
			printf("super=%d,ultra=%d\n", super, ultra);
		}	
		getchar();
		return 0;
	}

	【前后缀区别】
	#include<stdio.h>
	int main(void) 
	{
		int a=1,b=1;
		int a_post, pre_b;
		a_post = a++;	//后缀，使用a值之后，递增a
		pre_b = ++b;	//前缀，使用b值之前，递增b
		printf("a	a_post	b	pre_b\n");
		printf("%d	%5d	%5d	%5d\n", a, a_post, b, pre_b);	
		getchar();
		return 0;
	}

	结果为a=2,a_post=1,b=2,pre_b=2


	前缀形式：
	q=2*++a;		首先，a递增1；然后2乘以a并将结果给q；
	后缀形式；
	q=2*a++;		首先，2乘以a并将结果给q；然后，a递增1；

5.3.4	递减运算符--（与++同；略）
	
5.3.5	优先级
	递增递减运算符都有很高的优先级，只有圆括号优先级高于它们；
	因此，x*y++表示是(x)*(y++),而不是(x*y)(++),而且后者无效，递增和递减运算符只能影响一个变量；
	如果n++是表达式的一部分，可以视其为 先使用n，再递增；
	而++n则表示 先递增n，在使用；

5.3.6	如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增递减；
	如果一个变量多次出现在一个表达式中，不要对该变量使用递增递减

5.4	表达式和语句

5.4.1	表达式
	表达式由运算符和运算对象组成，最简单的表达式是一个单独的运算对象，一些表达式由子表达式组成；
	每个表达式都有一个值；

5.4.2	语句	
	一条语句相当于一条完整的计算机指令，大部分语句都以分号结尾；因此：
	legs=4 	只是一个表达式
	legs=4;	则是一条语句
	最简单的语句是空语句
	；//空语句
	C把末尾加上一个分号的表达式都看作是一条语句，即表达式语句
	8；
	3+4；
	但是这些语句在程序中什么也不做，不算是正真有用的语句
	确切的说，语句可以改变值或者调用函数：
	x=25;
	++x;
	y=sqrt(x);
	虽然一条语句相当于一条完整的指令，但并不是所有的指令都是语句，比如：
	x=6+(y=5);
	其中y=5是一条完整的指令，但是它只是语句的一部分，用分号识别这种情况下的语句；

	#include<stdio.h>
	int main(void) 
	{
		int count, sum;		//声明；
		count = 0;			//表达式语句
		sum = 0;			//表达式语句
		while (count++ < 20)
			{sum= sum + count;	}	//迭代语句	
		printf("sum=%d\n", sum);		//表达式语句
		return 0;			//跳转语句
	}
	
	声明创建了名称和类型，并分配内存位置，但声明不是表达式语句，如删分号，剩下也不是表达式，没有值；
	赋值表达式语句：一个变量名，后面是一个赋值运算符，再跟一个表达式，最后分号结尾；
	函数表达式语句会引起函数调用；在上例中，调用printf()函数打印结果。
	while()语句有3部分组成，首先是关键字while，圆括号内为待测试条件；如果条件为真，则执行while循环里的语句；
	while语句是一种迭代语句，也称为结构化语句；

	【副作用和序列点】

	副作用：是对数据对象或文件的修改；例如
	a=50;
	它的副作用是将变量的值设置为50；
	类似的，调用printf()函数时，它显示的信息其实是副作用(printf()的返回值是待显示字符的个数)；

	序列点：是程序的执行点，在该点上，所有的副作用都在进入下一步之前发生；
	在C中，语句中的分号标记了一个序列点，
	意思是在该语句中，赋值、递增、递减对运算对象的改变必须在程序执行下一条语句前完成；
	任何一个完整表达式的结束也是一个序列点。
	完整表达式：就是指这个表达式不是另一个更大表达式的子表达式；例如：
	表达式语句中的表达式；while循环中的测试条件表达式；

	序列点有助于分析后缀递增何时发生，例如：
	
	while(a++<10) 
		printf("a=%d\n",a);

	举例，a=5；
	该例子中，如果按照“先使用值，再递增”的后缀意思，会先printf()输出guests的值,再递增它；
	显示数字 a=5;然后a递增变成6；
	但是，表达式guests++<10是一个完整的表达式；是while循环的测试条件；所以该表达式的结束就是一个序列点；
	所以保证在执行printf()之前，发生副作用；a递增a=6;printf()输出%d调用a的值为6；
	同时，使用后缀递增保证了a在完成与10的比较后才进行递增，即a=5<10成立，输出6这个动作得以执行；

5.4.3	复合语句(块)
	
	复合语句是用花括号括起来的一条或多条语句，也成为块block；
	
	/*程序段1*/

	a=0;
	while(a++<10)
		 {b=10*a+2;}
	printf("b=%d",b);
	
	/*程序段2*/

	a=0;
	while(a++<10)
	 {
		b=10*a+2; 
		printf("b=%d",b);
	}

	程序段1，while循环只有一条赋值表达语句，while这行运行至下一个分号；循环结束后printf()只会被调用一次；
	程序段2，花括号确保两条语句都是while循环的一部分，每执行一次循环都调用一次printf()函数；

	风格提示：循环中的缩进，对编译器不起作用，编译器通过花括号和while循环的结构来识别和解释指令；
	这里的缩进是为了让使用者可以一眼看出程序是如何组织的；使用缩进和花括号的位置可以进一步提高可读性；

5.5	类型转换
	通常，在语句和表达式中应使用类型相同的变量和常量；
	但是如果使用混合类型，C虽然会采用一套规则自动转化类型，但是有一定的危险性；
	1.当类型转换出线在表达式时，无论是unsigned还是signed的char和short都会被自动转为int；
	  如有必要会被转换成unsigned int（若short与int大小相同，unsigned short就比int大）；
	  这种情况下，unsigned short会被转成unsigned int；
	由于都是从较小型转换为较大类型，所以这些转换被称为升级promotion；
	
	2.涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别；
	3.类型的级别从高至低：long double>double>float>unsignedlong long>long long>unsigned long>
			long>unsigned int>int>
	  例外：当long和int大小相同时，unsigned int 比long 的级别高，short和char均被升级到int或者unsigned int；
	4.在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型；这结果可能导致升级或降级；
	5.当作为函数参数传递时，char和short被转换成int，float被转换成double，函数原型会覆盖自动升级；
	类型升级通常都不会有什么问题，但是类型降级会导致正真的麻烦，可能会溢出；
	
	待转换的值与目标类型不匹配，涉及类型转换时：
	①目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略；
		例如目标类型是8位unsigned char，待赋的值是原始值求模256；
	②如果目标类型是一个符号整型，且待赋的值是整数，结果因实现而异；
	③如果目标类型是一个整型，且待赋的值是浮点数，该行为未定义；
	④如果把浮点数换成整数，原来的浮点值会被截断；
	下面的程序演示了这些转换规则；
	
	#include<stdio.h>
	int main(void)
	{
		char ch;
		int i;
		float fl;

		fl = i = ch = 'C';
		printf("ch=%c,i=%d,fl=%2.2f\n", ch, i, fl);
		ch = ch + 1;
		i = fl + 2 * ch;
		fl = 2.0*ch + i;
		printf("ch=%c,i=%d,fl=%2.2f\n", ch, i, fl);
		ch = 1107;
		printf("Now ch=%c\n", ch);
		ch = 80.89;
		printf("Now ch=%c\n", ch);
		getchar();
		return 0;
	}
	
5.5.1	强制类型转换运算符 cast
	在某个变量的前面放置用圆括号括起来的类项名，该类型名是希望转换成的目标类型；通用形式是 (type)
	用实际需要的类型替换(如long)替换type即可；例：
	int mice;
	mice=1.6+1.7；		//1.6+1.7=3.3,截断为int，结果为3；
	mice=（int）1.6+(int)1.7;	//1.6和1.7都被强制转换成int，截断后结果1+1=2；
	
总结
	赋值运算符：
	=	将右侧的值赋给左侧变量；如：a=2;
	算数运算符：
	+	将其左侧的值与右侧的相加；如：1+2=3;
	-	将其左侧的值减去右侧的值；如：3-2=1;
	-	作为一元运算符，改变其右侧值的符号；如：-1;
	*	将其左侧的值乘以右侧的值；如：2*3=6;
	/	将其左侧的值除以右侧的值；若都是整数，计算结果被截断；如：3/2=1;
	%	将其左侧的值除以右侧的值，取其余数(限整数)；如：16%5=1;	
	++	对其右侧的值加1(++a);对其左侧的值加1(a++);
	--	对其右侧的值减1(--a);  对其左侧的值减1(a--);
	其他运算符：
	sizeof	获得其右侧运算对象的大小(字节)，运算对象可以是类型说明符(sizeof(int))或者变量sizeof a;
	(type)	强制类型转换运算符，将其右侧的值转成圆括号内指定的类型；(float)9=9.0;

5.6	带参数的函数
	
	#include<stdio.h>
	void pound(int n);//ANSI函数原型声明
	int main(void)
	{
		int times = 5;
		char ch = '!';//ASCII码=33
		float f = 6.0f;

		pound(times);//int类型的参数
		pound(ch);//pound((int)ch);
		pound(f);//pound((int)f)
		getchar();
		return 0;
	}
	void pound(int n)//ANSI风格函数头
	{
		while (n-- > 0) { printf("#"); }
		printf("\n");	
	}

	其中，函数头：
	void pound(int n);
	如果函数不接受任何参数，函数头的圆括号中应该写上关键字void
	由于该函数接受一个类型的参数，所以圆括号中包含一个int类型变量n的声明；
	声明参数就创建了一个形式参数（形参）；pound(10)就是把10的值赋给n；n是形参
	我们称函数调用传递的值为实际参数（实参）；10就是实际参数；
	所以pound(time)把实际参数time的值5传递给函数pound(int n)，然后函数把5赋值给形式参数(变量n);
	
	(可以理解为形参是没有分配内存的，传入实际参数才分配内存，运行之后被释放了，所以n不会存数，
	下一次传实参进去又分配内存给它继续执行；）
	
	看上面例子的函数调用过程：
	第一个函数调用的是pound(time)，time的值5被赋给n，因此printf()函数打印了5个#和一个换行符；
	第二个函数调用的是pound(ch)，ch是char类型，被初始化为！字符，在ASCII中ch的值是33。但是pound()函数
	的参数类型是int，与char不匹配，程序开头的函数原型声明发挥了作用，描述了函数的返回值和参数：
	①该函数没有返回值(函数名前面有void关键字)；
	②该函数有一个int类型的参数ponud（int n）；//pound(type n);
	该例中，函数原型告诉编译器pound()需要一个int类型的参数，于是当编译器执行到pound(ch)时，把ch转成int类型；
	同理，pound(f)也让float类型的变量被自带转换成int类型；
	
	
5.7	总结
	用一个程序来涵盖本章内容：
	
	#include<stdio.h>
	const int S_PER_M = 60;		//每分钟的秒数；
	const int S_PER_H = 3600;	//每小时的秒数；
	const double M_PER_K = 0.62137;//1公里转换的英里数；
	int main(void)
	{
		double distk, distm;//距离数k-公里；m-英里；
		double rate;//平均速度（英里/小时）；
		int min, sec;//分；秒；
		int time;
		double mtime;//跑1英里需要的时间（秒）；
		int mmin, msec;//跑1英里需要的时间，以分钟秒钟为单位；

		printf("this programe bonverts your time for a metric race\n");
		printf("to a time for running a mile and to your average\n");
		printf("speed in miles per hour.\n");
		printf("Please enter,in kilometers,the distance run.\n");
		scanf_s("%lf", &distk);//%lf读取一个double类型值；

		printf("Next enter the time in minutes and seconds.\n");
		printf("Begin by entering the minutes.\n");
		scanf_s("%d", &min);	
		printf("Now enter the seconds.\n");
		scanf_s("%d", &sec);

		time = S_PER_M * min + sec;//把时间转换成秒；
		distm = M_PER_K * distk;//把公里转换成英里；
		rate = distm / time * S_PER_H;//英里/秒*秒/小时=英里/小时；
		mtime = (double)time / distm;//时间/距离=跑1英里所用的时间（秒）；
		mmin = (int)mtime / S_PER_M;//求出分钟数；截断；
		msec = (int)mtime%S_PER_M;//求出余下的秒数；

		printf("You ran %1.2f km (%1.2f miles)in %d min,%d sec.\n", distk, distm, min, sec);
		printf("That pace corresponds to running a mile in %d min,%d sec.\n", mmin, msec);
		printf("Your average speed was %1.2f mph.\n", rate);

		getchar();
		getchar();	
		return 0;
	}

5.10 	复习题
	
	1.假设所有变量类型都是int，下列各项变量的值是多少；
	x=(2+3)*6;	//x=30;
	x=(12+6)/2*3;	//y=27;
	y=x=(2+3)/4;	//x=1;y=1;
	y=3+2*(x=7/2);	//x=3;y=9;
	x=(int)3.8+3.3;	//x=6;
	x=(2+3)*10.5;	//x=52;
	x=3/5*22.0;	//x=0;
	x=22.0*3/5;	//x=13;

	3.对下列各表达式求值；
	30.0/4.0*5.0；	//37.5
	30.0/(4.0*5.0);	//1.5
	30/4*5;		//35
	30*5/4;		//37
	30/4.0*5;		//37.5
	30/4*5.0;		//35.0
	
	6.下面的程序将输出什么：
	#include<stdio.h>
	#define FORMAT "%s! C is cool!\n"
	int main(void)
	{
		int num = 10;
		printf(FORMAT, FORMAT);	//printf("%s! C is cool!\n","%s! C is cool!\n");
		printf("%d\n", ++num);	//++num 先递增num=11 再输出11；结果输出11；
		printf("%d\n", num++);	//num++ 先使用num=11 printf()输出11；再递增num=12; 
		printf("%d\n", num--);	//num--   先使用num=12 printf()输出12；再递减num=11;
		printf("%d\n", num);		//num=11;直接输出；
		getchar();
		return 0;
	}

	7.下面的程序将输出什么：
	#include<stdio.h>
	int main(void)
	{
		char c1, c2;
		int diff;
		float num;
		c1 = 'S';		//ASCII码83
		c2 = 'O';		//ASCII码79
		diff = c1 - c2;	//diff=83-79=4；
		num = diff;	//num=4.0;
		printf("%c%c%c:%d %3.2f\n", c1, c2, c1, diff, num);
		// SOS:4 4.00
		getchar();
		return 0;
	}

	8.下面的程序将输出什么：
	#include<stdio.h>
	#define TEN 10
	int main(void)
	{
		int n = 0;
		while (n++ < TEN)		//n++;先使用再递增，0<10,n=1
			printf("%5d", n);	//输出    1继续循环；输出1~10每个数字前面带4空格；
		printf("\n");		//回车
		getchar();
		return 0;
	}
	
	修改上面的程序使其可以打印字母a~g; (ASCII码，a对应97，g=103)；

	#include<stdio.h>
	#define TEN 103
	int main(void)
	{
		char n = 96;
		while (n++ < TEN) { printf("%5c", n); }
		printf("\n");
		getchar();
		return 0;
	}
	
	或者;
	
	#include<stdio.h>	
	int main(void)
	{
		char ch = 'a';
		while (ch <= 'g') { printf("%5c", ch++); }
		printf("\n");
		getchar();
		return 0;
	}
	
	10.假设下面是完整程序中的一部分，它们分别输出什么：
	①
	int x=0;
	while(++x<3);		//++x,先递增x=1,1<3成立
		printf("%4d",x);	//输出    1    2
	
		
	②
	int x=100;
	while(x++<103)		//x++,先使用100<103成立；再递增x=101
		printf("%4d\n",x);	//输出  101回车 102回车 103回车
		printf("%4d\n",x);	//输出  104回车
	分析组后一行为什么会输出104
	#include<stdio.h>	
	int main(void)
	{
		int x = 100;
		while (x++ < 103)		//x++,先使用x=100<103成立；再递增x=101
			printf("%4d\n", x);	//输出  101回车 ，继续循环
		/*
		即:x=100,x<103成立；递增后：x=101；执行printf()输出 101；
		    x=101,x<103成立；递增后：x=102；执行printf()输出 102；
		    x=102,x<103成立；递增后：x=103；执行printf()输出 103；
		    x=103,x<103不成立；
		因为while()循环条件是个完整表达式，序列点在此处；副作用产生，x递增实现，x=104
		序列点：程序执行的点，在该点上，所有的副作用都在进行下一步之前发生。
		知识点：任何一个完整的表达式的结束也是一个序列点；
		*/
		printf("%4d\n", x);		//输出104
		getchar();
		return 0;
	}




	③
	char ch='s';
	while(ch<'w')		
	{
		printf("%c",ch);	//stuv
		ch++;
	}
	printf("%c\n",ch);		//w回车

	
	11.下面的程序会输出什么：
	
	#define MESG "COMPUTER BYTES DOG"
	#include<stdio.h>
	int main(void)
	{
		int n=0;
		while(n<5)
			printf("%s\n",MESG);		//n=0;循环只输出MESG一次；
			n++;			//n++不在循环内；
		printf("That's all.\n");			//输出That's all.回车；
		return 0;
	}


	12.分别编写一条语句，完成下面各任务（使其具有副作用）：
	①将变量x的值增加10；
		x=x+10;
	②将变量x的值增加1；
		x=x+1;
	③将a与b之和的两倍赋给c；
		c=2*(a+b);
	④将a与b的两倍之和赋给c；
		c=2*a+2*b;
	⑤将变量x的值减少1；
		x=x-1;
	⑥将n除以k的余数赋值给m；
		m=n%k;
	⑦q除以b减去a，并将结果赋给p；
		p=q/b-a;
	⑧a与b之和除以c与d的乘积，并将结果赋值给x；
		x=(a+b)/(c*d);

5.11	编程练习
	
	1.编写一个程序，用分钟表示的时间转换成用小时和分钟表示的时间。
	使用#define或const创建一个表示60的符号常量或const变量；
	通过while循环让用户重复输入值，小于等于0时停止循环；	
	#include<stdio.h>
	#include<Windows.h>
	#define M_PER_H 60
	int main(void)
	{
		int time,min, hour;
		time = 1;	
		while (time > 0)
		{
			printf("This program convert time format:MIN to HOUR_MIN.\n");
			printf("Please enter the time used by minutes.\n");
			scanf_s("%d", &time);	
			hour = time / M_PER_H;
			min = time % M_PER_H;
			printf("%d minutes = %d hours and %d minutes.\n\n", time, hour, min);	
			printf("(program continues until you enter 0.)\n");
			Sleep(2000);
			system("cls");
		}		
		getchar();
		return 0;
	}

	2.编写一个程序，提示用户输入一个整数，然后打印从该数到比该数大10的所有整数，如5，5~15；
	要求打印的各值之间用一个空格、制表符或者换行符分开；
	#include<stdio.h>
	int main(void) 
	{
		int a,c;
		printf("Please enter a num.\n");
		scanf_s("%d", &a);
		c =1;
		while (c++<12)printf("%d\n", a++);				
		getchar();
		getchar();
		return 0;
	}

	
	3.编写一个程序，提示用户输入天数，然后将其转换成周数和天数；（略）
	4.编写一个程序提示用户输入身高(厘米)，并分别以厘米和英寸为单位显示；允许有小数部分；
	该程序应该能让用户重复输入身高，直到用户输入一个非正值；示例输出如下：
	Enter a height in centimeters: 182
	182.0 cm = 5 feet, 11.7 inches
	Enter a height in centimeters(<=0 to quit): 168.7
	168.7 cm = 5 feet, 6.4 inches
	Enter a height in centimeters(<=0 to quit): 0
	bye
	
	#include<stdio.h>
	#define IN_PER_CM 0.3937
	#define IN_PER_FT 12
	int main(void) 
	{
		float cm,height, inch;
		int foot;		
		printf("Enter a height in centimeters:");
		scanf_s("%f",&cm);	
		while(cm>0)
		{
			height = cm * IN_PER_CM;
			foot = (int)height / IN_PER_FT;
			inch = height - foot * IN_PER_FT;
			printf("%.1f cm = %d feet,%.1f inches\n", cm, foot, inch);
			printf("Enter a height in centimeters(<=0 to quit):");
			scanf_s("%f", &cm);		
		}
		printf("bye\n");
		getchar();
		getchar();
		return 0;
	}
	
	5.编写一个程序使其可以与用户交互，根据用户输入的数进行计算：
	假设第1天赚$1,第2天赚$2，第3天赚$3，以此类推……
	
	#include<stdio.h>
	int main(void)
	{
		int days,date,wealth;
		wealth = 0;	
		printf("Suppose you make $1 on the first day,the next day $2,and the third day $3…\n");
		printf("Please enter the number of days you want to calculate:");
		scanf_s("%d", &days);
		date = days;
		while (days>0) 
		{		
			wealth = wealth + days;
			days--;
		}
		printf("So,you made $%d in %d days.\n", wealth,date);
		getchar();
		getchar();
		return 0;
	}

	
	6.修改上一题，使其能计算整数的平方和；
	即第1天赚$1，第2天赚$4，第三天赚$9……
	//wealth = wealth + days;改成wealth = wealth + days*days;即可

	7.编写一个程序，提示用户输入一个double类型的数，并打印该数的立方值。
	自己设计一个函数计算并打印立方值，main()函数要把用户输入的值传递给该函数。

	#include<stdio.h>
	double cubic(double);
	int main(void)
	{
		double x;
		printf("This program will calculate cubic number.\n");
		printf("Enter the number:");
		scanf_s("%lf", &x);
		printf("%lf*%lf*%lf=%lf\n", x, x, x, cubic(x));
		getchar();
		getchar();
		return 0;
	}
	double cubic(double x)
	{
		return x*x*x;
	}

	8.编写一个程序，显示求模运算的结果。把用户输入的第一个整数作为求模运算符的第二个运算对象；
	该数在运算过程中保持不变；用户后面输入的数是第一个运算对象。当输入一个非正值程序结束。
	示例如下：
	
	This progran computes moduli.
	Enter an integer to sever as the second operand:256
	Now enter the first operand: 438
	438 % 256 is 182
	Enter next number for first operand(<=0 to quit):1234567
	1234567 % 256 is 135
	Enter next number for first operand(<=0 to quit):0
	Done

	
	#include<stdio.h>
	int main(void)
	{
		int a, b;
		printf("This progran computes moduli.\n");
		printf("Enter an integer to sever as the second operand:");
		scanf_s("%d", &b);
		printf("Now enter the first operand:");
		scanf_s("%d", &a);
		while(a>0)
		{
			printf("%d %% %d is %d\n", a, b, a%b);
			printf("Enter next number for first operand(<=0 to quit):");
			scanf_s("%d", &a);
		}
		printf("Done");
		getchar();
		getchar();	
		return 0;
	}

	
	9.编写一个程序，要求用户输入一个华氏温度。程序应读取double类型的值作为温度值，并把该值作为参数
	传递给一个用户自定义的函数Temperatures()。该函数计算摄氏温度和开式温度，并以小数点后两位数字的
	精度显示三种温度。要使用不同的温标来显示这三个温度值。
	摄氏温度=5.0/9.0*（华氏温度-32.0）
	开式温度=摄氏温度+273.16
	Temperatures()函数中用const创建温度转换中使用的变量。在main()函数中使用一个循环让用户重复输入温度
	当用户输入q或其他非数字时，循环结束。scanf()函数返回读取数据的数量，所以如果读取数字则返回1，
	如果读取q则不返回1.可以使用=运算符将scanf()的返回值和1做比较，测试两值是否相等。
	

	#include<stdio.h>
	double Temperatures(double);
	int main(void)
	{
		double F;
		printf("please enter the number of temperatures(F):");
		while (scanf_s("%lf", &F))
		{
			Temperatures(F);
			printf("please enter the number of temperatures(F)(q to quit)");
		}	
		return 0;
	}
	double Temperatures(double F)
	{
		double C = 5.0 / 9.0 * (F - 32.0);
		double K = C + 273.16;
		printf("%.2lf H\n%.2lf ℃\n%.2lf K\n", F, C, K);
		return 1;
	}
	

【第六章】C控制语句：循环

程序流：1.执行语句序列；2.如果满足某些条件就重复执行语句序列(循环)；3.通过测试选择执行哪一个语句序列(分支)；

3种循环：while循环 、for循环、do while循环


6.1.1 while循环

	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		long num;
		long sum = 0L;
		int status;
		printf("Please enter an integer to be summed(q to quit):");	
		status = scanf_s("%ld", &num);
		while(status==1)
		{
			sum = sum + num;	
			printf("Please enter an integer to be summed(q to quit):");
			status = scanf_s("%ld", &num);
		}
		printf("Those integers sum to %ld.\n", sum);
		Sleep(2000);
		return 0;
	}


程序结构分析(伪代码)：伪代码：用一种间的的句子表示程序思路的方法；

	把sum初始化为0
	提示用户输入数据
	读取用户输入的数据
	当输入的数据为整数的时候
		将输入值累计到sum
		提示用户继续输入
		然后读取下一个输入
	输入完成后，输出sum的值；

	总之，因为while循环是入口条件循环，程序在进入循环之前必须获取输入的数据并检查status的值
	所以在while前面要有一个scanf_s()；
	要让循环继续执行，在循环内需要一个读取数据的语句，来重置status的值；

	所以可以将下面的伪代码作为while循环的标准格式：
		获得第一个用于测试的值
		当测试为真时
			处理值
			获取下一个值

6.1.2	C风格读取循环

	原代码格式：
	status = scanf_s("%ld", &num);
	while(status==1)
	{
		/*循环行为*/
		status = scanf_s("%ld", &num);
	}

	可以简化替换为

	while(scanf_s("%ld",&num)==1)
	{
		/*循环行为*/
	}
	
	第二种形式同时使用scanf_()的两种不同特性；
	首先，如果函数调用成功，scanf_s()会把一个值存入num
	然后，利用scanf_s()的返回值(0或1)来控制while循环。
	
	因为每次迭代都会判断循环的条件，所以每次都需要调用scanf_()读取新的num值来做判断；
	所以C语言特性让你可以用下面精简版本替代标准版本：
		当获取值和判断值都成功
			处理该值


6.2 	while语句
	while循环的通用形式如下：
	while(expression)
		statment
	statment部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复杂语句。
	到目前为止，expression部分都是使用关系表达式，如果expression为真(非0)，执行statment部分一次，
	然后再次判断xepression，在expression为假(0)之前，循环的判断和执行一直重复进行
	每次循环都被成为一次迭代(iteration)
	
6.2.1	终止while循环
	while循环有一点非常重要：在构建while循环时，必须让表达式的值有变化，表达式最终要为假(0)
	否则，循环就不会终止(实际上可以使用break和if语句来终止)
	考虑下面的例子：
	index=1；
	while(index<5){/*表达式*/}；
	↑程序将无限重复；
	index=1；
	while(--index<5){/*表达式*/}；
	↑程序虽然改变了index的值，但是需要循环到该类型数据溢出；
	//表达式改成++index<5则是达到执行有限的指定次数效果；

6.2.2	何时终止循环
	
	#include<stdio.h>
	int main(void)
	 {
		int n = 5;
		while (n < 7)			 //第5行
		{
			printf("n=%d\n", n);
			n++;			//第8行
			printf("now n=%d\n", n);	//第9行
		}
		printf("the loop has finished.\n");
		getchar();
		return 0;
	}
--------------------------------------------
	n=5
	now n=6
	n=6
	now n=7
	the loop has finished.
	
	在第二次循环时，变量n在第8行首次获得值7，程序此时并未退出，它继续执行本次循环(执行第9行)，
	并在对第5行的测试条件求值时候才退出循环n=7  (n<7)不成立，退出循环，执行循环外语句。

6.2.3	while：入口循环条件
	while循环是使用入口条件的有条件循环。所谓有条件指的是语句部分的执行取决于表达式的描述/限定；
	例如(index<5),该表达式是一个入口条件(entry condition),满足该条件才能进入循环。
	
6.2.4	语法要点
	使用while时，要牢记一点：只有在测试条件后面的单独语句(简单语句或复合语句)才是循环部分；
	错误示例：
	
	#include<stdio.h>
	int main(void) 
	{
		int n = 0;
		while(n<3)	
			printf("n is %d\n", n);	//该部分为循环部分；因n没有重置而陷入死循环；
			n++;			//不在测试条件后面的单独语句；跳出循环前不执行；
		printf("that's all this program does.\n");
		getchar();
		return 0;	
	}
	
	
	综上，即使while语句本身是复合语句，但是在语句构成上，它也是一条单独的语句；
	该语句从while开始执行，到第一个分号结束。在使用了复合语句情况下到右花括号结束。

	示例：下面两个例子输出结果差别：

	#include<stdio.h>
	int main(void) 
	{
		int n = 0;
		while(n++<3)	
			printf("n is %d\n", n);	//while语句结束位置	
		printf("that's all this program does.\n");
		getchar();
		return 0;	
	}
	

	#include<stdio.h>
	int main(void) 
	{
		int n = 0;
		while(n++<3)
		；			//while语句结束位置
		printf("n is %d\n", n);	
		printf("that's all this program does.\n");
		getchar();
		return 0;	
	}
	
	在后一例中，测试条件后的单独分号是空语句(null statement),它什么也不做；
	有时故意使用带空语句的while语句，因为所有的任务都在测试条件中完成了，不需要在循环中做什么。
	例如，假设你想跳过输入到第一个非空白字符或数字，可以这样写：
	while(scanf_s("%d",&num)==1)
	;		

	只要scanf_s()读取一个整数，就会返回1，循环继续执行。
	为了提高代码可读性，应该让这行分号独占一行，不要直接把它放在测试表达式同行。
	这样一方面让读者更容易看到空语句；另一方面也提醒自己和读者，空语句是有意而为之。

6.3	用关系运算符和表达式比较大小
	＜	小于
	＞	大于
	≤	小于等于
	≥	大于等于
	==	等于
	！=	不等于
	
	示例
	while(number<6)
	while(ch!='$')
	while(scanf_s("%f",&num)==1)
	
	虽然运算关系也可以用来比较浮点数，但是要注意：比较浮点数时，尽量使用<和>
	因为浮点数的舍入误差导致在逻辑上应该相等的两数却不相等，例如3乘以1/3的积是1.0
	如果把1/3表示成小数点后6位数字，乘积则是0.999999不等于1.0
	使用fabs()函数（声明在math.h头文件中）可以方便的比较浮点数，该函数返回一个浮点值的绝对值。
	示例：

	#include<stdio.h>
	#include<math.h>
	int main(void)
	{
		const double answer = 3.14159;
		double respons;
		printf("What's the value of pi?\n");
		scanf_s("%lf", &respons);
		while(fabs(respons-answer)>0.0001)
		{
			printf("try again!\n");
			scanf_s("%lf", &respons);
		}
		printf("close enough!\n");
		getchar();
		getchar();
		return 0;
	}
	
6.3.1	什么是真
	在C语言中，表达式一定有一个值，关系表达式也不例外。
	示例：程序打印两个关系表达式的值，一个为真一个为假。
	#include<stdio.h>
	int main(void)
	{
		int truevalu, falsevalu;
		truevalue = (10 > 2);
		falsevalue = (10 == 2);
		printf("ture=%d;false=%d\n", truevalu, falsevalu);
		getchar();
		return 0;
	}

	所以对C语言而言，表达式为真的值是1，表达式为假的值是0；
	有些循环结构由于1为真，所以循环会一直执行如；while(1){...}

6.3.2	其他真值

	#include<stdio.h>
	int main(void)
	{
		int n = 3;
		while(n)
		{
			printf("%2d is true\n", n--);
		}
		printf("%2d is false\n", n);

		n = -3;
		while (n)
		{
			printf("%2d is true\n", n++);
		}
		printf("%2d is false\n", n);
		getchar();
		return 0;
	}

	也可以说，只要测试条件的值为非零，就会执行while循环。
	这是从数值方面，而不是真/假方面来看测试条件；
	要牢记：关系表达式为真，求值得1；关系表达式为假，求值得0；
	因此，这些表达式实际上相当于数值。
	因此可以很好的利用测试条件这一特性；比如用while(valu)替换while(valu!=0)

6.3.3	真值的问题
	C对真的概念约束太少会带来一些麻烦；例如：
	
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		long num;
		long sum = 0L;
		int status;

		printf("Please enter an integer to be summed(q to quit):");	
		status = scanf_s("%ld", &num);
		while(status=1)					//将等号==改为赋值=
		{
			sum = sum + num;	
			printf("Please enter an integer to be summed(q to quit):");
			status = scanf_s("%ld", &num);
		}
		printf("Those integers sum to %ld.\n", sum);
		Sleep(2000);
		return 0;
	}
	
	调试程序，本应在用户输入q结束输入并计算结果的时候，循环开始陷入重复输入提示的bug……

	由于status=1是一个赋值表达式语句，赋值后，while(status=1)循环语句实际就变成while(1),
	虽然用户输入q，status被设置为0，但是循环测试条件把status又重置为1，进入了下一次迭代；
	那为什么会陷入重复提示且无法输入呢？
	因为，如果scanf_s()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，供下次读取；
	当scanf_s()把q作为整数读取失败了，它把q留下。
	在下次循环时，scanf_s()函数从上次读取失败的地方(q)作为整数开始读取，又失败了，陷入无限循环；

	不要在本应使用==的地方使用=
	一些计算机语言如(basic)用相同的符号表示赋值运算符和关系相等运算符，但这两个运算符完全不同
	示例：
	value==5  //检查value的值是否为5；
	value=5	//把数值5赋给value；
	
	tips：如果待比较的值是常量，可以把该常量放在左侧有助于编译器捕获错误
	5=value；//语法错误；
	5==value	//检查value的值是否为5；

	这是因为C语言不允许给常量赋值，编译器会把赋值运算符的这种用法作为语法错误标记出来；

	总之，关系运算符用于构成关系表达式，关系表达式为真的时候值是1，为假时值为0.
	通常用关系表达式作为测试条件的语句如while if可以使用任何表达式作为测试条件，非零为真，零为假

6.3.4	C99新增的 _Bool 类型
	
	在编程中，表示真或假的变量称为布尔变量（boolean variable），所以_Bool是C语言中布尔变量的类型名；
	_Bool类型的变量只能存储1(真)或0(假)，如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1；
	
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		long num;
		long sum = 0L;
		_Bool input;

		printf("Please enter an integer to be summed(q to quit):");	
		input =( scanf_s("%ld", &num)==1);
		while(input)					
		{
			sum = sum + num;	
			printf("Please enter an integer to be summed(q to quit):");
			input =( scanf_s("%ld", &num)==1);
		}
		printf("Those integers sum to %ld.\n", sum);
		Sleep(2000);
		return 0;
	}
	
	C99提供了stdbool.h的头文件，该头文件让bool成为_Bool的别名，而且还把true和false分别定义为1和0；
	包含该头文件后，写出的代码可以与C++兼容，因为C++把bool ture false定义为关键字；
	如果系统不支持_Bool类型，导致无法运行该程序，可以把_Bool替换成int即可。

6.3.5	优先级和关系运算符

	1.关系运算符的优先级比算术运算符低，比赋值运算符高。
	这意味着
	 x>y+2 和 x>(y+2)相同；
	 x=y>2 和 x=(y>2)相同；//如果y大于2，则给x赋值1，否则0，y的值不会赋给x；
	
	2.关系运算符之间有不同的优先级
	高优先级组：＜ ≤ ＞ ≥
	低优先级组：== !=
	与其他大多数运算符一样，关系运算符的结合律也是从左往右；因此
	ex!=wye==zee 和 (ex!=wye)==zee 相同//先判断ex与wye是否相等得出值0或者1，再与zee比较；

	完整优先等级表
	运算符(优先级从高到低)	结合律
	（）			从左往右→
	-  +  ++  -- sizeof		从右往左←	
	*   /  %			从左往右→
	+  -			从左往右→
	<  >  ≥  ≤			从左往右→
	==  !=			从左往右→
	=			从右往左←	

6.4	不确定循环和计数循环
	不确定循环：在测试表达式为假之前，预先不知道要执行多少长循环
	计数循环：   在循环执行之前就知道要重复执行多少次

	#include<stdio.h>
	int main(void)
	{
		int a = 1;			//初始化
		while (a <= 10)		//测试
		{
			printf("goodluck\n");	//行为
			a++;		//更新计数
		}
		getchar();
		return 0;
	}
	
	在创建一个重复执行固定次数的循环中涉及3个行为：
	1.必须初始化计数器；
	2.计数器与有限的值作比较；
	3.每次循环时递增/减计数器；

	在上面的例子中，递增发生在循环的末尾，可以防止不小心漏掉递增，因此这样比(a++<=10)好，
	但是计数器的初始化放在循环外，就有可能忘记初始化。

6.5	for循环
	for循环将上述3个行为(初始化、测试和更新)组合在一起
	#include<stdio.h>
	int main(void)
	{
		int a;	
		for (a = 1; a <= 10; a++)
		{
			printf("%d	%d",a,a*a);
		}
		getchar();
		return 0;
	}
	
	关键字for后面的圆括号内有3个表达式，分别用分号隔开；
	第1个表达式是初始化；只会在for循环开始时执行一次；
	第2个表达式是测试条件，在执行循环之前对表达式求值，如果表达式为假，循环结束；
	第3个表达式执行更新，在每次循环结束时求值；
	
	这三个表达式也叫控制表达式，都是完整的表达式，所以每个表达式的副作用都发生在下一个表达式求值之前

6.5.1	利用for的灵活性
	for的灵活性源于如何使用for循环中的3个表达式
	在前面示例中，1表达式给计数器赋初值，2表达式计数器范围，3表达式递增计数器
	除此以外，for循环还有其他9种用法：

	1.递减计数
	for(a=5;a>0;a--)
	
	2.固定数递增
	for(n=2;n<60;n=n+10)
	
	3.用字符代替数字计数
	for(ch='a';ch<='z';ch++)

	4.除了测试迭代次数外，还可以测试其他条件比如
	for(a=1;a<=6;a++)替换成for(a=1;a*a<=36;a++)
	与控制次数相比，如果更关心测试条件限制，可以这样使用；
	
	5.让递增的量几何增长，而不是算术增长
	for(a=10;a<150;a=a*1.2)

	6.第三个表达式可以使用任意合法的表达式；并每次迭代都会更新该表达式的值
	for(x=1;y<=75;y=(++x*5)+50)

	7.可以省略一个或多个表达式
	n=25;
	for(a=2;n<=125;){n=n*a}//该循环保持a=2;变量n的值从初始25变50 100 200；
	另；省略第2个表达式被视为真，所以for(;;),则循环会一直运行；

	8.第1个表达式不一定是给变量赋初值，也可以使用printf()
	在执行循环其他部分之前，只对第1个表达式求一次值或执行一次；例：
	#include<stdio.h>
	int main(void)
	{
		int num = 0;
		for (printf("keep entering numbers!\n"); num != 6;)
		{scanf_s("%d", &num);}
		printf("That's the one I want!\n");
		getchar();
		getchar();
		return 0;
	}


	9.循环体中的行为可以改变循环头中的表达式；例如
	for(n=1;n<10000;n=n+delta)
	如果程序经过几次迭代后发现变量delta太小或者太大，循环中的if语句可以改变delta的值
	在交互式程序中，用户可以在循环运行时才改变delta的值；但如果delta为0循环失效；

6.6	其他赋值运算符 +=  -=  *=  /=  %=
	
	a+=20	等效于	a=a+20
	a -=20	等效于	a=a -20
	a *=20	等效于	a=a *20
	a /=20	等效于	a=a /20
	a%=20	等效于	a=a%20

	上述所列运算符右侧都使用了简单的数字，还可以使用更复杂的表达式；例如
	x*=3*y+12	等效于	x=x*(3*y+12)


6.7	逗号运算符

	示例程序：
	
	#include<stdio.h>
	int main(void)
	{
		int a, b;
		for (a = 1, b = 5; a <= 5; a++, b += 3)
		{printf("%d %d\n", a, b);}
		getchar();
		return 0;
	}
	
	该程序在初始化表达式和更新表达式中都使用了逗号运算符；
	初始化表达式中逗号使得a和b都进行了初始化；
	更新表达式中逗号使每次迭代都更新a和b的值；绝大部分计算都在for循环头中进行

	逗号运算符并不局限在for循环，但是这是它最常用的地方
	逗号运算符有2个特质：
	1.	首先它保证了被它分隔的表达式从左往右求值；(即逗号是一个序列点)
	逗号左侧所有副作用都在程序执行逗号右侧前发生；
	例如 a++,b=a+20;在该表达式中，先递增a的值，然后在b的表达式中使用a更新后的值；

	2.	整个逗号表达式的值是右侧项的值，例如：
	x=(y=3,(z=++y+2)+5);
	效果是先把3赋给y，然后y递增为4，然后4+2=6赋给z，z+5=11赋给x；x=11；
	
	另，加入在输入数字时不小心输入了逗号：
	a=249,500;
	此表达式没语法错误，编译器会将其解释成一个逗号表达式；即a=249为左侧，500为右侧表达式；
	效果类同于 
	a=249;
	500;	//tips:任何表达式后面加上一个分号就成了表达式语句，500；也是一条语句，虽然它什么都不做；
	
	另，
	a=(249,500);	//赋值给a的值是逗号右侧的子表达式的值，即a=500;
	
	逗号也可以作为分隔符。如 int a=2,b=3;此时逗号是分隔符，不是逗号运算符；




6.7.1	芝诺悖论与for循环
	
	芝诺二分法悖论
	
	从A点到B点，必须通过AB之间的中点，每一次到达中点后剩下的路程还有中点…
	按照芝诺悖论，把AB之间有限的距离无限细分，永远走不完这条路……
	用无限序列来表示总时间，假设走到AB中点花费的时间为1，则匀速走完AB需要的时间s：
	s=1+1/2+1/4+1/8+1/16+……

	#include<stdio.h>
	int main(void)
	{
		int a;//计数项
		double s, zeno;//s:所花时间总和，zeno：每次剩下一半的变量
		int limit;//查看点

		printf("Enter the number of terms you want:");
		scanf_s("%d", &limit);
		for (s = 0, zeno = 1, a = 1; a <= limit; a++, zeno = zeno * 2.0)
		{
			s = s + 1.0 / zeno;
			printf("time=%f when terms =%d.\n", s, a);
		}
		getchar();
		getchar();
		return 0;
	}
	
	
	数学家证明当项的数目接近无穷时，总和无限接近2.0，数学证明方法：
	
	s=1+1/2+1/4+1/8+1/16……
	
	将s除以2可得

	s/2=1/2+1/4+1/8+1/16……
	
	将第一个式子减去第二个式子可得
	s-s/2=1,

	即s=2；
	

6.8	出口条件循环 do while
	
	while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，
	所以有可能根本不执行循环中的内容；
	而出口条件循环则是在循环的每次迭代之后检测测试条件，
	这保证了至少执行循环中的内容一次；这种循环成为do while
	
	示例
	#include<stdio.h>
	int main(void)
	{
		int a,code;
		code = 13;
		printf("wellcome to play number riddle\n");
		do
		{	
			printf("Please enter a number you choose:");
			scanf_s("%d", &a);
		} 
		while (a != code);
		printf("congratulations!\n");
		getchar();
		getchar();
		return 0;
	}

	do while循环的通用形式：
	
	do
	        statement
	while(expression);
	
	statement可以是一条简单语句或复合语句，do while循环以分号结尾；
	do while 循环适应于那些至少要迭代一次的循环，如：
	
	do
	{
		提示用户输入密码
		读取用户输入的密码
	}while（用户输入的密码不等于密码）；
	
	
6.9	如何选择循环
	入口条件循环和出口条件循环按照是否需要必须执行一次来选择；
	通常入口条件循环常用些，好处在于：
	1.一般原则是在执行程序前测试条件比较好
	2.测试条件放在循环的开头程序可读性更高；
	3.许多应用中要求在一开始不满足测试条件时直接跳过整个循环；
	
	入口条件循环的选择用for还是while看个人喜好；
	一般当循环涉及初始化和更新变量时，用for循环比较合适，其他情况下while循环更好；
	如
	while(scanf_s("%ld",&num)==1)
	for(count=1;count<=100;count++)


6.10	嵌套循环
	嵌套循环指的是在一个循环内包含另一个循环，嵌套循环常用于按行和列显示数据
	也就是说一个循环处理一行所有的列，另一个循环处理所有的行
	示例：
	#include<stdio.h>
	#define ROWS 6
	#define CHARS 10
	int main(void)
	{
		int row;
		char ch;
		for (row = 0; row < ROWS; row++)		//外层循环，创建6行
		{
			for (ch = 'A'; ch < ('A' + CHARS); ch++) 	//内层循环，打印10字符
			{ printf("%c", ch); }
			printf("\n");
		}
		getchar();
		return 0;
	}

6.10.2	嵌套变式
		
	#include<stdio.h>
	int main(void)
	{

		const int ROWS = 6;
		const int CHARS = 6;
		int row;
		char ch;	
		for (row = 0; row < ROWS; row++)
		{
			for (ch = ('A' + row); ch < ('A' + CHARS); ch++)
			{printf("%c", ch);}
			printf("\n");
		}
		getchar();
		return 0;
	}


6.11	数组简介
	数组是按照顺序存储的一系列类型相同的值；整个数组有一个数组名，通过整数下标访问数组中单独的项或元素
	声明示例如下：
	float debts [20];
	
	声明debts是一个内含20个元素的数组，每个元素都是存储float类型的值；
	第1个元素是debts[0],第2个元素是debts[1]…以此类推直到debts[19]；
	
	数组元素编号从0开始，而不是从1开始，可以给每个元素赋值，比如
	debts[5]=32.2;
	debts[6]=1.732;
	实际上使用数组元素和使用同类型的变量一样，例如可以把值读入指定的元素中：
	scanf_s("%f",&debts[4]);	//把一个值读取入数组的第5个元素
	tips：C编译器不会检查数组的下标是否正确，例如示例声明中：
	debts[30]=20.5;	//该数组元素实际并不存在，debts[19]是该数组最后的元素；
	因为编译器不会查找这样的错误，当程序运行时，会导致数据被放置在已被其他数据占用的地方
	这可能会破坏程序的结果甚至导致程序异常中断；
	
	int num[20];	//可存储20个int类型整数的数组；
	char name[50];	//可存储50个字符的数组；
	long big[500];	//可存储500个long类型整数的数组；
	
	字符串：如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成字符串；
	you can see it.	char[15]	//字符数组，不是字符串；
	you can see it.\0	char[16]	//即是字符数组，也是字符串

	用于识别数组元素的数字被称为下标/索引/偏移量；
	下标必须是整数而且要从0开始计数，数组的元素被依次存储在内存中的相邻位置；如：
	
	int boo[4]  (每个int为2字节)

	1980	46	4816	3
	boo[0]	boo[1]	boo[2]	boo[3]
	
	char foo[4]  (每个char为1字节)

	h	e	l	p
	foo[0]	foo[1]	foo[2]	foo[3]


6.11.1	在for循环中使用数组
	示例：程序读取10个高尔夫分数，稍后进行处理；使用数组就不用创建10个不同的变量来存储10个高尔夫分数
	而且，还可以用for循环来读取数据，程序输出总分、平均分、差点(平均分与标准分的差值)

	#include<stdio.h>
	#define SIZE 10
	#define PAR 72
	int main(void)
	{	
		int index,score[SIZE];
		int sum = 0;
		float average;
		printf("Enter %d golf scores:\n", SIZE);
		for (index = 0; index < SIZE; index++) 
		{ scanf_s("%d", &score[index]); }//读取10个高尔夫分数
		printf("The scores read in are as follow:\n");
		for(index=0;index<SIZE;index++)
		{printf("%2d %5d\n", index+1, score[index]);}//验证输入
		for (index = 0; index < SIZE; index++) { sum = sum + score[index]; }//求总分
		average = (float)sum / SIZE;//求平均分
		printf("Sum of score=%d,average=%.2f\nThat's a handicap of %.0f.\n", sum, average, average - PAR);
		getchar();
		getchar();
		return 0;
	}

6.12	使用函数返回值的循环示例
	
	#include<stdio.h>
	double power(double n, int p);	//ANSI函数原型
	int main(void)
	{
		double x, xpow;
		int exp;
		printf("Enter a number and the positive integer power");
		printf("to which\nthe number will be raised.(q to quit).\n");
		while (scanf_s("%lf %d", &x, &exp) == 2)
		{
			xpow = power(x, exp);//函数调用
			printf("%.3g to the power %d is %.5g\n", x, exp, xpow);
			printf("Enter next pair of numbers or q to quit.\n");
		}
		printf("hope you enjoyed this power trip--bye!\n");
		return 0;
	}
	double power(double n, int p)	//函数定义
	{
		double pow = 1;
		int i;
		for (i = 1; i <= p; i++)
			pow *= n;
		return pow;
	}


6.12.2	使用带返回值的函数
	声明函数，调用函数，定义函数，使用关键字return，都是定义和使用带返回值函数的基本要素
	为什么在定义中说明了power()的返回类型为double，还要单独声明这个函数？
	既然在使用函数返回值之前要声明函数，为什么scanf_s()返回值之前没有声明scanf_s()
	
	编译器在程序中首次遇到power()时，需要直到它的返回类型；
	此时编译器尚未执行到power()的定义，并不知道函数中的返回类型是double
	因此必须通过前置声明，预先说明函数的返回类型，前置声明告诉编译器，该函数的定义在别处，
	其返回类型为double。如果把power()函数的定义置于main()的文件顶部，就可以省略前置声明，
	但是这不是C语言的标准风格，因为main()通常只提供整个程序的框架，最好把main()放在所有函数定义的前面；
	另外，通常把函数放在其他文件中，所以前置声明必不可少；
	scanf_s()能使用的原因是已经声明了，stdio.h头文件中包含了函数原型，它的返回类型是int


6.13	关键概念
	1.注意循环的测试条件要能使循环结束(可退出)；
	2.确保循环测试中的值在首次使用之前已经初始化；
	3.确保循环在每次迭代都更新测试的值；

	C通过求值来处理测试条件，结果为0表示假，非0表示真，带关系运算符的表达式也常用来做循环测试；
	数组由相邻的内存位置组成，只存储相同类型的数据，下标从0开始编号；
	
	使用函数设计3个步骤：
	1.通过函数原型声明函数；
	2.在程序中通过调用函数使用；
	3.定义函数；
	
	函数原型是为了方便编译器查看程序中使用的函数是否正确，函数定义描述了函数如何工作；
	现代的编程习惯是把程序要素分为接口部分和实现部分，例如函数原型和函数定义
	接口部分描述了如何使用一个特性，也就是函数原型所做的；
	实现部分描述了具体的行为，这正是函数定义所做的。

	
6.14	本章小结
	
	1.典型的while循环设计伪代码如下：

	获得初值
	while(满足测试条件)
	{
	处理该值
	获取下一个值
	}

	2.for循环也可以完成相同的任务：
	
	for(获得初始值；满足测试条件；获得下一个值)
		{处理该值}

	这些循环都使用测试条件来判断是否继续执行下一次迭代；
	一般而言，如果对测试表达式求值为非0，继续循环，否则循环结束

6.15	复习题
	
	1.写出执行完下列各行后quack的值是多少；后5行使用的均是前1行quack的值
	int quack=2；	//quack=2
	quack+=5;	//quack=quack+5	==7
	quack*=10;	//quack=quack*10	==70
	quack-=6;		//quack=quack-6	==64
	quack/=8;		//quack=quack/8	==8
	quack%=3;	//quack=quack%3	==2


	2.假设value是int类型，下面循环的输出是什么？如果value是double类型，会出现什么问题？
	
	for(value=36;value>0;value/=2)printf("%3d",value);
	
	36	18	9	4	2	1	
	
	36.0	18.0	9.0	4.5	2.25	1.125	……
	
	3.用代码表示以下测试条件：
	①.x大于5					//x>5;
	②.scanf_s()读取一个名为x的double类型的值且失败	//double x;    scanf_s("%lf",&x)==0;//scanf_s("%lf",&x)!=1;
	③.x的值等于5				//x==5;
	④.scanf_s()成功读入一个整数			//int x;    scanf_s("%d",&x)==1;
	⑤.x不等于5				//x!=5;
	⑥.x大于或等于20				//x>=20;

	5.下面的程序有点问题，请找出问题所在

	#include<stdio.h>
	int main(void)
	{					//第3行；				
		int i, j, list[10];			//第4行；	

		for (i = 1; i <= 10; i++)		//第6行；for(;;)中间分号隔开
		{				//第7行；			
			list[i] = 2 * i + 3;		//第8行；
			for (j = 1; j <= i; j++)	//第9行；	for(;;)中间分号隔开；j<=i;否则无限循环
				printf("  %d", list[j]);	//第10行；	
			printf("\n");		//第11行；	
		}				//第12行；}为for循环结尾					
		getchar();
		return 0;
	}		
	

	6.编写一个程序打印下面的图案，要求使用嵌套循环：
	$$$$$$$$
	$$$$$$$$
	$$$$$$$$
	$$$$$$$$
	
	#include<stdio.h>
	int main(void)
	{
		int a, b;	
		for (a = 0; a < 4; a++)
		{
			for (b = 0; b < 8; b++) 
				printf("$");
			printf("\n");		
		}
		getchar();
		return 0;
	}
	

	7.下面的程序各打印什么内容？
	
	①//Hi! Hi! Hi! Bye! Bye! Bye! Bye! Bye! 
	#include<stdio.h>
	int main(void)
	{
		int i = 0;
		while (++i < 4)
			printf("Hi! ");
		do
			printf("Bye! ");
		while (i++ < 8);
		getchar();
		return 0;
	}
	

	②//ACGM
	#include<stdio.h>
	int main(void)
	{
		int i;
		char ch;
		for (i = 0, ch = 'A'; i < 4; i++, ch += 2 * i)
			printf("%c", ch);
		getchar();
		return 0;
	}
	
	

	8.假设用户输入的是 Go west,young man! 下面各程序输出的是什么？
	(在ASCII码中 !紧跟在空格字符后面)

	①// Go west,youn	/*循环遇到输入g后终止；*/

	#include<stdio.h>
	int main(void)
	{
		char ch;
		scanf_s("%c", &ch,1);
		while (ch != 'g')
		{
			printf("%c", ch);
			scanf_s("%c", &ch,1);
		}
		return 0;
	}

	
	②// Hp!xfty-zpvo	/*循环遇到输入g后终止，所有输出按照输入偏移1个值*/
	
	#include<stdio.h>
	int main(void)
	{
		char ch;
		scanf_s("%c", &ch,1);
		while (ch != 'g')
		{
			printf("%c", ++ch);
			scanf_s("%c", &ch,1);
		}
		return 0;
	}	
		
	
	③//Go west,young	/*do while 遇到输入g时先输出g然后终止循环*/

	#include<stdio.h>
	int main(void)
	{
		char ch;
		do
		{
			scanf_s("%c", &ch,1);
			printf("%c",ch);
		}
		while (ch != 'g')
		return 0;
	}	
	
	④$o west,youn	/*for循环初始值执行一次ch=$赋值行为，遇到输入g后终止循环*/
	
	#include<stdio.h>	
	int main(void)
	{
		char ch;
		scanf_s("%c", &ch, 1);
		for (ch = '$'; ch != 'g'; scanf_s("%c", &ch))
			printf("%c", ch);		
		return 0;
	}
		

	9.下面的程序输出什么内容？
	
	#include<stdio.h>
	int main(void)
	{
		int n, m;
		n = 30;
		while (++n <= 33)
			printf("%d|", n);//31|32|33|

		n = 30;
		do
			printf("%d|", n);
		while (++n <= 33);	//30|31|32|33|

		printf("\n***\n");	//换行***换行

		for (n = 1; n*n < 200; n += 4)
			printf("%d\n", n);	//1换行5换行9换行13换行

		printf("\n***\n");	//换行***换行

		for (n = 2, m = 6; n < m; n *= 2, m += 2)
			printf("%d %d\n", n, m);//2 6换行 4 8换行 8 10换行

		printf("\n***\n");	//换行***换行

		for (n = 5; n > 0; n--)
		{
			for (m = 0; m <= n; m++)
				printf("=");
			printf("\n");
		}//======换行=====换行====换行===换行==换行

		getchar();
		return 0;
	}
	
	10.考虑下面的声明：
	double mint[10];
	数组名是什么？	//mint
	该数组有多少个元素	//10
	每个元素可以存储什么类型的值	//double
	下面哪一个scanf_s()的用法正确：
	①scanf_s("%lf",mint[2])
	②scanf_s("%lf",&mint[2])	//正确项
	③scanf_s("%lf",mint)
	
	11.下面程序创建了一个存储2、4、6、8等以2为计数的数组，查找程序问题：
	
	#include<stdio.h>
	#define SIZE 8
	int main(void)
	{
		int two[SIZE];
		int index;
		for (index = 1; index <= SIZE; index++)
			two[index] = 2 * index;
		for (index = 1; index <= SIZE; index++)
			printf("%d\n", two[index]);	//原程序printf("%d\n", two]);输出错误；
		getchar();
		return 0;
	}

	14.下面的程序输出什么内容：
	#include<stdio.h>
	int main(void)
	{
		int k;
		for (k = 1,printf("%d:Hi!\n", k); printf("k=%d\n", k), k*k < 26; k += 2, printf("Now k is %d\n", k))
			printf("k is %d in the loop\n", k);
		getchar();
		return 0;
	}

	//输出内容
	1:Hi!
	k=1
	k is 1 in the loop
	Now k is 3
	k=3
	k is 3 in the loop
	Now k is 5
	k=5
	k is 5 in the loop
	Now k is 7
	k=7


6.16	编程练习
	1.编写一个程序，创建一个包含26个元素的数组，并在其中存储26个小写字母并输出
	①
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY];
		int index;
		for (index = 0; index < QTY; index++)
			scanf_s("%c", &ch[index],1);	//给ch[]数组分配26个小写字母
		for (index = 0; index < QTY; index++)
			printf("%c\n", ch[index]);	//输出数组内容；	
		getchar();
		getchar();
		return 0;
	}
	//该程序仍需要手动输入a~z字母给数组；那有没有办法可以让系统自动分配字母给数组呢？
	
	②
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY];
		char a = 'a';
		int index;
		for (index = 0; index < QTY; index++)
		{
			ch[index] = a++;
			printf("%c", ch[index]);		
		}
		getchar();
		return 0;
	}

	③
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY];
		char a = 'a';
		int index=0;
		while(index<QTY)
		{
			ch[index++] = a++;
			printf("%c", ch[index-1]);			
		}
		getchar();
		return 0;
	}

	④
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY]="abcdefghijklmnopqrstuvwxyz";
		int index;
		for(index=0;index<QTY;index++)
			printf("%c",ch[index]);
		getchar();
		return 0;
	}
	//程序直接将数组内容预赋值完毕；
	
	⑤
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY];
		char a = 'a';
		int index;
		for (index = 0; index < QTY; index++)
		{
			ch[index-1] = a++;
			printf("%c", ch[index-1]);
		}
		getchar();
		return 0;
	}
	
	//想一想下面这个程序为什么不对：
	#include<stdio.h>
	int main(void)
	{
		char ch[26];
		int a,index=0;
		ch[index]='a';
		for(a=0;a<26;a++)
		{
			printf("%c",ch[index]);			
			ch[index]++;
		}
		getchar();
		return 0;
	}
	//虽然输出了26个字母，但是都是ch[0],index始终没更新给下一个数组；
	

	2.使用嵌套循环，按下面格式打印字符：	
	$
	$$
	$$$
	$$$$
	$$$$$
	
	#include<stdio.h>
	int main(void)
	{
		int a,b;
		for (a = 0; a < 5; a++)
		{
			for (b = 0; b <= a; b++)
				printf("$");
			printf("\n");
		}
		getchar();
		return 0;
	}


	3.使用嵌套循环，按下面的格式打印字母：
	F
	FE
	FED
	FEDC
	FEDCB
	FEDCBA

	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		int n,index;
		for (n = 5; n >=0; n--) 
		{
			for (index = 5; index >=n; index--)
				printf("%c", ch[index]);
			printf("\n");
		}
		getchar();
		return 0;
	}


	4.使用嵌套循环，按下面的格式打印字母：
	A
	BC
	DEF
	GHIJ
	KLMNP
	PQRSTU

	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		char ch[QTY] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		int n, m,index=0;
		for (n = 0; n < 6; n++)			//n控制换行数
		{
		
			for (m = 0; m <= n; m++)		//m控制每行字母数量
			{
				printf("%c", ch[index]);	//index控制输出字母
				index++;
			}
			printf("\n");
		}
		return 0;
	}



	5.编写一个程序，提示用户输入大写字母，使用嵌套循环以下面金字塔型的格式打印字母：
	
	          A         	
	        ABA
	      ABCBA
	    ABCDCBA	        
	  ABCDEDCBA
	
	打印这样的图形，要根据用户输入的字母来决定，例如上面的图形是在用户输入E后的打印结果
	提示：用外层循环处理行，每行使用3个内层循环，分别处理空格，升序字母，降序字母的输出
	
	#include<stdio.h>
	#define QTY 26
	int main(void)
	{
		int a,b,c,d,row;
		char E, ch[QTY] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		printf("Please enter a capital letter: ");
		scanf_s("%c", &E, 1);
		row = E +1- 'A';
		for (a = 0; a < row; a++)			//for循环控制换行；
		{
			for (b = row-1; b > a; b--)		//for循环输入空格
				printf(" ");
			for (c = 0; c <= a; c++)		//for循环输入顺序字母
				printf("%c", ch[c]);
			for (d =0 + a; d >0; d--)		//for循环输入逆序字母
				printf("%c", ch[d-1]);
			printf("\n");
		}
		getchar();
		getchar();
		return 0;
	}




	6.编写一个程序打印一个表格，每一行打印一个整数，该数的平方，该数的立方；
	要求用户输入表格的上下限，使用for循环。
	
	#include<stdio.h>
	int main(void)
	{
		int first, last,n;
		printf("Check list\n");
		printf("Enter the number of list start form:\n");
		scanf_s("%d", &first);
		printf("And enter the number in the end:");
		scanf_s("%d", &last);
		for (n = first; n <= last; n++)
		{
			printf("n=%d;	n*n=%d;	n*n*n=%d\n",n,n*n,n*n*n);
		}
		getchar();
		return 0;
	}

	
	7.编写一个程序把一个单词读入一个字符数组中，然后倒序打印这个单词；
	提示：strlen()函数可用于计算数组最后一个字符的下标；

	#include<stdio.h>
	int main(void)
	{
		int n,i;
		char ch[40];
		scanf_s("%s", ch,40);	
		n = strlen(ch);
		for (i = n; i >= 0; i--)
			printf("%c", ch[i-1]);
		return 0;
	}



	8.编写一个程序，要求用户输入两个浮点数，并打印两数之差除以两数乘积的结果；
	在用户输入非数字之前，程序应循环处理用户输入的每对值；
	
	#include<stdio.h>
	int main(void)
	{
		float a, b,c;
		printf("Please enter two number,q to quit:\n");	
		while (scanf_s("%f", &a) == 1 && scanf_s("%f", &b) == 1)
		{
			c = (a - b) / (a*b);
			printf("%.2f", c);
		}
		return 0;
	}

	
	
	9.修改练习8，使用一个函数返回计算的结果；
	

	#include<stdio.h>
	float back(float x, float y);
	int main(void)
	{
		float a,b;
		printf("Please enter two number,q to quit:\n");
		while (scanf_s("%f", &a) == 1 && scanf_s("%f", &b) == 1)
			printf("%.2f\n",back(a,b));		
		return 0;
	}
	float back(float x, float y)
	{
		float n;
		n = 1.0;
		n = (x - y) / (x*y);
		return n;
	}


	10.编写一个程序，要求用户输入一个上限整数和一个下限整数；
	程序计算从上限到下限范围内所有整数的平方和，并显示计算结果；
	程序循环执行，直到输入的上限数小于下限数为止；
	程序的运行示例如下：
	Enter lower and upper integer limits：5  9
	the sums of the spuares form 25 to 81 is 255
	Enter next set of limits: 3  25
	the sums of the spuares form 9 to 625 is 5520
	Enter next set of limits: 5  5
	Done
	
	#include<stdio.h>
	int main(void)
	{
		int low, up,n,sum=0;	
		printf("Enter lower and upper integer limits:");
		scanf_s("%d %d", &low, &up);	
		for (n = low; n <=up; n++)
		{
			for (n = low; n <= up; n++)
				sum = sum + n * n;
			printf("the sums of the spuares form %d to %d is %d\n", low*low, up*up, sum);
			printf("Enter next set of limits:");
			scanf_s("%d %d", &low, &up);
			n = low;
			sum = 0;
		}
		printf("Done");
		return 0;
	}

	11.编写一个程序，在数组中读入8个整数，然后按倒序打印这8个整数
	#include<stdio.h>
	int main(void)
	{
		int n, i,num[8];
		for(n=0;n<8;n++)
			scanf_s("%d", &num[n]);
		for (i = 7; i >=0; i--)
			printf("%d\n", num[i]);
		return 0;
	}
	


	12.思考下面两个无限序列：
	1.0+1.0/2.0+1.0/3.0+1.0/4.0+……
	1.0- 1.0/2.0+1.0/3.0- 1.0/4.0+……
	编写一个程序计算这两个无限序列的总和，直到到达某次数。
	提示：奇数个-1相乘为-1；偶数个-1相乘为1；让用户交互地输入指定次数
	当用户输入0或者负值时结束输入。
	查看运行100项；1000，10000项后的总和，是否发现每个序列都收敛于某值？

	#include<stdio.h>
	int main(void)
	{
		int i,j,limit,k=-1;
		float n=0,m=0;
		printf("Enter the number you look up:\n");
		scanf_s("%d", &limit, 1);
		while (limit > 0)
		{
			for (i = 1; i <= limit; i++)
			{
				n = n + (1.0 / i);
				//printf("%d	%.2f\n", i, n);
			}
			for (k = 1, j = 1; j <= limit; k = k * -1, j++)
			{
				m = m + (1.0 / j)*k;
				//printf("%d	%.2f\n", j, m);
			}
			printf("%.2f\n", n + m);
			scanf_s("%d", &limit, 1);
			i = 1;
			j = 1;
			n = 0;
			m = 0;
		}
		return 0;
	}
	


	13.编写一个程序，创建一个包含8个元素的int类型数组，分别把数组元素设置为2的前8次幂。
	使用for循环设置数组元素的值，使用do while循环显示数组元素的值。
	
	#include<stdio.h>
	int main(void)
	{
		int i,j, n[9];
		n[0] = 2;
		j = 1;
		for (i = 1; i <= 8; i++)			
			n[i] = n[i-1] * 2;		
		do
		{
			printf("%d\n", n[j-1]);
			j++;
		}
		while (j <= 8);
		return 0;
	}


	14.编写一个程序，创建两个包含8个元素的double类型数组，使用循环提示用户为第一个数组输入8个值。
	第二个数组元素的值设置为第一个数组对应元素的累积之和；
	最后使用循环显示两个数组的内容，第一个数组显示成一行，第二个数组显示在下一行，元素相对应；

	#include<stdio.h>
	int main(void)
	{
		double a[8], b[8],sum;
		int i, j,k;	
		sum = 0;
		printf("Please enter 8 numbers for the first digit group:\n");
	
		for (i = 0; i < 8; i++)//为第一个数组输入8个值；
		{
			printf("Enter the number (%d/8) is:",i+1);
			scanf_s("%lf", &a[i], 1);
			//printf("the number of %d/8 is:%.2f\n", i+1, a[i]);			
		}	
	
		for (j = 0; j < i; j++)//为第二个数组输入值；
		{
			sum = sum + a[j];
			b[j] = sum;
			//printf("b[%d]=%.2f\n",j, b[j]);
		}

		printf("the first digit group:	");
		for (k = 0; k < 8; k++)
			printf("%5.2f	", a[k]);
		printf("\nthe second digit groua:	");
		for (k = 0; k < 8; k++)
			printf("%5.2f	", b[k]);
		return 0;
	}



	15.编写一个程序，读取一行输入，然后把输入的内容倒序打印出来，可以把输入储存在char类型的数组中；
	假设每行字符不超过255.回忆下，根据%c，scanf_s()函数一次只能从输入中读取一个字符；
	而且在用户按下enter键时scanf()函数会生成一个换行字符(\n)

	#include<stdio.h>
	int main(void)
	{
		char ch[255];
		int i, n;	
		scanf_s("%s", &ch,255);//输入内容;
		n = strlen(ch)-1;
		for (i = n+1; i >= 0; i--)
			printf("%c", ch[i - 1]);
		return 0;
	}


	16.达芙妮以10%的单利息投入了100美元(每年投资获利=原始投资*10%)；
	迪尔德以5%的复合利息投资了100美元(利息是当前余额的5%，包含之前的利息)；
	编写一个程序，计算需要多少年迪尔德的投资额才会超过达芙妮，并显示那时两人的投资额。

	#include<stdio.h>
	int main(void)
	{
		int i;
		double sum1, sum2;
		sum1 = 100;
		sum2 = 100;
		for (i = 1; sum2 <= sum1; i++)
		{
			sum1 = 100+10*i;
			sum2 = sum2 * 1.05;
			//printf("%d	%.2f	%.2f\n",i, sum1, sum2);
		}
		printf("after %dyears,	Daphne:%.2f $;	Deirdre: %.2f $\n", i, sum1, sum2);
		return 0;
	}



	17.chuckie赢得了100万美元(税后)，他把奖金存入年利率8%的账户，在每年的最后一天，chuckie取出10万美元；
	编写一个程序，计算多少年后chuckie会取完账户的钱？

	#include<stdio.h>
	void main(void)
	{
		double sum1, sum2;
		int i;
		sum1 = 100;
		sum2 = 100;
		for (i = 1; sum2 >= 10; i++)
		{
			sum2 = sum2*1.08-10;
			printf("%d,%.2f\n", i, sum2);
		}	
		printf("after %d years,Chuckie has no money left.", i );
		return 0;
	}


	18.Rabnud博士加入了一个社交圈，起初他有5个朋友，他注意到他的朋友数量以下面方式增长
	第1周少了1个朋友，剩下的朋友数量翻倍；第2周少了2个朋友，剩下的朋友数量翻倍；
	计算并显示博士每周的朋友数量，该程序一直运行直到超过邓巴数(一个人社交圈稳定关系上限150)
	
	#include<stdio.h>
	void main(void)
	{
		int weeks,friends;
		friends = 5;
		for (weeks = 1; friends < 150; weeks++)
		{
			friends = (friends - weeks) * 2;
			printf("%d weeks,he has %d friends.\n", weeks, friends);
		}
		return 0;
	}






【第七章】C控制语句：分支和跳转

关键字：	if、else、swith、continue、break、case、default、goto
运算符：	&&、||、?:
函数：	getchar()、putchar()、ctype.h系列
如何使用 if 和 if else 语句，如何嵌套它们；
在更复杂的测试表达式中用逻辑运算组合关系表达式
C的条件运算符
switch语句
continue、break 和 goto 语句
ctype.h 头文件提供的字符分析函数系列



7.1	if 语句
	
	程序读取一列数据，每个数据都表示每日的最低温度(℃)，然后输出统计的总天数和最低温度在0℃以下的天数占比；
	程序中的循环通过scanf_s()读入温度值，while循环每迭代一次，就递增计数器增加天数；if语句负责判断0℃以下天数；

	示例程序：		//示例程序有问题会报错，无法计算百分比；
	#include<stdio.h>
	int main(void)
	{
		const int FREEZING = 0;
		float temperature;
		int cold = 0, all = 0;
		printf("Enter the list of daily low temperatures.\n");
		printf("Use Celsius,and q to quit.\n");
		while (scanf_s("%lf", &temperature,1) == 1)
		{
			all++;
			if (temperature < FREEZING)
				cold++;
		}	
		if (all != 0)
			printf("%d days total:%.1f%% were below freezing.\n", all,100.0*(float)cold/all);
		if (all == 0)
			printf("No date entered!\n");		
		return 0;
	}
		


	if语句被称为分支语句或选择语句，它相当于一个交叉点，程序要在两条分支中选择一条执行；
	if语句的通用形式如下：
		if(expression)
			statement

	如果对expression求值为真(非0)，则执行statement，否则就跳过，statement属性与while循环一样
	if与while区别是，如果满足条件的话，while可以测试和执行多次，if只能测试和执行一次；

	
7.2	if else 语句
	
	简单形式的if语句让程序选择执行一条语句，或者跳过这条语句，if else可以让程序在两条语句之间做选择；
	
		if(expression)
			statement1
		else
			statement2

7.21	字符输入输出：getchar()和putchar()

	getchar()函数不带任何参数，它从输入队列中返回下一个字符；例如

	ch=getchar();	效果等同于	scanf_s("%c",&ch);

	putchar()函数打印它的参数；
	
	putchar(ch);	效果等同于	printf("%c",ch);

	由于这些函数只处理字符，所以它们比通用的scanf_s()和printf()函数更快更简洁；且不需要转换说明
	这两个函数定义在stdio.h头文件中；

	#include<stdio.h>
	#define space ' '
	int main(void)
	{
		char ch;
		ch = getchar();
		while (ch != '\n')
		{
			if (ch == space)
				putchar(ch);
			else
				putchar(ch + 1);
			ch = getchar();
		}
		return 0;
	}


7.2.2	ctype.h系列的字符函数
	
	C有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型
	
	#include<stdio.h>
	#include<ctype.h>	//包含了sialpha()的函数原型
	int main(void)
	{
		char ch;
		while ((ch = getchar())!= '\n')
		{
			if (isalpha(ch))		// ch为纯字母；
				putchar(ch + 1);
			else
				putchar(ch);
		}
		putchar(ch);
		return 0;
	}
	
	


	ctype.h头文件中的字符测试函数：
	
	isalnum()		字母或数字
	isalpha()		字母
	isblank()		空白字符
	iscntrl()		控制字符
	isdigit()		数字
	isgraph()		除空格之外的任意可打印字符
	islower()		小写字母
	isprint()		可打印字符
	ispunct()		标点符号
	isspace()		空白字符(空格、换行符、换页符、回车符、垂直制表符、水平制表符或其他本地化指定)
	isupper()		大写字母
	isxdigit()		十六进制数字符
	wolower()		大写转小写
	toupper		小写转大写



7.2.3	多重选择 else if

	例如电力公司电费按照使用量的分段计费：
	首360kwh		$0.13230/kwh
	续108kwh		$0.15040/kwh
	续252kwh		$0.30025/kwh
	超720kwh		$0.34025/kwh
	写一个程序计算电费：
	
	#include<stdio.h>
	#define rate1 0.13230	//费率1
	#define rate2 0.15040	//费率2
	#define rate3 0.30025	//费率3
	#define rate4 0.34025	//费率4
	#define break1 360.0	//分界点1
	#define break2 468.0	//分界点2
	#define break3 720.0	//分界点3
	#define pay1 (rate1*break1)			//一段完全费用
	#define pay2 (pay1+rate2*(break2-break1))	//二段完全费用
	#define pay3 (pay1+pay2+rate3*(break3-break2))	//三段完全费用

	int main(void)
	{
		double kwh;	//总用量
		double bill;	//电费
		printf("Please enter the kwh used.\n");
		scanf_s("%f", &kwh);
		if (kwh <= break1)				//一段内计费；
			bill = pay1 * kwh;			
		else if (kwh <= break2)			//二段计费
			bill = pay1 + (rate2*(kwh - break1));
		else if (kwh <= break3)			//三段计费
			bill = pay2 + (rate3*(kwh - break2));
		else					//四段计费
			bill = pay3 + (rate4*(kwh - break3));
		printf("The charge for %.1f kwh is $ %1.2f.\n", kwh, bill);
		return 0;
	}
	


7.2.4	else与if配对

	测试下面两个程序的结果差异；

	#include<stdio.h>
	int main(void)
	{
		int number;
		scanf_s("%d", &number);
		if (number > 6)
		{
			if (number < 12)
				printf("you're close!\n");
		}
		else
			printf("sorry,you lose a turn!\n");
		return 0;
	}



	#include<stdio.h>
	int main(void)
	{
		int number;
		scanf_s("%d", &number);
		if (number > 6)
			if (number < 12)
				printf("you're close!\n");		
		else
			printf("sorry,you lose a turn!\n");
		return 0;
	}



	
	如果没有花括号，else与离它最近的if匹配；


7.2.5	多层嵌套的if语句

	设计一个程序，给定一个整数，显示所有能整除它的约数，如果没有约数，就报告该数是一个素数
	开发程序模型：
	
	提示用户输入数字
	当scanf()返回值为1
		分析该数并报告结果
		提示用户继续输入
	
	设计如何找出约数；最直接的方法：
	for(i=2;i<num;i++)
		if(num%i==0)
			printf("%d is divisible by %d.\n",num,i);
	循环检查2~num之间的所有数字，测试它们是否能被整除，但是会有点浪费时间；
	比如16，按照程序会输出 2*8	4*4	8*2；
	在得到4*4之后，又开始得到已经找到的约数(只是次序相反)；因此，循环不用到达num，只要到它的平方根就可以

	for(i=2;（i*i）<num;i++)
		if(num%i==0)
			printf("%d is divisible by %d and %d.\n",num,i,num/i);
	
	不使用平方根而用这样的测试条件，1因为整数乘法比求平方根快；2教材还没介绍到平方根函数(真实)

	然而还需要解决两个问题才能开始编程：
	1.如果待测试数是完整的平方数怎么办?
	如16，可以被4*4；解决方法：嵌套一个if语句比较i和num/i是否相等，如果是，程序只输出一个约数；
	
	for(i=2;（i*i）<num;i++)
		if(num%i==0)
			if(i*i!=num)
				printf("%d is divisible by %d and %d.\n",num,i,num/i);	
			else
				printf("%d is divisible by %d.\n",num,i);

	2.如何知道一个数字是素数？如果num是素数，程序流不会进入if语句
	解决办法：在外循环把一个变量设置为某个值1，然后在if语句中把该值重新设置为0；
	循环完成后，检查该变量是否是1，如果是说明没有进入if语句，该数字就是素数；
	这样的变量通常被称为标记(flag)

	一直以来，C都习惯用int作为标记类型，其实新增的_Bool类型更合适；
	另外头文件stdbool.h下bool类型可替代_Bool类型，用true和false分别替代1和0；

	
	#include<stdio.h>
	#include<stdbool.h>
	int main(void)
	{
		unsigned long num;	//待测试数
		unsigned long n;	//约数
		bool prime;	//素数标记

		printf("Please enter an integer for analysis.\n");
		printf("Enter q to quit.\n");

		while (scanf_s("%lu", &num,1) == 1)
		{
			for (n = 2,prime=true; (n*n) <= num; n++)
			{
				if (num%n == 0) 
				{
					if ((n*n)!=num )
						printf("%lu is divisible by %d and %d.\n", num, n, num / n);
					else
						printf("%lu is divisible by %d.\n", num, n);
					prime = false;		//该数不是素数
				}
			}
			if (prime)
				printf("%lu is prime.\n",num);
			printf("\nPlease enter another integer for analysis.\n");
			printf("Enter q to quit.\n");
		}
		printf("Byebye\n");
		return 0;
	}



	小结：if else
	一般注解：
	形式1：如果expression为真，执行statement部分；
	if(expression)
		statement
	
	形式2：如果expression为真，执行statement1部分，否则执行statement2部分
	if(expression)
		statement1
	else
		statement2

	形式3：如果expression1为真，执行statement1部分，如果expression2为真，执行statement2部分；
	否则执行statement3部分
	if(expression1)
		statement1
	else is(express2)
		statement2
	else
		statement3

	
7.3	逻辑运算符

	if和while语句通常使用关系表达式作为测试条件，有时候多个关系表达式组合起来会很有用
	例如：编写一个程序计算输入一行句子中除了单引号和双引号以外其他字符的数量：
	这种情况下可以使用逻辑运算符，并使用句点（.）标识句子的末尾

	
	#include<stdio.h>
	#define end '.'
	int main(void)
	{
		char ch;
		int m = 0;
		while ((ch=getchar()) != end)
		{
			if (ch != '"'&&ch != '\'')
				m = m + 1;
		}
		printf("There are %d non-quote characters.\n",m);
		return 0;
	}


	逻辑运算符
	&&	与
	||	或
	！	非

	exp1和exp2为两个简单的关系表达式，则
	1.当且仅当exp1和exp2两个都为真时，exp1 && exp2才为真
	2.如果exp1或者exp2为真，则exp1||exp2为真；
	3.如果exp1为假，则!exp为真；反之亦然；

	
7.3.1	备选拼写：iso646.h头文件

	&&	and
	||	or
	!	not

7.3.2	优先级
	！运算符优先级很高，比乘法运算符还高与递增运算符的优先级相同，只比圆括号的优先级低
	&&优先级比||高，两者优先级都比关系运算符低，比赋值运算符高；因此
	表达式：	a>b&&b>c||b>d
	相当于	(a>b)&&(b>c)||(b>d)
	
7.3.3	求值顺序

	除了两个运算符共享一个运算对象情况外，C通常不保证先对复杂表达式中哪部分求值，比如
	m=(5+3)*(9+6);可能是先求值5+3，也可能先计算9+6；

	C把先计算哪部分的决定权留给编译器的设计者，以便对特定系统优化设计；
	但是对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右；
	&&和||运算符都是序列点，所以程序从一个运算对象执行到下一个运算对象之前，所有副作用都会生效；
	C保证一旦发现某个元素让整个表达式无效，便立即停止求值；
	正是由于这些规定，才能写出这样结构的代码：
	while((c=getchar()) != ' ' && c !='\n')
	如上：读取字符直到遇到第一个空格或换行符，第一个式子把读取的值赋给c，后面表达式会用到c的值
	还如：
	if(number!=0&&12/number==2)
		printf("the number is 5 or 6.\n");
	如果number的值是0，那么第一个子表达式为假，且不再对关系表达式求值，这样避免了把0作为除数

	while(x++<10&&x+y<20)
	实际上，&&是一个序列点，保证了在对右侧表达式求值之前，已经递增了x


7.3.4	范围
	&&运算符可以用于测试范围，例如要测试是否在10~100范围内，可以这样写：
	if(range>=90&&range<=100)
		printf("good show.\n");

	而不能写成if(90<=range<=100)		
	//错误写法，语义错误，而不是语法错误；
	编译器不会捕捉这样的问题，会继续执行为 (90<=range)<=100;
	对子表达式90<=range求值，要么是真(1)，要么是假(0)，这两个值都小于100；
	所以不管range值是多少，此表达式都恒为真

	许多代码都用范围测试来确定一个字符是否是小写字母
	if(ch>='a'&&ch<='z')
	但仅对ASCII这样的字符编码有效，但对EBCDIC这样的代码就没用了，移植方法是用ctype.h
	if(islower(ch))

	
7.4	一个统计单词的程序
	编写一个程序读取并报告单词的数量，该程序还可以计算字符和行数；伪代码
	①	读取一个字符
	②	当有更多输入时
	③		递增字符计数
	④		如果读完一个单词，递增单词计数
	⑤		如果读完一行，递增行数计数
	⑥		读取下一个字符
	
	②输入循环模型
	while((ch=getchar())!=stop){…}	这里stop标识输入末尾，可暂时选择文本中不常用字符比如(|)标记
	⑤统计行数：检查换行字符
	④最棘手部分，首先程序需要定义什么是该程序识别的单词；
		用相对简单的方法，把一个单词定义为一个不含空白(没有空格、制表符、换行符)的字符序列
		因此程序读取的第一个非空白字符就是单词的头，到空白字符时候结束；
	判断非空白字符表达式：	c != ' ' && c !='\n' && c != '\t'
	检测空白字符表达式：	c==' ' || c == '\n' || c == 't'
	然而使用ctype.h头文件函数issoace()更简单；isspace(c)为真是空白字符，非空白字符时候!isspace(c)为真
	
	要查找一个单词里是否有某个字符，可以在程序中输入单词的首字符时把一个标记(inword)设置为1，
	可以在此时递增单词计数，然后只要inword为1后续的非空白字符都不记为单词的开始，
	直到下一个空白字符，必须重置标记为0，然后程序准备好读取下一个单词；伪代码：
		如果c不是空白字符，且inword为假
			设置inword为真，并给单词计数
		如果c是空白字符，且inword为真
			设置inword为假

	如果使用布尔类型（_Bool）的变量，通常习惯把变量自身作为测试条件
	用if(inword)代替if(inword==true)
	用if(!inword)代替if(inword==false)
	

	完整代码：
	#include<stdio.h>
	#include<ctype.h>	//为isspace()函数提供原型
	#include<stdbool.h>	//为bool、true、false提供定义
	#define stop '|'	//结束标记符
	int main(vodi)
	{
		char c;				//读入字符
		char prev;			//读入的前一个字符
		int n=0;				//字符数
		int m=0;				//单词数
		int l=0;				//行数
		int pline = 0;			//不完整的行数
		bool inword = false;	//单词标记
		printf("Enter text to be analyzed(| to terminate):\n");
		prev = '\n';//用于识别完整的行
		while ((c = getchar()) != stop)
		{
			n++;//统计字符
			if (c == '\n')
				l++;	//统计行数
			if (!isspace && !inword)
			{
				inword = true;
				m++;	//统计单词数
			}
			if (isspace && inword)
				inword = false;
			prev = c;	//保存字符的值
		}
		if (prev != '\n')
			pline = 1;
		printf("characters=%d,words=%d,lines=%d.\n", n, m, l);
		printf("partial lines=%d.\n", pline);
		return 0;
	}


7.5	条件运算符 ?:

	条件表达式作为if else语句的一种便捷方式，如：
	
	x=(y<0)?-y:y;

	在=和；之间的内容就是条件表达式，该语句的意思是：
	如果y<0，那么x=-y;否则x=y
	
	用if else表达式为：
	
	if(y<0)
		x=-y;
	else
		x=y;


	条件表达式的通用形式如下：
	expression1？expression2：expression3

	如果exp1为真，那么整个表达式的值与exp2的值相同；
	如果exp1为假，那么整个表达式的值与exp3的值相同；

	需要把两个值中的一个赋给变量是，就可以用条件表达式，
	典型的例子是，把两个值中最大值赋给变量：
	
	max=(a>b)?a:b;

	通常条件运算符完成的任务if else也能完成，但是条件运算符代码更简洁紧凑

	示例程序：该程序计算刷给定面积需要多少罐油漆
	基本算法：用总面积除以每罐油漆能刷的面积，但是商店只卖整罐油漆，不会拆分来卖
	所以如果计算结果是1.7，就需要2罐，
	因此，该程序得到带小数的结果时应该进1
	条件运算符常用于这种情况，而且根据单复数分别打印can和cans

	#include<stdio.h>
	#define cover 350	//每罐可刷面积
	int main(void)
	{
		int sq;
		int cans;

		printf("Enter number of square feet to be painted:\n");
		while (scanf_s("%d", &sq) == 1)
		{
			cans = sq / cover;
			cans = cans + ((sq%cover == 0) ? 0 : 1);
			printf("you need %d %s of paint.\n", cans, cans == 1 ? "can" : "cans");
			printf("Enter next square (q to quit):\n");
		}
		return 0;
	}



7.6	循环辅助：continue和break

	一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中所有的语句
	continue和break语句可以根据循环中的测试结果来忽略一部分循环内容，甚至结束循环


7.6.1	continue语句

	3种循环都可以使用continue语句
	执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。
	如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环；
	示例：

	#include<stdio.h>
	int main(void)
	{
		const float MIN = 0.0f;	//最低分边界点
		const float MAX = 100.0f;	//最高分边界点

		float score;		//得分
		float total = 0.0f;		//总分
		int n = 0;			//计数器
		float min = MAX;		//最低分
		float max = MIN;		//最高分

		printf("Enter the first score(q to quit):\n");
		while (scanf_s("%f", &score) == 1)		//输入成绩float类型；非匹配数据退出；
		{
			if (score<MIN || score>MAX)		//输入得分在边界范围外；无效数；
			{
				printf("%0.1f is an invalid value.try again:", score);
				continue;//跳转至while循环的测试条件
			}
			printf("Accepting %0.1f:\n", score);	//显示本次接收数据
			min = (score < min) ? score : min;	//刷新最低分
			max = (score > max) ? score : max;	//刷新最高分	
			total += score;			//计算总得分；用来计算平均分
			n++;				//计数器累计
			printf("Enter next score(q to quit):\n");
			if (n > 0)				//有效记分时输出成绩：
			{
				printf("average of %d score is %0.1f.\n", n, total / n);
				printf("Low=%0.1f,high=%0.1f.\n", min, max);
			}
			else
				printf("No valid score were entered.\n");
		}
		return 0;
	}
	
		
	

	continue部分：筛选出无效的分数，让程序跳过处理有效输入部分的代码，对无效输入不做处理；
	continue该情况下替代了原来的方法：
	①
	if(score<0||score>100)
		{……}
	else
	{……}
	
	②
	if(score>=0&&score<=100){……}
	
	这种情况下，使用continue的好处是减少主语句组中的一级缩进，当语句很长或嵌套多的时候紧凑简洁
	continue还可以用作占位符；如下面的循环读取并丢弃输入的数据，直到读到行末尾：
	while(getchar()!='\n')
		;
	当程序已经读取一行中的某些内容，要跳到下一行开始处时，这种用法很方便，问题是一般很难注意到一个单独分号
	如果使用continue，可读性会更高：
	
	while(getchar()!='\n')
		continue;

	相反的如果用了continue没有简化代码反而更复杂，就不要使用；例如：
	
	while((ch=getchar())!='\n')
	{
		if(ch=='\t')
			continue;
		putchar();
	}
	该循环跳过制表符，并在读到换行符时退出循环，此时不用continue
	更简洁的方法是把if条件反过来使用即可：
	
	while((ch=getchar())!='\n')
	{
		if(ch!='\t')
			putchar();
	}

	
	


7.6.2	break语句
	程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段

	#include<stdio.h>
	int main(void)
	{
		float length, width;
		printf("Enter the length of the rectangle:\n");
		while (scanf_s("%f", &length, 1) == 1)
		{
			printf("length=%0.2f:\n",length);
			printf("Enter its width:\n");
			if (scanf_s("%f", &width, 1) != 1)
				break;
			printf("width =%0.2f:\n",width);
			printf("area=%0.2f:\n", length*width);
			printf("Enter the length of the rectangle:\n");
		}
		printf("Done.\n");
		return 0;
	}


	在for循环中的break，在执行完break语句后会直接执行循环后面的第一条语句，连更新部分也跳过
	嵌套在内层的break只会跳出包含它的当前循环，要跳出外层循环还需要一个break

	
	
	
7.7	多重选择：switch和break
	
	使用条件运算符和if else语句很容易编写二选一的程序
	然而程序有时候需要在多个选项中进行选择，可以用if else if……else来完成
	但是使用switch语句就可以更方便的解决这个问题
	示例：该程序读入一个字母，然后打印出与该字母开头的动物名

	
	#include<stdio.h>
	#include<ctype.h>
	int main(void)
	{
		char ch;
		printf("Give me a letter of the alphabet,and i'll give an animal name beginning with that letter.\n");
		printf("Please type in a letter;type # to end my ect.\n");
		while ((ch = getchar()) != '#')
		{
			if ('\n' == ch)
				continue;
			if (islower(ch))
				switch (ch)
				{
				case 'a':
					printf("argali,a wild sheep of Asia.\n");
					break;
				case 'b':
					printf("babirusa,a wild pig of Malay.\n");
					break;
				case 'c':
					printf("coati,racoon like mammal.\n");
					break;
				default:
					printf("that's a stumper!\n");
				}
			else
				printf("I recognize only lowercase letters.\n");
			while (getchar() != '\n')	//跳过输入行的其余部分只读取首字母
				continue;
			printf("Please type another letter or a #.\n");
		
		}
		printf("bye!\n");
		return 0;
	}



7.7.1	switch语句

	按照示例分析switch工作原理：
	对紧跟在关键字switch后圆括号中的表达式求值（ch）
	然后程序扫描标签（case 'a':等等）列表，直到发现一个匹配值为止，程序转至那一行
	如果没有匹配的标签怎么办？如果有default标签行，就转到该行，没有就继续执行switch后面的语句。
	break语句在其中起什么作用？
	它让程序离开switch语句，跳到switch语句后面的下一条语句。
	如果没有break语句，就会从匹配标签开始执行到switch末尾。（即从匹配标签开始把后续标签都执行一遍）
	
	break语句可用于循环和switch语句中，但是continue只能用于循环中；
	尽管如此，如果switch语句在一个循环中，continue便可以作为switch语句的一部分；
	这种情况下就像其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分

	一般C语言的case一般都指定一个值，不能使用一个范围
	switch在圆括号中的测试表达式的值应该是一个整数值，包括char类型；
	case标签必须是整数类型(包括char类型)的常量或整形常量表达式，不能用变量作为case标签

	switch构造如下：
	
	switch(整形表达式)
	{
		case 常量1：
			语句
		case 常量2：
			语句
		default：
			语句
	}


7.7.3	多重标签

	
	switch(ch)
	{
		case 'a':
		case 'A':
			a++;
			break;
		case 'b':
		case 'B':
			b++;
			break;
		default:
			break;
	}
	

	假设ch是字母b，switch语句会转到标签为case 'b'的位置；
	由于该标签没有关联break语句，所以程序流直接执行下一条语句，即b++;
	如果ch字母是B，程序流直接定位到case'B',
	本质上两个标签指的都是相同的语句。
	
	严格地说，case 'B'语句下的break并不重要，因为即使删除这条break程序流会接着执行default：break；
	但是从习惯上建议保留这条break，方便以后再添加新的case，防止遗漏break；

	在该例中，如果使用ctype.h系列的toupper()函数就可以避免使用多重标签，在测试前把字母转换成大写
	如：
	ch=toupper(ch);
	或者
	
	switch(toupper(ch));

	
7.7.4	switch和 if else

	如果是浮点类型的变量或表达式来进行选择，就无法使用switch
	如果根据变量在某范围内决定程序流的去向，switch也很麻烦，这种时候用if更方便
	
	
7.8	goto 语句

	goto语句有两部分：goto和标签名
	标签的命名遵循变量命名规则，如：
	goto part2；
	要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该语句标签名后紧跟一个冒号开始
	part2：printf("done.\n");

7.8.1	避免使用goto
	原则上，根本不用在C程序中使用goto语句	























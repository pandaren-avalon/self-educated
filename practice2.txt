【C primer Plus自学】

【第一章】初识

C语言历史和特性；
程序编写步骤；
编译器和链接器；
C标准；

1.4 	计算机能做什么
	计算机组成：
	①中央处理单元 CPU；
	②随机存储内存RAM；
	③永久内存存储 硬盘；
	④支持设备、外设等；

	CPU：	从内存获取并执行一条指令；然后再下一条；
		CPU有自己的小工作区；若干个寄存器；寄存器可存储一个数字；
		一个寄存器存储下一条指令的内存地址（寄存器a）；
		CPU用该地址来获取和更新下一条指令；
		CPU在获取指令后，在另一个寄存器（寄存器b）存储该指令；并更新寄存器a的下一个地址；
	CPU能理解的指令有限（指令集）多数用于将一个数从一个位置移动到另一个位置；
	存储在计算机内的所有内容都是数字；
	计算机程序最终都必须以数字指令码来表示；
	
	计算机工作原理：
	如果希望计算机做某些事：
	1.必须为其提供特殊的指令列表（程序）；确切的告诉它要做的事以及如何做；
	2.必须用计算机直接明白的语言（机器语言）创建程序；
	例如：两数相加；
		①从内存位置2000上，把一个数字拷贝到寄存器1；
		②从内存位置2004上，把一个数字拷贝到寄存器2；
		③把寄存器2和寄存器1中的内容相加，将结果存在寄存器1中；
		④将寄存器1中的内容拷贝到内存位置2008；

1.5 	高级计算机语言和编译器
	高级编程语言在计算机看来是一堆无法理解的无用数据；
	编译器：将高级程序语言翻译成机器语言指令集；

1.6 	C语言标准：C89/C90  C99  C11

1.7 	使用C语言的7个步骤
	1.定义程序目标：用一般术语表达；比如：
		程序需要那些信息（输入）；
		程序需要进行哪些计算和控制（运行）；
		程序应该报告什么信息（输出）；
	2.设计程序：比如：用户界面？组织程序？目标用户？如何表达数据？数据处理方法？
	3.编写代码：用文本编辑器创建源代码；
	4.编译：
		①将源代码转换成可执行代码（机器语言）；
		②将源代码和库代码合并成最终程序（链接器），生成可执行文件；
	5.运行程序：
		①常规环境（Windows带命令提示符、UNIX、LinUX）输入可执行文件名；
		②集成开发环境（IDE）菜单选项或者特殊键（单双击）执行；
	6.测试、调试程序：查找并修复程序错误（debug）;
	7.维护和修改代码；
	*程序越庞大越复杂，事先定义和程序设计环节工作量越大；

1.8 	编程机制
	源代码――编译器――目标代码――链接器――可执行代码
	(.c文件)		(.obj文件)	   库代码       (.exe文件)	
	  code		 目标文件	   启动代码    应用程序文件

【第二章】概述
运算符：=
函数main()、printf()
编写一个简单C程序；
创建整型变量，为其赋值并打印；
换行字符；
注释；多个函数程序；
关键字；


	

2.1
	#include<stdio.h>		//包含另一个文件；
	int main(void)		//主函数名；
	{			//表面函数开始；
		int a;		//声明变量a；
		a=1;		//赋值表达式；
		printf("%d",a);	//调用一个函数printf();	
		return 0;		//返回值；
	}			//函数结束；
2.2
	1. #include指令和头文件
	#include<stdio.h>相当于将stdio.h文件中的所有内容输入该行；实质为复制粘贴；方便共享许多程序共有信息；
	#include是一条C语言预处理信息；#表明C预处理器在编译器接手前处理这条指令；
	通常在C程序顶部信息集合，称为头文件；
	特定C实现的文档中应包含对C库函数的说明，确定了使用哪些函数需要用到哪些头文件；

	2. main()函数
	C程序一定从main()函数开始执行，除了main()函数可以任意命名其他函数名；
	int是main()函数的返回类型，返回整数给操作系统；
	int main(void)：	()内包含了一些传入函数的信息，若不需要传递任何信息，()内用单词void；

	3. 注释  // 注释到本行结尾   /*……*/ 注释掉中间部分内容；
	
	4. 花括号{}标记函数开始与终结；

	5. 声明
	int a;	这行代码完成两件事；①声明函数中有个变量a；②int表明变量a是个整数；
		int是一种数据类型，编译器以此为变量a在内存中分配存储空间；
		a  是一种标识符，是一个变量、函数或者其他实体的名称；
		C语言中所有变量都必须声明后才能使用；
	命名：尽量使用有意义的变量名；编译器能识别前63字符，可以用大小写数字下划线命名，第一位不能用数字；

	6. 赋值：
	a=1；	在执行声明时，编译器在内存中为变量a预留了空间，赋值时将值存储在预留位置；
		赋值表达式为从右侧将值赋到左侧；
		C语言是通过赋值运算而不是赋值语句完成操作；
	
	7. printf()函数
		printf()括号中的内容为main()函数传递给printf()函数的信息；()内信息为函数实际参数；
		①实际参数：传递给函数的特定值；
		②形式参数：函数中用于储存变量的值；
	
	8. return语句
		int main(void)函数中的int表明main()函数应返回一个整数；有返回值的函数需要有return语句；
		return语句是一种跳转语句；

【练习题1.】
	编写一个程序，把你的姓名打印在一行，输出如下：

	Gustav Mahler	//第1次打印的内容
	Gustav 		//第2次打印的内容
	Mahler		//仍是第2次打印的内容
	Gustav Mahler	//第3、4此打印的内容

	#include<stdio.h>
	int main(void)
	{
		printf("Gustav Mahler\n");
		printf("Gustav\nMahler\n");
		printf("Gustav ");
		printf("Mahler\n");
		getchar();
		return 0;
	}

【练习题2.】
	编写一个程序，打印你的姓名和地址。

	#include<stdio.h>
	int main(void)
	{
		printf("Name:***\nAddress:Room***, unit***, building**,***Road,***District,***City,***Province\n");
		getchar();
		return 0;
	}

【练习题3.】
	编写一个程序，把你的年龄转换成天数，并显示这两个值，不考虑闰年问题。

	#include<stdio.h>
	int main(void)
	{
		int age, day;
		age = 18;
		day = age * 365;
		printf("Your age:%d\nConvert age to days:%d\n", age, day);
		getchar();
		return 0;
	}

【练习题4.】
	编写一个程序，生成以下输出;除了main()函数以外，自定义两个函数；
	hello world
	hello world
	hello world
	i'm good

	#include<stdio.h>
	void hello(void){printf("hello world\n");}
	void good(void){ printf("i'm good\n"); }
	int main(void) 
	{
		hello(); 
		hello();
		hello();
		good();
		getchar();
		return 0;
	}

【练习题5.】
	编写一个程序，生成以下输出；除了main()函数外，自定义两个函数br()和ic()分别为“Brazil,Russia”;和“India,China”;
	各依次调用并打印一次，其余内容在main()函数中完成。

	Brazil,Russia,India,China
	India,China，
	Brazil,Russia

	#include<stdio.h>
	void br(void) { printf("Brazil,Russia"); }
	void ic(void) { printf("India,China"); }
	int main(void) 
	{
		br();
		printf(",");
		ic();
		printf("\n");
		printf("India,China,\n");
		printf("Brazil,Russia");
		getchar();
		return 0;
	}

【练习题6.】
	编写一个程序，创建一个整型变量toes，并将toes设置为10.程序中还要计算toes的两倍和平方并打印和描述；

	#include<stdio.h>
	int main(void) 
	{
		int toes;
		toes = 10;
		printf("toes=%d\n2*toes=%d\ntoes*toes=%d\n", toes, 2 * toes, toes*toes);
		getchar();
		return 0;
	}

【练习题7.】
	编写一个程序，生成以下格式输出；自定义一个函数，调用一次打印一次“smile!”
	smile!smile!smile!
	smile!smile!
	smile!
	
	#include<stdio.h>
	void smile(void) { printf("smile!"); }
	int main(void) 
	{
		smile(); 
		smile();
		smile();
		printf("\n");
		smile();
		smile();
		printf("\n");
		smile();
		printf("\n");
		getchar();
		return 0;
	}

【练习题8.】
	编写一个函数，调用one()的函数打印“one”调用two()函数打印“two”，要求输出如下：
	starting now:
	one
	tow
	three
	done!


	#include<stdio.h>
	void one(void) { printf("one"); }
	void two(void) { printf("two"); }
	int main(void) 
	{
		printf("starting now\n");
		one();
		printf("\n");
		two();
		printf("\n");
		printf("three\n");
		printf("done!\n");
		getchar();
		return 0;
	}

【第三章】数据和C

关键字int、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary
运算符 sizeof()
函数 scanf()
整数类型和浮点数类型的区别；


3.1	
	#include<stdio.h>
	int main(void)
	{
		float weight;	//浮点数变量
		float value;
		float prince;
		prince=1700.0;
		printf("please enter your weight in pounds: ");
		scanf_s("%f",&weight);	//scanf_s()读取键盘输入；%f浮点数占位符
		value=prince*weight*14.5833;	//变量与常量；
		printf("your weight in platinum is worth $%.2f.\n",value);	//%.2f .2控制精度
		printf("if platinum princes drop,eat more maintain your value.\n");
		getchar();
		getchar();
		return 0;
	}

3.3
	【数据类型关键字】

            【K&C】		【C90】		【C99】

	int		signed		_Bool
	long		void		_Complex
	short				_Imaginary
	unsigned
	char
	float
	double

	【位、字节和字】

	最小的存储单元是位(bit)，可以存储0或1；
	字(byte)节是常用的计算机存储单位;
	1字节=8位 1byte=8bit;
	既然1位可以表示0或者1，8位字节就有256种可能组合(2的8次方)；
	通过二进制编码，便可表示0-255的整数或一组字符；
	字(word)、计算机进行数据处理时，一次存取、加工和传送的数据长度称为字(word)；
	字长越大，数据转移越快；允许访问的内存也更多；

	【整数和浮点数】
	整数：2进制存储；最高位设置为符号位，1代表负数(负数补码=负数反码)，0代表正数(正数原码=反码=补码)；
	浮点数：与整数存储方案不同；采用小数部分+指数部分来表示；

3.4
	【int类型】（有符号整型）
		
	int类型的值必须是整数，可以是正整数、负整数或0，取值范围随系统，ISO C规定最小16位(-32768~32767)；
	
	1.声明int变量	
	int a;
	int b;
	int a,b;

	给变量提供值的方法：

	①赋值：
		int a;
		a=1;
	②函数获取：
		int a;
		scanf_s("%d",&a);
	

	2.初始化变量：C语言中可以直接在声明中给变量赋一个初始值
		int a=1;
	
	声明其实已经位变量创建和标记了存储空间，若初始化在声明里，则为其直接指定初始值；

	3.int类型常量
	C语言把不含小数点和指数的数作为整数，如22和-44是整型常量，但22.0和2.2E1则不是；
	C语言把大多数整型常量视为int类型，但是非常大的整数除外（long常量）；
	
	4.打印 int 值
	可以使用printf()函数；%d称为"转换说明”,它指定了printf()函数应使用什么格式来显示一个值；
	使用printf()函数时，要确保转换说明数量%d与待打印值的变量数相等，若无指定，将读取内存中任意值

	5.八进制和十六进制
	计算机如何10000是十进制十六进制还是二进制？C语言中用特定的前缀表示；
	0x或者0X前缀表示十六进制  	例如十进制16等于十六进制0x10
	0前缀表示八进制；		例如十进制16等于八进制020
	
	6.显示八进制和十六进制；
	%d――十进制
	%o――八进制
	%x――十六进制
	另外若要显示后两种进制数的前缀0、0x或0X，分别使用%#o、 %#x、 %#X，例如打印十进制的100：

	#include<stdio.h>
	int main(void)
	{
		int a = 100;
		printf("dec=%d,	octal=%o,	hex=%x\n", a, a, a);//十进制、八进制、十六进制
		printf("dec=%d,	octal=%#o,	hex=%#x,	hex=%#X\n", a,a,a,a);
		getchar();
		return 0;
	}

	【其他整数类型】：

	short int 类型(或简写为short)用于较小数值的场合以节省空间，是有符号类型；
	long  int 类型(或简写为 long)用于较大数值的场合，也是有符号类型；
	long long int (或简写为 long long)占用64位以上的更大数值场合，也是有符号类型；
	unsigned int  (或简写为unsigned)只用于非负数值的场合，
		例如16位取值范围为0~65535，而非-32768~32767，是用符号位拿来存二进制位；
	在任何有符号类型前面添加关键字signed，可强调使用有符号类型的意图。

	1.声明其他整数类型：与int相同；

	2.int long short 只规定了占位大小关系，因为对16位机或者32位机甚至64位机对应的取值范围不同；
	   通常个人PC最常见设置 long long占64位，long占32位，short占16位，int占16或32位(依计算机字长)；
	  ① 当取值范围在int内，尽量不用long，，使用long类型会减慢运算速度；其他关键字类推；
	  ②若需要从32位机移植程序到16位机的情况，若有当需要用到32位数字时，用long，其他关键字类推；

	3.long 和long long
	通常程序中使用的数字会被存储为int类型；
	若超出范围，编译器依次视其为long----unsigned long----long long-nusigned long long
	特定情形下需要用long存储一个小数字，可以加个后缀l或者L 大写字母易区分1与l；如7L；9LL；
	
	整数溢出
	#include<stdio.h>
	int main(void)
	{
		int a=2147483647;
		unsigned int b=4294967295;
		printf("%d %d %d\n",a,a+1,a+2);
		printf("%u %u %u\n",b,b+1,b+2);
		getchar();
		return 0;
	}

	观察结果，溢出后数字从定义类型范围的最小始开始
	最小看取值范围int、 unsigned int
	本例中int为32位（+标识符加31位数字，二进制下为+2147483647）范围(-2147483648~2147483647)
	所以unsigned范围为（0~4294967295）例题中a+1和b+1数字溢出后从最小处重新开始取值；

	4.打印short、long、long long和unsigned
	short		――%hd；（%hx；%ho）	//十进制、十六进制、八进制；
	long		――%ld；（%lx；%lo）	//常量后缀在转换说明里只能用小写；
	long long		――%lld；（%lldx;%lldo）
	
	unsigned		――%u；

	nusigned short	――%hu;
	unsigned long	――%lu；
	nusigned long long	――%llu；
	
	#include<stdio.h>
	int main(void)
	{
		unsigned a = 3000000000;	//int为32位下系统；
		short b = 200;
		long c = 65537;
		long long d = 12345678908642;

		printf("a=%u not %d \n", a, a);
		printf("b=%hd and %d \n", b, b);
		printf("c=%ld not %hd \n", c, c);
		printf("d=%lld not %ld", d, d);

		getchar();
		return 0;
	}
	
	①第一行输出：%d和%u的区别在于signed和unsigned的区别，两个输出不同的值在内存中的二进制排列相同；
	   但是在signed读取的时候，最高位的数字被读取成符号位；unsigned则直接为数字一部分；
	   在两个数集的交集部分，则两者输出结果相同；
	②第二行输出：输出结果相同，C编译器把short类型的值自动转换成int类型的值；int类型参数传递快效率高；
	③第三行输出：使用h修饰符可以显示较大整数被截断成short类型值的情况；
	   65537在32位里二进制是0000 0000 0000 0001 0000 0000 0000 0001 %hd只会查看后16位，所以显示为1；
	④同上；

	综上，不管是unsigned、整数溢出或者转换说明的出错，其实质都是定义数集合的范围不一样导致的；
	存储在内存中的二进制数，对不同的定义和转换说明，读取到的排列序，即在这个定义集合里的值都不一样；
	计算机能存储的状态就是0和1的有限组合，同样的组合能根据用户的定义给出更多的不同值的表达；

	【char类型】

	char类型用于存储字符，但从技术层面看，char是整数类型，char实际上存储的是整数而不是字符。

	ASCII编码――字符的本质：

	#include<stdio.h>	
	int main(void)
	{
		int i;
		for (i = 0; i <= 127; i++) 	//0-127或者0-255ASCII拓展表
			printf("%d %c\n", i, i); 
		getchar();
		return 0;
	}
	C语言把1字节定义为char类型占用的位数(bit)，因此16位或者32位系统都可以使用char类型

	1.声明char类型变量
	char a;
	char a,b;
	
	2.字符常量和初始化
	char a;
	char a='A';	//正确赋值字符初始化常量，A是字符；
	char a=A;		//错误，此时A是一个变量；
	char a="A"	//错误，此时"A"是一个字符串；
	char a=65; 	//前提是系统使用ASCII码，不推荐；

	*C语言将字符常量视为int类型而非char类型；
	例如int为32位，char为8位，可以将4个独立的ASCII编码储存在32位存储单元中;
	试运行下列代码：

	#include<stdio.h>
	int main(void)
	{
		char a='FATE';
		printf("%c\n", a);
		getchar();
		return 0;
	}
	实际这样的字符常量赋给char类型，只有最后8位有效，所以显示的是字母E；

	再试试下面的代码:

	#include<stdio.h>
	#include<windows.h>
	int main(void)
	{
		char a;
		scanf_s("%c", &a);
		printf("%c\n", a);
		Sleep(2000);
		return 0;
	}
	尝试输入多个字母，显示的仍为第一个输入的字母；

	3.非打印字符/控制字符
	如何表达这些字符
	①用ASCII码	char beep=7;
	②转义序列使用转义字符表达	char nerf='\n';
	\a	警报
	\b	退格
	\f	换页
	\n	换行
	\r	回车
	\t	水平制表符
	\v	垂直制表符
	\\	反斜杠\
	\'	单引号
	\"	双引号
	\?	问好
	\0oo	八进制值(oo八进制数，即每个o可表示0~7中的一个数)
	\xhh	十六进制值(hh十六进制数，即每个h可表示0~f中的一个数)
	
	4.打印字符

	#include<stdio.h>	
	int main(void)
	{
		char ch = 'C';
		printf("%c is %d", ch, ch);
		getchar();
		return 0;
	}


	printf()函数用%c打印字符，printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式:
	
	存储方式：  ch: 0100 0011（ASCII码中字符C）
	读取方式	%c――输出图形字符 C
		%d――输出十进制值 67
	
	5.有符号还是无符号
	根据C90标准，C语言允许在关键字char前面使用signed(-128-127)或unsigned(0-255);
	这在用char类型处理小整数时很有用，如果只用处理char处理字符，则无需任何修饰符；

	【_Bool类型】

	C99标准添加表示布尔值，即逻辑true和false；C语言用1和0表示，原则上它仅占用1位存储空间

	【可移植类型：stdint.h和inttypes.h】

	C语言提供了许多整数类型，但是某些型名在不同系统中功能不一样；
	C99新增的两个头文件；以却把C语言的类型在各个系统中的功能相同；
	stdint.h头文件：
	精确宽度整数类型，如int32_t表示整数类型的宽度正好是32位；
	最小宽度类型，如int_least8_t表示可容纳8位有符号整数值的类型中宽度最小的类型的一个别名；
	最快最小宽度类型，如int_fast8_t定义为系统中对8位有符号值而言运算最快的整数类型的别名；
	最大整数类型，如intmax_t,可存储任何有效的有符号的整数，unitmax_t表示最大无符号整数类型；
	
	C99和C11不仅提供可移植的类型名，还提供相应的输入和输出；
	比如printf()打印特定类型时，要求对应的转换说明匹配，int32_t类型的值，有%d、%ld的区分使用；
	C标准针对这情况，提供了一些字符串宏来显示可移植类型，如inttypes.h头文件中定义了PRId32字符串宏；
	范例：

	#include<stdio.h>	
	#include<inttypes.h>//支持可移植类型
	int main(void)
	{
		int32_t m32;	//声明m32为一个32位有符号整型变量;
		m32 = 45933945;
		printf("m32=%d\n", m32);
		printf("m32=%"PRId32"\n",m32);
		getchar();
		return 0;
	}
	 
	在最后一行printf()中，参数PRId32被定义在inttypes.h中的“d”替换，所以输出相等；

	【float、double 和 long double】

	浮点数的表示类似于科学记数法――指数记数法(科学记数法在计算机中的写法)；例：
	
	数字		科学记数法	指数记数法
	1000000000	1.0*10^9		1.0e9
	123000		1.23*10^5		1.23e5
	322.56		3.2256*10^2	3.2256e2
	0.00056		5.6*10^-5		5.6e-5
	
	C标准规定，float类型必须至少能表示6位有效数字，取值范围10e-37~10e37
	一般系统储存一个浮点占用32位，其中8位表示指数的值和符号，24位表示非指数部分(尾数/有效数)及其符号；
	C语言提供的另一种浮点类型是double(双精度)，至少能表示10位有效数字，一般占用64位；

	1.声明浮点型变量 与整型变量相同；

	2.浮点型常量：
	有符号的数字(包括小数点)后面跟e或者E最后是一个有符号数表示10的指数，如：
	-1.56E+12;
	2.87e-3;
	正号可以省略；不要在浮点型常量中间加空格；
	可以没有小数点如2E5或没有指数部分如19.28；但不能同时省略两者；
	可以省略小数部分如3.E16或整数部分如.45E-6,但是不能同时省略两者；
	常量示例：
	3.14159
	.2
	4e16
	.8e-5
	100.
	
	默认情况下，编译器假定浮点型常量是double类型的精度，比如
	float some;
	some=4.0*2.0;
	通常4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘机截断成float宽度；
	这样计算精度更高，但会减慢程序运行速度，所以在浮点数后面加上f或者F可以覆盖默认设置；
	使用l或L后缀可以使数字称为long double类型；没有后缀的浮点型常量是double类型；
	
	C99添加了一种新的浮点常量格式，用十六进制表示浮点型常量
	在十六进制数前加上十六进制前缀(0x或0X)，用p或者P分别代替e和E，用2的幂代替10的幂（P记数法）
	如 0xa.1fp10
	十六进制下,a等于十进制10，.1f是1/16加上15/256(f等于10进制15)，p10是2^10即1024；
	0xa.1fp10表示的十进制值为（10+1/16+15/256）*1024=10364.0

	3.打印浮点值
	printf()函数使用%f转换说明打印float和double类型浮点数；
	用%e打印指数记数法的浮点数；如果系统支持十六进制格式的浮点数，可用a或A分别代替e和E；
	打印long double使用 %Lf、%Le或者%La转换说明；
	给那些未在原型中显式说明参数类型的函数传递参数时，C编译器会把float类型的值自动换成double类型；
	例：两种方式显示float类型的值
	
	#include<stdio.h>	
	int main(void)
	{
		float a = 32000.0;
		double b = 2.14e9;
		long double c = 5.32e-5;
		printf("a=%f = %e\n",a, a);		//a=32000.000000=3.200000e+04
		printf("hexadecimal:\na = %a\n\n",a);	//a=0x1.f400000000000p+14
		printf("b=%f = %e\n", b, b);		//b=2140000000.000000=2.140000e+09
		printf("c=%Lf = %Le\n", c, c);		//c=0.000053=5.320000e-05
		getchar();
		return 0;
	}
	
	4.浮点值的上溢和下溢；

	①上溢范例：
	#include<stdio.h>	
	int main(void)
	{	
		float big = 3.4e38*100.0f;
		printf("%e\n", big);		//输出结果：inf或者infinity无穷大，上溢；
		getchar();
		return 0;
	}
	
	C语言规定当计算导致数字过大，超过当前类型能表达的范围时，给变量赋一个表示无穷大的值；
	
	②下溢范例：
	#include<stdio.h>	
	int main(void)
	{	
		float big = 0.1e-44/2;
		printf("%e\n", big);		//输出结果0.000000e+00
		getchar();
		return 0;
	}
	
	C语言把损失了类型全精度的浮点数称为‘低于正常的浮点值’
	
	还有另一个特殊的浮点值NaN(not a number);
	例如给asin()函数传递一个值，该函数返回一个角度，该角度的正弦就是传入的函数的值；
	但正弦值不能大于1，因此如果传入的参数大于1，该函数的行为是未定义的，函数返回NaN；

	演示舍入错误：

	#include<stdio.h>	
	int main(void)
	{	
		float a, b;
		a = 2.0e20 + 1.0;
		b = a - 2.0e20;
		printf("%f", b);	//输出：4008175468544.000000
		getchar();
		return 0;
	}
	
	原因为计算机缺少足够的小数位来完成正确运算；
	2.0e20 是2后面有20个0；如果把该数加1，那么发生变化的是第21位，要正确计算，程序至少要存储21位数字；
	而float类型的数字通常只能存储按指数比例缩小或放大的6或7位有效数字；

	显示精度问题

	#include <stdio.h>	
	int main()
	{
	float a;
	double b;
	a=3.1415926535897932;
	b=3.1415926535897932;	
	printf("%.15f",a);		//输出结果a=3.141592741012573;".15"表示保留小数点后15位
	printf("%.15lf",b);		//输出结果a=3.141592653589793
	getchar();			
	return 0;
	}

	【复数和虚数类型】

	3种复数类型，float_Complex、double_Complex、long double_Complex
	3种虚数类型，float_Imaginary、double_Imaginary、long double_Imaginary
	
	【其他类型】
	
	数组、指针、结构和联合等

	指针――指向变量或其他数据对象位置，如scanf()函数里用到的前缀&，告诉函数把数据放在何处；
		
	【类型大小】
	如何知道当前系统的指定类型大小是多少？%zd 或者%u %lu;

	#include<stdio.h>
	int main(void)
	{
		printf("int size =%zd bytes\n", sizeof(int));
		printf("short size =%zd bytes\n", sizeof(short));
		printf("long size =%zd bytes\n", sizeof(long));
		printf("long long size =%zd bytes\n", sizeof(long long));
		printf("unsigned size =%zd bytes\n", sizeof(unsigned));
		printf("char size =%zd bytes\n", sizeof(char));
		printf("float size =%zd bytes\n", sizeof(float));
		printf("double size =%zd bytes\n", sizeof(double));
		printf("long double size =%lu bytes\n", sizeof(long double));
		getchar();
		return 0;
	}
	
3.5
	【合理选用变量类型】

	int a=3			//正确
	int b=3.0			//不推荐；
	int c=12.99		//取值C为12，int截断小数部分，精度丢失严重
	float d=3.1415926536	//损失精度；float只保证前6位精度，编译器警告；
	
3.6	【参数与陷阱】

	printf() 和 scanf()与一般函数不同，他们的参数个数是可变的；
	第一个字符串的转换说明与后面的参数需一一对应；
	程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹配；
	错误示例：
	#include<stdio.h>
	int main(void)
	{
		int m = 4;
		int n = 5;
		float f = 7.0f;
		float g = 8.0f;
		printf("%d\n", n, m);		//参数太多
		printf("%d %d %d\n", n);	//参数太少
		printf("%d %d\n", f, g);	//转换说明类型不匹配
		getchar();
		return 0;
	}
		
3.7	【转义序列】
	
	#include<stdio.h>
	int main(void)
	{
		float salary;
		printf("\aEnter your salary:");	
		printf(" $________\b\b\b\b\b\b\b");
		scanf_s("%f",&salary);
		printf("\n\t$%.2f a month is $%.2f a year.",salary,salary*12.0);
		printf("\rGee!\n");
		getchar();
		getchar();
	}

	
	最初，printf()语句把输出发送到一个叫做缓冲区的中间存储区域，然后再发送到屏幕上；
	当缓冲区满、遇到换行字符或者需要输入的时候，刷新缓冲区；
	(从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区；)
	旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示任何内容，等待用户输入；
	在这种情况下，可以在示例中第一行输出末尾加入换行字符\n刷新缓冲区。

3.8	计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大差别；
	即使两个32位存储单元存储的位组合完全相同，但一个解释为float类型，另一个解释为long类型；
	这两个相同的位组合表示的值也完全不同；举例：
	假设一个位组合表示float类型的数256.0，如果将其解释为long类型，则值是113246208；
	#include<stdio.h>
	int main(void)
	{
		float a;
		a = 256.0;
		printf("%.1f = %lld",a,a);	//VS2017输出为long long类型4643211215818981376
		getchar();
		getchar();
	}

【练习题1.】
	通过试验(编程验证)观察系统如何处理整数上溢、浮点数上溢和下溢的情况；

	#include<stdio.h>
	int main(void)
	{
		int a;
		float b,c;
		a=1000000000000000;
		b=3.5e+60;
		c=1/b;
		printf("%d\n",a);
		printf("%f\n",b);
		printf("%f\n",c);
		getchar();
		return 0;
	}

【练习题2.】
	编写一个程序，要求提示输入一个ASCII码值(如，66)，然后打印输入的字符；

	#include<stdio.h>
	int main(void)
	{
		int ASCII;
		printf("输入一个ASCII可打印码值(33-127): ");
		scanf_s("%d",&ASCII);
		printf("%c",ASCII);
		getchar();
		getchar();
		return 0;
	}

【练习题3.】
	编写一个程序，发出一声警报，然后输出下面文本：“what was that!”
	
	#include<stdio.h>
	int main(void)
	{
		printf("\awhat was that!\n");
		getchar();
		return 0;
	}

【练习题4.】
	编写一个程序，读取一个浮点数，先打印成小数点形式，再打印成指数形式，如果系统支持，再打成P记数法；
	按以下格式输出：

	Enter a floating-point value: 64.25
	fixed-point notation: 64.250000
	exponential notation: 6.425000e+01
	p notation: 0x1.01p+6

	#include<stdio.h>
	int main(void)
	{
		float pr;
		printf("Enter a floating-point value: ");
		scanf_s("%f", &pr);
		printf("fixed-point notation: %lf\n", pr);
		printf("exponential notation: %e\n", pr);
		printf("p notation: %a\n", pr);
		getchar();
		getchar();
		return 0;
	}

【练习题5.】
	一年大约有3.156*10^7秒。编写一个程序，提示用户输入年龄，然后显示该年龄对应的秒数；

	#include<stdio.h>
	int main(void)
	{
		double sec;
		float age;	
		printf("Enter your age: ");
		scanf_s("%f", &age);
		sec = age * 3.156e+7;
		printf("your ages change to sec = %e", sec);
		getchar();
		getchar();
		return 0;
	}

【练习题6.】
	1个水分子的质量约为3.0*10^-23克，1夸脱水大约是950克，输入水的夸脱数，求水分子数量；

	#include<stdio.h>
	int main(void)
	{
		double qty;	//水分子数量
		double m;
		m = 3.0*10e-32;	//每个水分子的质量；
		float quarts;	//输入的水的夸脱数；
		printf("Enter the number of quarts for water ");
		scanf_s("%f",&quarts);
		qty = quarts * 950 / m;
		printf("there are %e of water molecules", qty);
		getchar();
		getchar();
		return 0;
	}

【练习题7.】
	1英寸相当于2.54厘米。编写一个程序，输入身高(英寸)，然后显示厘米单位身高。

	#include<stdio.h>
	int main(void)
	{
		float height;	//身高cm
		float inch;		//身高in
		printf("Enter your height by inch: ");
		scanf_s("%f", &inch);
		height = inch * 2.54;
		printf("your height is %.1f cm", height);
		getchar();
		getchar();
	}

【练习题8.】
	编写一个程序，用户输入杯数，以其他单位容量显示等价容量；
	1品脱=2杯；1杯=8盎司；1盎司=2汤勺；1汤勺=3茶勺；
	
	#include<stdio.h>
	int main(void)
	{
		float pint, cup, oz, tbsp, tsp;
		printf("Enter the number of cup: ");
		scanf_s("%f", &cup);
		pint = 0.5*cup;
		oz = 8 * cup;
		tbsp = 2*oz;
		tsp = 3*tbsp;
		printf("%.2f cup=%.2f pint\n", cup,pint);
		printf("%.2f cup=%.2f oz\n",cup,oz);
		printf("%.2f cup=%.2f tbsp\n",cup,tbsp);
		printf("%.2f cup=%.2f tsp\n",cup,tsp);
		getchar();
		getchar();
		return 0;
	}
	
【总结】

数据与转换说明：
	关键字		声明/初始化		十进制	八进制		十六进制	
整型	int		int a=1;			%d;	%o;(%#o);		%x;%#x 或%#X;
	unsigned		unsigned a=1;		%u;

	short		short a=1;			%hd;	%ho;		%hx
	unsigned short	unsigned short a=1;		%hu
	long		long a=1L;		%ld;	%lo;		%lx
	unsigned long	unsigned long a=1uL;	%lu
	long long 		long long a=1LL;		%lld
	unsigned long long  unsigned long long a=1ull;	%llu

	关键字		声明/初始化		十进制	指数记数法	
浮点型	float		float a=3.14f		%f	%e	
	double		double=3.14		%f	%e
	long double	long double=3.14L		%f	%e

	关于本机C语言整型数字取值范围：
	8位(bit)	256个数	【char】占用1字节长度；1字节的整型 unsigned (0~255)  signed数字轴左移一半
	16位	256^2个	本机 【short】占用2字节长度；unsigned(0~65535)signed数字轴左移一半
	32位	256^4个	本机【int】【long】占用4字节长度；unsigned(0~4294967295)signed数字轴左移一半
	64位	256^8个	本机【long long】占用8字节长度；unsigned(0~18446744073709551615)signed数字轴左移一半

代码验证如下：
	#include<stdio.h>
	int main(void)
	{
		int a = 2147483647;
		unsigned b = 4294967295;
		short c = 32767;
		unsigned short d = 65535;
		long e = 2147483647;
		unsigned long f = 4294967295;
		long long g = 9223372036854775807;
		unsigned long long h = 18446744073709551615;
		char ch = 'T';
		float j = 3.14159265358979323846;
		double k = 3.14159265358979323846;
		long double l= 3.14159265358979323846;
		float flp = 3.1415926e38;
		float flm = 3.1415926e-45;
		double dp = 3.1415926e307;
		double dm = 3.1415926e-324;
		long double ldp= 3.1415926e307;
		long double ldm = 3.1415926e-324;
		printf("a = %d	a+1=%d		sizeof int = %zd \n", a, a + 1, sizeof(a));
		printf("b = %u	b+1=%u		sizeof unsigned = %zd \n", b, b + 1, sizeof(b));
		printf("c = %hd	c+1=%hd		sizeof short = %zd \n", c, c + 1, sizeof(c));
		printf("d = %hu	d+1=%hu		sizeof unsigned short = %zd \n", d, d + 1, sizeof(d));
		printf("e = %ld	e+1=%ld		sizeof long = %zd \n", e, e + 1, sizeof(e));
		printf("f = %lu	f+1=%lu		sizeof unsigned long = %zd \n", f, f + 1, sizeof(f));
		printf("g = %lld	g+1=%lld		sizeof long long = %zd \n", g, g + 1, sizeof(g));
		printf("h = %llu	h+1=%llu		sizeof unsigned long long = %zd \n", h, h + 1, sizeof(h));	
		printf("ch=%c	ASCII NO.=%d	sizeof char=%zd\n",ch,ch,sizeof(ch));
		printf("j=%.20f	j*10=%e		sizeof float=%zd\n", j, j*10, sizeof(j));
		printf("k=%.20f	k*10=%e		sizeof double=%zd\n", k, k * 10, sizeof(k));
		printf("l=%.20f	k*10=%e		sizeof long double=%zd\n", l, l * 10, sizeof(l));
		printf("flp=%e	flp*10=%e\n", flp,flp*10);
		printf("flm=%e	flm/10=%e\n", flm, flm / 10);
		printf("dp=%e	dp*10=%e\n", dp, dp * 10);
		printf("dm=%e	dm/10=%e\n", dm, dm / 10);
		printf("ldp=%e	ldp*10=%e\n", ldp, ldp * 10);
		printf("ldm=%e	ldm/10=%e\n", ldm, ldm / 10);
		getchar();
		return 0;
	}

【第四章】字符串和格式化输入/输出

4.1
	#include<stdio.h>
	#include<string.h>
	#define DENSITY 62.4//预处理：define 宏定义；
	int main(void)
	{
		float weight,volume;
		int size, letters;
		char name[40];//name是一个可容纳39字符的数组;
		printf("what's your first name?\n");
		gets(name);
		printf("what's your weight in pounds?\n");
		scanf_s("%f", &weight);
		size = sizeof name;
		letters = strlen(name);//strlen()函数获取字串长度；
		volume = weight / DENSITY;
		printf("%s,your volume is %.2f cubic feet.\n", name, volume);//%s 字符串转换说明；
		printf("also,your first name has %d letters.\n", letters);
		printf("we have %d bytes to store it.\n", size);
		getchar();
		getchar();
		return 0;
	}

	【字符串和字符】	
	字符串常量"X"和字符常量'X'不同
	区别1：'X'是基本类型char；“X”是派生类型(char 数组)
	区别2："X"实际上由两个字符组成'X'和空字符 \0	//空字符作为字符串的结束；

	#include<stdio.h>
	#include<string.h>
	#define PRAISE "You are an extraordinary being."
	int main(void)
	{
		char name[40];
		printf("what's your name?\n");
		gets(name);
		printf("hello,%s.%s\n", name, PRAISE);
		printf("your name of %zd letters occupies %zd memory cells.\n", strlen(name), sizeof name);
		printf("the phrase of parise has %zd letters,", strlen(PRAISE));
		printf("and occupies %zd memory cells.\n", sizeof PRAISE);
		getchar();
		getchar();
		return 0;
	}
	例输入'peter'；
	sizeof 运算符报告，name数组有40个存储单元，但是只有前5个单元用来存储peter，所以strlen()函数得出的结果是5；
	name数组的第6个单元存储空字符\0；strlen()并未将其计入；
	对于预定义的PRAISE 用strlen()得出字符串中的字符数为31(含空格、标点)，
	而sizeof运算符给出的数字为32，因为它把字符串末尾不可见的空字符也计算在内。
	该程序并未明确告诉计算机要给PRAISE字符串预留多少空间，所以它必须计算双引号内的字符数；
	
	关于sizeof后面是否带圆括号取决于运算对象是类型还是特定量；
	运算对象是类型时，圆括号必不可少，但对于特定量，可有可无。但是建议都加圆括号；
	
4.3	【常量和C预处理器 #define】
	circumference=3.14159*diameter；	//常量3.14159代表圆周率pi(π)
	circumference=pi*diameter；		//使用符号常量能更方便、表达更多信息；
	假设程序中多出使用一个常量，有时需要变更它的值，比如经常浮动的税率。
	如果程序使用符号常量，则只需更改符号常量定义，而不用在程序中查找使用常量的地方逐一修改；
	如何创建符号常量？

	方法1：声明一个变量，然后将该变量设置为所需的常量；如
	float taxrate；
	taxrate=0.015；
	这样做就给0.015这个常量提供了一个符号名，但是taxrate是一个变量，程序可能会无意间改变它的值；
	所以C语言提供了一个更好的方案――C预处理器。
	方法2：用预处理器来定义一个常量；如
	#define TAXRATE 0.015	//格式 #define NAME value
	编译程序时，程序中所有TAXRATE都会被替换成0.015；这过程被称为“编译时替换”，这样定义的常量也称明示常量；
	符号常量名一般建议用大写名；程序中看到大写名可以立刻明白这是个符号常量，而非变量；提高可读性；
	
	#include<stdio.h>
	#define PI 3.14159
	int main(void)
	{
		float area, circum, radius;
		printf("what's the radius of your pizza?\n");
		scanf_s("%f", &radius);
		area = PI * radius*radius;
		circum = 2.0*PI*radius;
		printf("your basic pizza parameters are as follow:\n");
		printf("circumference=%.2f,area=%.2f\n", circum, area);
		getchar();
		getchar();
		return 0;
	}

	#define指令还可以定义字符和字符串常量，前者使用单引号，后者使用双引号；如
	#define BEEP '\a'
	#define TEE 'T'
	#define ESC '\033'
	#define OOPS "Now you have done it!"
	
	const限定符，用于限定一个关键量为只读。声明如下
	const int MONTHS=12；	//MONTHS在程序中不可更改，值为12

	C头文件limits.h 和 float.h 分别提供了整数类型和浮点类型大小限制相关的详细信息；
	每个头文件都定义了一系列供实现使用的符号常量；例如limits.h头文件包含以下类似代码：
	#define INT_MAX +32767
	#define INT_MIX -32768
	这些明示常量代表int类型可以表示的最大值和最小值。如果系统使用32位的int，该头文件会为这些明示常量提供不同的值。
	如果在程序中包含limits.h头文件，就可以编写下面代码：
	#include<stdio.h>
	#include<limits.h>
	int main(void)
	{
		printf("Maxmum int value on this system=%d\n", INT_MAX);
		getchar();
		return 0;
	}
	类似的float.h也定义了一些明示常量；演示如下：

	#include<stdio.h>
	#include<limits.h>//整型限制
	#include<float.h>//浮点型限制
	int main(void)
	{
		printf("some number limits for this system:\n");
		printf("Biggist int =%d\n", INT_MAX);
		printf("Smallest long long =%lld\n",LLONG_MIN);
		printf("One byte=%d bits\n",CHAR_BIT);
		printf("Largest double=%e\n",DBL_MAX);
		printf("Smallest normal float=%e\n",FLT_MIN);
		printf("float precision =%d digits\n",FLT_DIG);
		printf("float epsilon=%e\n",FLT_EPSILON);
		getchar();
		return 0;
	}


4.4.2	【printf()】

	#include<stdio.h>
	#define PI 3.141593
	int main(void)
	{
		int num = 7;
		float pies = 12.75;
		int cost = 7800;
		printf("the %d contestants are %.2f berry pies.\n",num,pies);
		printf("the value of PI is %f.\n",PI);
		printf("farewell! thou art too dear for my possessing,\n");
		printf("%c%d.\n",'$',2*cost);	//printf()函数使用的是值，无论是变量、常量还是表达式的值			
		getchar();
		return 0;
	}

	printf()函数格式
	printf(“格式字符串”，待打印项1，待打印项2……)；
	格式字符串包含两种形式：1.需要实际打印的字符；2.转换说明，数量跟待打印项相对应
	
4.4.3	printf()的转换说明修饰符

	①标记
		(-、+、空格、#和0)，可以不使用标记或者使用多个标记；示例：“%-10d”左对齐10个格位；
		-：待打印项目左对齐
		+：显示值的正负符号；值为正，在值前面显示+；若为负显示-；
		空格：若值为正，占用一空格，若值为负，显示-号；
		#：把结果转换成另一种格式；%o格式则以0开始；%x则以0x开始；
		     对于所有的浮点格式，#保证即使后面没有任何数字，也打印一个小数点字符；
		     对%g格式，#防止结果后面的0被删除；

	②数字 
		显示字段宽度，如果该字段不能容纳待打印的数字或者字符串，系统会使用更宽的字段；示例："%4d"

	③.数字
		标明精度；
		对于%e、%E和%f转换，表示小数点右边数字的位数；示例“%.2f”保留小数点后两位；
		对于%g、%G转换，表示有效数字最大位数；
		对于%s转换，表示待打印字符的最大数量；
		对于整型转换，表示待打印数字的最小位数；
		如有必要，使用前导0来达到这个位数
		只使用.表示其后跟随一个0，所以%.f和%.0f相同
	④字符：
		h：和整型转换说明一起使用，表示short int或unsigned short int类型的值；
		hh：signed char或unsigned char；
		j：intmax_t或uintmax_t；
		l：long int或 unsigned long int；
		ll：long long  或unsigned long long；
		L：long double；
		t：ptrdiff_t；
		z：size_t；

	类型可移植性：sizeof运算符以字节为单位返回类型或值的大小；系统只规定了该值为unsigned整数；
		      如果移植要查找返回值类型选择用u-int、u-long甚至u-long long
	float参数的转换：有double和long double类型的转换，printf()函数中float类型函数自动转换成double类型；	

	#include<stdio.h>
	#define PAGES 959
	int main(void)
	{
		printf("*%d*\n",PAGES);	//*959*	//不带任何修饰符，默认输出结果；
		printf("*%2d*\n", PAGES);	//*959*	//修饰符要求2字段宽度，但待打印整数有3位数字，字段扩大字段宽度；
		printf("*%10d*\n", PAGES);	//*       959*//输出10个字段宽度，7空格+3数字；
		printf("*%-10d*\n", PAGES);	//*959       *//输出10个字段宽度，7空格+3数字；-修饰符，数字左靠齐；
		getchar();
		return 0;
	}

	#include<stdio.h>
	int main(void)
	{
		const double RENT = 3852.99;	//const限定变量只读；
		printf("*%f*\n", RENT);	//*3852.990000*	//字段宽度和小数点后面的位数均为默认
		printf("*%e*\n", RENT);	//*3.852990e+03*	//指数写法；小数点左侧1位，右侧6位；
		printf("*%4.2f*\n", RENT);	//*3852.99*	//4字段宽度被扩大，小数点后两位；
		printf("*%3.1f*\n", RENT);	//*3853.0*		//3字段宽度也失效，小数点后保留1位，四舍五入；
		printf("*%10.3f*\n", RENT);	//*  3852.990*	//10字段宽度指定生效，小数点后三位；
		printf("*%10.3E*\n", RENT);	//* 3.853E+03*	//10字段宽度生效；小数点后保留三位，指数写法；
		printf("*%+4.2f*\n", RENT);	//*+3852.99*	//显示正负号；指定字段宽度失效；保留2位小数；
		printf("*%010.2f*\n", RENT);	//*0003852.99*	//指定10字段宽度，空位用0填充，小数点后保留2位；
		getchar();
		return 0;
	}
	
	#include<stdio.h>
	int main(void)
	{
		printf("%x %X %#x\n",31,31,31);		//1f 1F 0x1f
		printf("**%d**% d**% d**\n",42,42,-42);		//**42** 42**-42**
		printf("**%5d**%5.3d**%05d**%05.3d**\n",6,6,6,6);	//**    6**  006**00006**  006**
		getchar();
		return 0;
	}

	字符串输出：
	
	#include<stdio.h>
	#define BLURB "Authentic imitation!"
	int main(void)
	{
		printf("[%2s]\n", BLURB);	//指定2字段宽度，但是被扩大为可容纳所有字符字段；
		printf("[%24s]\n", BLURB);	//输出24字段宽度字符串，多余部分会显示出左边空位；
		printf("[%24.5s]\n", BLURB);	//.5精度限制输出待打印字符的个数，只输出5个字符；
		printf("[%-24.5s]\n", BLURB);	//-标记使得文本左对齐输出；
		getchar();
		return 0;
	}


4.4.4	【转换说明】
	转换说明把以二进制格式存储在计算机中的值转换成一系列字符(字符串)以便于显示；
	转换不是原始值被替换成转换后的值，而是一种翻译说明；%d的意思是把给定的值翻译成十进制整数输出；

	1.转换不匹配问题：

	①整型转换不匹配示例：
	
	#include<stdio.h>
	#define PAGES 336
	#define WORDS 65618
	int main(void)
	{
		short num=PAGES;
		short mnum=-PAGES;
		printf("num as short and unsigned short:%hd %hu\n",num,num);		//336 336
		printf("-num as short and unsigned short:%hd %hu\n",mnum,mnum);		//-336 65200
		printf("num as int and char:%d %c\n",num,num);				//336 P
		printf("WORDS as int,short,and char:%d %hd %c",WORDS,WORDS,WORDS);	//65618 82 R
		getchar();
		return 0;
	}

	第三行演示了把一个大于255的值转换成字符会发生的情况，short int是2字节；char是1字节；
	当printf()用%c打印336时候，它只查看336数字2字节中的后1字节；这种被称为截断：
	P在ASCII表中为80；   80在二进制中为 01010000；
		而336的二进制为 00000001 01010000；
	该数字被解释成“以256为摸”(modulo256),即该数字除以256后取其余数。

	②整型与浮点型混淆示例：
	
	#include<stdio.h>
	int main(void)
	{
		float n1=3.0;
		double n2=3.0;
		long n3=2000000000;
		long n4=1234567890;
		printf("%.1le %.1le %.1le %.1le\n",n1,n2,n3,n4);	//3.0e+00 3.0e+00 3.1e+46 7.1e-305
		printf("%ld %ld\n",n3,n4);			//2000000000 1234567890
		printf("%ld %ld %ld %ld\n",n1,n2,n3,n4);		//0 1074266112 0 1074266112
		getchar();
		return 0;
	}

	最后一行输出n3,n4也出错了；结果显示如果printf()语句有其他不匹配的地方，即使用对了转换说明也会出错
	问题出在C如何把信息传递给函数，即参数传递机制；

	函数调用 printf("%ld %ld %ld %ld\n",n1,n2,n3,n4);
	该调用告诉计算机把n1,n2,n3,n4的值传递给程序；这是一种常见的参数传递方式：
	程序把传入的值放入被称为“栈”(stack)的内存区域；

	计算机根据变量类型(而不是根据转换说明) 把这些值放入栈中；
		因此，n1被存储在栈中，占8字节(float类型被转换成double类型)；n2也占8字节；
		而n3和n4在栈中分别占4字节；

	然后控制转到printf()函数，
	该函数根据转换说明(而不是根据变量类型)从栈中读取值：
		%ld表明printf()应该读取4字节，所以只读取了n1的前半部分；并被解释成一个long类型整数；
		根据下一个%ld，printf()再读取4字节，读取了n1的后半部分；被解释成第二个long类型整数；
		类似的根据第三个和第四个%ld，分别读取了n2的前、后两部分，并被解释成n3，n4;

	2.printf()的返回值
	
	#include<stdio.h>
	int main(void)
	{
	int rep;
	rep=printf("hello world\n");		//输出printf()，并将这个printf()的返回值赋给rep
	printf("rep have %d characters",rep);	//输出rep返回值，hello+空格+world+\n=5+1+5+1=12字符数；
	getchar();
	return 0;
	}

	
4.4.5	【scanf()】
	printf()函数使用变量、常量和表达式；scanf()函数使用指向变量的指针；
	1.如果用scanf()读取基本变量类型的值，在变量名前加上一个&；
	2.如果用scanf()把字符串读入字符数组中，不要使用&；

	#include<stdio.h>
	#pragma warning(disable:4996)；
	int main(void)
	{
		int age;
		float assets;
		char pet[30];
		printf("Enter your age,assets,and favorite pet.\n");
		scanf("%d %f", &age, &assets);
		scanf("%s", pet);
		printf("your age : %d,\nand your assets: $%.2f,\nand your favorite pet:%s.\n", age, assets, pet);
		getchar();
		getchar();
		return 0;
	}

	【scanf_s解决办法】
	#include<stdio.h>
	int main(void)
	{
		int age;
		float assets;
		char pet[30];
		printf("Enter your age,assets,and favorite pet.\n");
		scanf_s("%d %f", &age, &assets);
		scanf_s("%s", pet,30);				/*scanf_s(,,)第三个参数的数字是限制读取边界*/
		printf("your age : %d,\nand your assets: $%.2f,\nand your favorite pet:%s.\n", age, assets, pet);
		getchar();
		getchar();
		return 0;
	}



	
	示例里面的输入三个参数，可以用回车键、tab键或者空格键来隔开；所以可以将输入在一行或者多行进行；
	其中%c是例外，scanf()会读取每个字符，包括空白。

	scanf()转换说明
	
	%c		把输入解释成字符；
	%d		把输入解释成有符号十进制整数；
	%e、%f、%g、%a	把输入解释成浮点数； 
	%E、%F、%G、%A	把输入解释成浮点数；
	%i		把输入解释成有符号十进制整数；
	%o		把输入解释成有符号八进制整数；
	%p		把输入解释成指针(地址)；
	%s		把输入解释成字符串，到下一个空白字符之前；
	%u		把输入解释成无符号十进制整数；
	%x、%X		把输入解释成有符号十六进制整数；

	scanf()如何读取输入：	
	①假设scanf()根据一个%d转化说明读取一个整数：
	scanf()函数每次读取一个字符，跳过所有空白字符，直到遇到第一个非空白字符开始读取；
	因为要读取整数，所以scanf()开始寻找一个数字字符或者一个符号(+或-)，
	如果找到一个数字或符号，便保存该字符，并读取下一个字符，如果下一个字符是数字，保存并读取下一个字符；
	scanf()不断地读取和保存字符，直到遇到非数字字符，便认为读到了整数的末尾；
	scanf()将非数字字符放回输入，这意味着下一次读取输入时，首先读到的就是这个被放回的非数字字符；
	最后scanf()计算已经读取的字符(可能还有符号)对应的数值，并将计算后的值放入指定变量中。
	
	上例中，如果第一个非空白字符是A而不是数字，scanf()将停在那里，并把A放回输入中，而不会把值赋给变量；
	如果使用字段宽度，scanf()会在字段结尾或者第一个空白字符处停止读取(满足其中之一就停止读取)

	②其他数值匹配的转换说明跟%d情况大致相同，区别在于scanf()会把更多字符识别成数字的一部分，比如十六进制A~F；
	③浮点转换说明还要求scanf()识别小数点、e记数法和新增的p计数法；
	④使用%s转换说明时，scanf()会读取除空白外所有字符；scanf()跳过空白开始读取第一个非空白字符并保存，直到下一个空白；
	⑤除了%c，其他转换说明都会自动跳过待输入值前所有空白；

	scanf()返回值
	scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0；
	当scanf()检测到"文件结尾"时，会返回EOF(EOF是stdio.h中定义的特殊值，通常#define指令把EOF定义为-1)

4.4.6	printf()和scanf()的*修饰符
	
	printf()的*修饰符：如果转换说明是%*d。那么参数列表中应包含*和d对应的值；同时也可用于浮点值指定精度和字段宽度；
	范例：
	#include<stdio.h>
	int main(void) 
	{
		unsigned width, precision;	//width:字段宽度;precision:精度;
		int number = 256;		//演示1输出项；
		double weight = 242.5;	//演示2输出项；

		printf("Enter a field width:\n");			//指定字段宽度；
		scanf_s("%d", &width);			//给字段宽度赋值；
		printf("The number is :%*d:\n",width,number);	//输出1 number；*按照指定输出字段宽度；

		printf("Now enter a width and a precision:\n");	//指定字段宽度和显示精度；
		scanf_s("%d %d",&width,&precision);		//读取宽度和精度设定；
		printf("Weight=%*.*f\n",width,precision,weight);	//输出2 weight；*.*前者字段宽度后者小数点后显示精度
		printf("Done!\n");

		getchar();
		getchar();
		return 0;
	}


	scanf()的*修饰符：把*放在%和转换字符之间，会让scanf()跳过对应的输出项；在程序需要读取文件中特定列的内容时可用上；
	范例：

	#include<stdio.h>
	int main(void)
	{
		int a,b,c;

		printf("Please enter three integers:\n");
		scanf_s("%*d %*d %d", &a,&b,&c);
		printf("The last integer was %d\n",a);

		getchar();
		getchar();
		return 0;
	}

4.4.7	printf()的用法提示
	①使用足够大的固定字段宽度让输出整齐美观；
	比如要输出三次：printf("%d %d %d\n",a,b,c,);，若用户输入不同变量，则输出可能是
	22 234 3222
	345 8 66	
	6789 224 37
	
	修改后：printf("%4d %4d %4d\n",a,b,c,);
	    22       234   3222
	  345           8      66	
	6789        224      37

	②如果要在文字中嵌入一个数字，通常指定一个小于或等于该数字宽度的字段会比较方便；
	如嵌入一个10.22
	printf("Count Jack ran %.2f miles in 3 hours.\n",distance);
	Count Jack ran 10.22 miles in 3 hours.
	若转换说明为printf("Count Jack ran %8.2f miles in 3 hours.\n",distance);
	Count Jack ran         10.22 miles in 3 hours.

4.7 	练习
	1.编写一个程序，提示用户输入名和姓，然后以“名，姓”的格式打印出来
	#include<stdio.h>
	int main(void)
	{
		char name1[40], name2[40];
		printf("Please enter your first name.\n");
		scanf_s("%s", name1, 40);
		printf("please enter your family name.\n");
		scanf_s("%s", name2, 40);
		printf("so your neme is %s,%s.", name1, name2);
		getchar();
		getchar();
		return 0;
	}
	
	2.编写一个程序，提示用户输入名和姓，并执行以下操作：
	a,打印名和姓，包括双引号；
	b.在宽度为20的字段右端打印名和姓，包括双引号；c.换字段左端；
	d.在比姓名宽度宽3的字段中打印名和姓。

	#include<stdio.h>
	int main(void)
	{
		char name1[40], name2[40];
		int a, b,c;

		printf("Please enter your first name.\n");
		scanf_s("%s", name1, 40);
		printf("please enter your family name.\n");
		scanf_s("%s", name2, 40);
		a = strlen(name2);
		a = 20 - a - 1;
		b = strlen(name1);
		b = -(20 - b - 1);
		c = strlen(name1)+ 3;

		printf("so your neme is \"%s.%s\"\n", name1, name2);
		printf("so your neme is \"%*s.%s\"\n", a, name1, name2);
		printf("so your neme is \"%s.%*s\"\n", name1, b, name2);
		printf("so your neme is \"%*s.%s\"\n", c,name1,name2);
		getchar();
		getchar();
		return 0;
	}

	3.编写一个程序，读取一个浮点数，首先以小数点记数法打印，然后以指数记数法打印。
	用下面的格式进行输出：
	a. 输入21.3或者2.1e+001；
	b.输入21.290或2.129E+001;
	#include<stdio.h>
	int main(void) 
	{
		float a;
		scanf_s("%f", &a);
		printf("%f\n", a);
		printf("%e", a);
		getchar();
		getchar();
		return 0;
	}

	4.编写一个程序，提示用户输入身高和姓名，然后以下面的格式显示用户输入信息：

	Dabney, you are 6.208 feet tall
	使用float类型，并用/作为除号，要求用户以mm为单位输入身高以米输出

	#include<stdio.h>
	#include<Windows.h>
	int main(void) 
	{
		float height;
		float feettall;	
		char firstname[40];
		char familyname[40];	

		printf("Pleast enter your height in feet\n");
		scanf_s("%f", &feettall);
		printf("Pleast enter your height in mm\n");
		scanf_s("%f", &height);
	
		printf("Pleast enter your first name\n");
		scanf_s("%s", firstname,40);
		printf("Pleast enter your family name\n");
		scanf_s("%s", familyname,40);	
	
		system("cls");
		printf("%s.%s, you are %.3f feet tall\n",firstname,familyname,feettall);
		printf("you are %.3f meters tall.", height/1000);

		getchar();
		getchar();
		return 0;
	}

	5.编写一个程序，提示用户输入以兆位每秒(Mb/s)为单位的下载速度和以兆字节(MB)为单位的文件大小；
	程序中应计算文件的下载时间，1字节等于8位，使用float，并用/作除号；
	要以下面格式打印三个变量的值，显示小数点后面两位数字：
	At 18.12 megabits per second,a file of 2.20 megabytes downloads in 0.97 seconds.

	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		float speed, file;

		printf("Please enter your download speed by Mb/s\n");
		scanf_s("%f", &speed);
		printf("Please enter your download file megabntes\n");
		scanf_s("%f", &file);
	
		system("cls");
		printf("At %.2f megabits per second,a file of %.2f megabytes downloads in %.2f seconds.", speed, file,file*8/speed);
		getchar();
		getchar();
		return 0;
	}
	
	6.编写一个程序，先提示用户输入名，然后输入姓。在一行打印输入的名和姓，再下一行分别打印名和姓的字母数；
	字母数要和相对应的名和姓结尾对齐，如下所示：
	Melissa Honeybee
	         7               8
	换字母开头对齐：
	Melissa Honeybee
	7           8
	
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		char firstname[40],familyname[40];
		int a, b;

		printf("Please enter your first name.\n");
		scanf_s("%s", firstname, 40);
		a = strlen(firstname);
		printf("Please enter your family name.\n");
		scanf_s("%s", familyname, 40);
		b = strlen(familyname);
	
		system("cls");
		printf("%s %s\n%*d %*d\n", firstname, familyname,a,a,b,b);
		printf("%s %s\n%-*d %-*d\n", firstname, familyname, a, a, b, b);
		getchar();
		getchar();
		return 0;
	}

	//关于输入姓名超出给定范围或者格式，如何删除冗余输入不影响后续的暂行办法，如下如果name[4]就没法解决超出3字节问题；
	#include<stdio.h>
	#pragma   warning(disable:4996)
	int main(void)
	{
		char name[40];
		int age,a,i;
		printf("please enter your name.\n");
		scanf_s("%s", name, 40);

		//for (a = 0; a < 4; a++) { name[a] = getchar(); }
		//fflush(stdin);
		setbuf(stdin, NULL);
		//while ((name[4] = getchar()) != EOF && name[4] != '\n');
		i = strlen(name);
		printf("your name have %d byte\n\n", i);

		printf("please enter your age.\n");
		scanf_s("%d", &age);

		printf("\nwell,%s,you are %d years old.\n", name, age);

		getchar();
		getchar();
		return 0;
	}

	7.编写一个程序，将一个double类型的变量设置为1.0/3.0，将一个float类型的变量设置为1.0/3.0；
	分别显示两次计算的结果各3次：
	一次显示小数点后面6位数字；一次显示小数点后12位数字；一次显示小数点后16位数字；
	程序中要包含float头文件，并显示FLT_DIG和DBL_DIG的值；
	1.0/3.0的值与这些值一致吗？
	
	#include<stdio.h>
	#include<float.h>
	int main(void) 
	{
		double a;
		float b;
		a = 1.0 / 3.0;
		b = 1.0 / 3.0;
		printf("%.6f\n%.12f\n%.16f\n", a, a, a);
		printf("%.6f\n%.12f\n%.16f\n", b, b, b);
		printf("%d\n%d", FLT_DIG, DBL_DIG);
		getchar();
		return 0;
	}


	8.编写一个程序，提示用户输入旅行的里程和消耗的汽油量，然后计算并显示消耗每加仑汽油行驶的英里数，保留一位小数；
	1加仑约3.785升；1英里约1.609千米；将单位是英里/加仑的值转换为升/100公里并显示结果，保留一位小数点；
	注：美国采用的方案测量消耗单位燃料的里程值，而欧洲采用单位距离消耗的燃料测量方案；
	使用#define创建符号常量或使用const限定符创建变量来表示两个转换系数；
	
	#include<stdio.h>
	#define c 100*3.785/1.609
	int main(void)
	{
		float a, b;
	
		printf("Please enter your mileage:\n");
		scanf_s("%f", &a);
		printf("Please enter your fuel consumed in gallon:\n");
		scanf_s("%f", &b);
	
		printf("your comprehensive oil consumption is:\n");
		printf("MPG:%.1f \n", a/b);
		printf("%.1f L/100KM", c*b/a );
		getchar(); 
		getchar();
		return 0;
	}


【第五章】运算符、表达式和语句

	
5.1 	循环

	数据对象：用于储存值的数据存储区域；
	左值：用于标明特定数据对象的名称或表达式；对象定位值；
	右值：能赋值给可修改左值的量，且本身不是左值；
	运算符：基本运算符=+-*/
	
5.2.1 	赋值运算符=
	
	#include<stdio.h>
	int main(void)
	 {
		int jane, tarzan, cheeta;
		cheeta = tarzan = jane = 68; //三重赋值；
		printf("cheeta    tarzan    jane\n");
		printf("%4d %8d %8d\n", cheeta, tarzan, jane);
		getchar();
		return 0;
	}	

	赋值顺序从右往左，首先把86赋值给jane,然后再赋值给tarzan；最后赋值给cheeta；

5.2.2	加法运算符+
	printf("%d",4+20);打印的是24而不是表达式4+20；
	相加的对象可以是变量也可以是常量；
	
5.2.3	减法运算符-
	takehome=224-24;
	+和-运算都被成为二元运算符，即这些运算符需要两个运算对象才能完成操作；

5.2.4	符号运算符-和+
	减号还可以用于标明或改变一个值的代数符号如
	rocky=-12；
	smokey=-rocky；
	smokey最后的值为12；
	
	二元：36-12 值为24
	一元：-16	   值为-16
	二者兼有：-（12-20） 值为8

5.2.5	乘法运算符*
	例：C没有平方函数，如果需要打印一个平方表，则：
	/*squares.c――计算1-20的平方*/
	#include<stdio.h>
	int main(void)
	{
		int num;
		num = 1;
		while (num < 21) 
		{
			printf("%d*%d=%d\n", num, num, num*num);
			num = num + 1;
		}
		getchar();
		return 0;
	}
	
	1.指数增长：
	棋盘上的米粒：第一格放1粒，第二格放2粒，第三格放4粒，第四格放8粒；
	以此类推，放满64个格子数；
	/*指数增长，让程序计算出每个格子放多少，并计算总数*/
	#include<stdio.h>
	int main(void)
	{
		int a;
		double b,c;
		a = 1;	//格子数
		b = 1.0;	//格子上米粒数
		c = 1.0;	//总米粒数
		printf("格子数	米粒数		总数\n");
		while(a<65)
		{				
			printf("%d:	%.2e	%.2e\n",a, b,c);	
			b = 2 * b;		
			a = a + 1;		
			c = c + b;		
		}
		getchar();
		return 0;
	}

	改进：制作一个指数函数查看表1；
	#include<stdio.h>
	#include<Windows.h>
	int main(void)
	{
		int count,num;
		double result;
		count = 1;	
		result = 1.0;
		printf("please enter the number as the powerof 2\n");
		scanf_s("%d", &num);
		while (count < num+1)
		{
			count = count + 1;		
			result = 2 * result;
		}
		system("cls");
		printf("the %d power of 2 is %.2e\n", num, result);	
		getchar();
		getchar();
		return 0;
	}
	
	改进：制作一个指数函数查看表2；
	#include<stdio.h>
	int main(void)
	{
		int count,n,num;
		double result;
		count = 1;	
		n = 0;
		result = 1.0;
		printf("please enter the number as the powerof 2\n");
		scanf_s("%d", &num);

		printf("n.	result\n");
		while (count < num+2)
		{		
			printf("%d	%.2e\n", n, result);
			count = count + 1;		
			result = 2 * result;
			n = count - 1;		
		}	
		getchar();
		getchar();
		return 0;
	}
	
5.2.6	除法运算符/
	整数除法和浮点数除法不同，浮点数除法的结果是浮点数，而整数除法的结果是整数，没有小数部分；
	所以整数除法使得5/3这样的情况，实际结果有小数部分，但是被丢弃，这过程称为截断；
	#include<stdio.h>
	int main(void)
	{
		printf("int division: 5/4 is %d\n", 5 / 4);		//1
		printf("int division: 8/4 is %d\n", 8 / 4);		//2
		printf("int division: 7/4 is %d\n", 7 / 4);		//1，截断为丢弃整个小数部分，不会四舍五入；
		printf("float division: 7.0/4.0 is %.2f\n", 7.0 / 4.0);	//1.75
		printf("mixed division: 7.0/4 is %.2f\n", 7.0 / 4);	//1.75，尽量避免此类；4会被先转化成4.0
		getchar();
		return 0;
	}

5.2.7	运算符优先级：

	（）	从左往右
	+ -(一元)	从右往左(正负)
	* /	从左往右
	+ -(二元)	从左往右(加减)
	=	从右往左

5.3	其他运算符：
	
5.3.1	sizeof运算符和size_t类型
	#include<stdio.h>
	int main(void)
	{
		int n = 0;
		size_t intsize;	
		intsize = sizeof(int);	
		printf("n=%d,n has %u bytes;all ints have %u bytes.\n", n, sizeof n, intsize);
		getchar();
		return 0;
	}

5.3.2	求模运算符%
	用于整数运算，给出左侧整数除以右侧整数后的余数；
	13%5的结果为3；

	#include<stdio.h>
	#define SEC_PER_MIN 60
	int main(void)
	{
		int sec, min, left;

		printf("Convert seconds to minutes and secods!\n");
		printf("Enter the number of seconds(<=0 to quit):\n");
		scanf_s("%d", &sec);
		while(sec>0)
		{
			min = sec / SEC_PER_MIN;//截断分钟数；
			left = sec % SEC_PER_MIN;//剩下的秒数；
			printf("%d seconds is %d minutes, %d seconds.\n", sec, min, left);
			printf("Enter next value(<=0 to quit):\n");
			scanf_s("%d", &sec);
		}
		printf("Done!\n");
		getchar();
		getchar();
		return 0;
	}
	
	关于负数求模；
	11/5 得2	11%5得1
	11/-5得-2	11%-2得1
	-11/-5得2	-11%-5得-1
	-11/5得-2	-11%-2得-1
	综上：
	如果第一个运算对象是负数，那么结果就为负数；
	如果第一个运算对象为正数，那么求模结果也是正数；	

	实际上，只要a和b是整数，便可通过 a-(a/b)*b来计算；

	例如：-11%5：
	  -11-（-11/5）*5
	=-11-（-2）*5
	=-11-（-10）
	=-1


5.3.3	递增运算符++
	执行简单的任务，将其运算对象递增1；分为：
	1.前缀模式		 a++
	2.后缀模式		 ++a
	
	【前后缀相似之处】

	#include<stdio.h>
	int main(void) 
	{
		int ultra = 0, super = 0;
		while (super < 5)
		{
			super++;
			++ultra;
			printf("super=%d, ultra=%d\n", super, ultra);
		}
		getchar();
		return 0;
	}

	程序输出：
	super=1, ultra=1
	super=2, ultra=2
	super=3, ultra=3
	super=4, ultra=4
	super=5, ultra=5

	#include<stdio.h>
	int main(void) 
	{
		int ultra = 0, super = 0;
		while (super++ < 5)//super=0<5,super+1=0+1=1;执行循环,
		{
			++ultra;//ultra=1；使用ultra之前先递增ultra;
			printf("super=%d,ultra=%d\n", super, ultra);
		}	
		getchar();
		return 0;
	}

	【前后缀区别】
	#include<stdio.h>
	int main(void) 
	{
		int a=1,b=1;
		int a_post, pre_b;
		a_post = a++;	//后缀，使用a值之后，递增a
		pre_b = ++b;	//前缀，使用b值之前，递增b
		printf("a	a_post	b	pre_b\n");
		printf("%d	%5d	%5d	%5d\n", a, a_post, b, pre_b);	
		getchar();
		return 0;
	}

	结果为a=2,a_post=1,b=2,pre_b=2


	前缀形式：
	q=2*++a;		首先，a递增1；然后2乘以a并将结果给q；
	后缀形式；
	q=2*a++;		首先，2乘以a并将结果给q；然后，a递增1；

5.3.4	递减运算符--（与++同；略）
	
5.3.5	优先级
	递增递减运算符都有很高的优先级，只有圆括号优先级高于它们；
	因此，x*y++表示是(x)*(y++),而不是(x*y)(++),而且后者无效，递增和递减运算符只能影响一个变量；
	如果n++是表达式的一部分，可以视其为 先使用n，再递增；
	而++n则表示 先递增n，在使用；

5.3.6	如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增递减；
	如果一个变量多次出现在一个表达式中，不要对该变量使用递增递减

5.4	表达式和语句

5.4.1	表达式
	表达式由运算符和运算对象组成，最简单的表达式是一个单独的运算对象，一些表达式由子表达式组成；
	每个表达式都有一个值；

5.4.2	语句	
	一条语句相当于一条完整的计算机指令，大部分语句都以分号结尾；因此：
	legs=4 	只是一个表达式
	legs=4;	则是一条语句
	最简单的语句是空语句
	；//空语句
	C把末尾加上一个分号的表达式都看作是一条语句，即表达式语句
	8；
	3+4；
	但是这些语句在程序中什么也不做，不算是正真有用的语句
	确切的说，语句可以改变值或者调用函数：
	x=25;
	++x;
	y=sqrt(x);
	虽然一条语句相当于一条完整的指令，但并不是所有的指令都是语句，比如：
	x=6+(y=5);
	其中y=5是一条完整的指令，但是它只是语句的一部分，用分号识别这种情况下的语句；

	#include<stdio.h>
	int main(void) 
	{
		int count, sum;		//声明；
		count = 0;			//表达式语句
		sum = 0;			//表达式语句
		while (count++ < 20)
			{sum= sum + count;	}	//迭代语句	
		printf("sum=%d\n", sum);		//表达式语句
		return 0;			//跳转语句
	}
	
	声明创建了名称和类型，并分配内存位置，但声明不是表达式语句，如删分号，剩下也不是表达式，没有值；
	赋值表达式语句：一个变量名，后面是一个赋值运算符，再跟一个表达式，最后分号结尾；
	函数表达式语句会引起函数调用；在上例中，调用printf()函数打印结果。
	while()语句有3部分组成，首先是关键字while，圆括号内为待测试条件；如果条件为真，则执行while循环里的语句；
	while语句是一种迭代语句，也称为结构化语句；

	【副作用和序列点】

	副作用：是对数据对象或文件的修改；例如
	a=50;
	它的副作用是将变量的值设置为50；
	类似的，调用printf()函数时，它显示的信息其实是副作用(printf()的返回值是待显示字符的个数)；

	序列点：是程序的执行点，在该点上，所有的副作用都在进入下一步之前发生；
	在C中，语句中的分号标记了一个序列点，
	意思是在该语句中，赋值、递增、递减对运算对象的改变必须在程序执行下一条语句前完成；
	任何一个完整表达式的结束也是一个序列点。
	完整表达式：就是指这个表达式不是另一个更大表达式的子表达式；例如：
	表达式语句中的表达式；while循环中的测试条件表达式；

	序列点有助于分析后缀递增何时发生，例如：
	
	while(a++<10) 
		printf("a=%d\n",a);

	举例，a=5；
	该例子中，如果按照“先使用值，再递增”的后缀意思，会先printf()输出guests的值,再递增它；
	显示数字 a=5;然后a递增变成6；
	但是，表达式guests++<10是一个完整的表达式；是while循环的测试条件；所以该表达式的结束就是一个序列点；
	所以保证在执行printf()之前，发生副作用；a递增a=6;printf()输出%d调用a的值为6；
	同时，使用后缀递增保证了a在完成与10的比较后才进行递增，即a=5<10成立，输出6这个动作得以执行；

5.4.3	复合语句(块)
	
	复合语句是用花括号括起来的一条或多条语句，也成为块block；
	
	/*程序段1*/

	a=0;
	while(a++<10)
		 {b=10*a+2;}
	printf("b=%d",b);
	
	/*程序段2*/

	a=0;
	while(a++<10)
	 {
		b=10*a+2; 
		printf("b=%d",b);
	}

	程序段1，while循环只有一条赋值表达语句，while这行运行至下一个分号；循环结束后printf()只会被调用一次；
	程序段2，花括号确保两条语句都是while循环的一部分，每执行一次循环都调用一次printf()函数；

	风格提示：循环中的缩进，对编译器不起作用，编译器通过花括号和while循环的结构来识别和解释指令；
	这里的缩进是为了让使用者可以一眼看出程序是如何组织的；使用缩进和花括号的位置可以进一步提高可读性；

5.5	类型转换
	通常，在语句和表达式中应使用类型相同的变量和常量；
	但是如果使用混合类型，C虽然会采用一套规则自动转化类型，但是有一定的危险性；
	1.当类型转换出线在表达式时，无论是unsigned还是signed的char和short都会被自动转为int；
	  如有必要会被转换成unsigned int（若short与int大小相同，unsigned short就比int大）；
	  这种情况下，unsigned short会被转成unsigned int；
	由于都是从较小型转换为较大类型，所以这些转换被称为升级promotion；
	
	2.涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别；
	3.类型的级别从高至低：long double>double>float>unsignedlong long>long long>unsigned long>
			long>unsigned int>int>
	  例外的情况是，当long和int大小相同时，unsigned int 比long 的级别高，short和char均被升级到int或者unsigned int；

	



















